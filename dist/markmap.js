(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name2 in all)
      __defProp(target, name2, { get: all[name2], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/katex/dist/katex.js
  var require_katex = __commonJS({
    "node_modules/katex/dist/katex.js"(exports, module) {
      (function webpackUniversalModuleDefinition(root3, factory) {
        if (typeof exports === "object" && typeof module === "object")
          module.exports = factory();
        else if (typeof define === "function" && define.amd)
          define([], factory);
        else if (typeof exports === "object")
          exports["katex"] = factory();
        else
          root3["katex"] = factory();
      })(typeof self !== "undefined" ? self : exports, function() {
        return (
          /******/
          function() {
            "use strict";
            var __webpack_require__ = {};
            !function() {
              __webpack_require__.d = function(exports2, definition) {
                for (var key in definition) {
                  if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
                    Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
                  }
                }
              };
            }();
            !function() {
              __webpack_require__.o = function(obj, prop2) {
                return Object.prototype.hasOwnProperty.call(obj, prop2);
              };
            }();
            var __webpack_exports__ = {};
            __webpack_require__.d(__webpack_exports__, {
              "default": function() {
                return (
                  /* binding */
                  katex_webpack
                );
              }
            });
            ;
            class ParseError {
              // Error start position based on passed-in Token or ParseNode.
              // Length of affected text based on passed-in Token or ParseNode.
              // The underlying error message without any context added.
              constructor(message, token) {
                this.name = void 0;
                this.position = void 0;
                this.length = void 0;
                this.rawMessage = void 0;
                let error2 = "KaTeX parse error: " + message;
                let start2;
                let end2;
                const loc = token && token.loc;
                if (loc && loc.start <= loc.end) {
                  const input = loc.lexer.input;
                  start2 = loc.start;
                  end2 = loc.end;
                  if (start2 === input.length) {
                    error2 += " at end of input: ";
                  } else {
                    error2 += " at position " + (start2 + 1) + ": ";
                  }
                  const underlined = input.slice(start2, end2).replace(/[^]/g, "$&\u0332");
                  let left;
                  if (start2 > 15) {
                    left = "\u2026" + input.slice(start2 - 15, start2);
                  } else {
                    left = input.slice(0, start2);
                  }
                  let right;
                  if (end2 + 15 < input.length) {
                    right = input.slice(end2, end2 + 15) + "\u2026";
                  } else {
                    right = input.slice(end2);
                  }
                  error2 += left + underlined + right;
                }
                const self2 = new Error(error2);
                self2.name = "ParseError";
                self2.__proto__ = ParseError.prototype;
                self2.position = start2;
                if (start2 != null && end2 != null) {
                  self2.length = end2 - start2;
                }
                self2.rawMessage = message;
                return self2;
              }
            }
            ParseError.prototype.__proto__ = Error.prototype;
            var src_ParseError = ParseError;
            ;
            const deflt = function(setting, defaultIfUndefined) {
              return setting === void 0 ? defaultIfUndefined : setting;
            };
            const uppercase = /([A-Z])/g;
            const hyphenate = function(str) {
              return str.replace(uppercase, "-$1").toLowerCase();
            };
            const ESCAPE_LOOKUP = {
              "&": "&amp;",
              ">": "&gt;",
              "<": "&lt;",
              '"': "&quot;",
              "'": "&#x27;"
            };
            const ESCAPE_REGEX = /[&><"']/g;
            function utils_escape(text3) {
              return String(text3).replace(ESCAPE_REGEX, (match2) => ESCAPE_LOOKUP[match2]);
            }
            const getBaseElem = function(group) {
              if (group.type === "ordgroup") {
                if (group.body.length === 1) {
                  return getBaseElem(group.body[0]);
                } else {
                  return group;
                }
              } else if (group.type === "color") {
                if (group.body.length === 1) {
                  return getBaseElem(group.body[0]);
                } else {
                  return group;
                }
              } else if (group.type === "font") {
                return getBaseElem(group.body);
              } else {
                return group;
              }
            };
            const isCharacterBox = function(group) {
              const baseElem = getBaseElem(group);
              return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom";
            };
            const assert = function(value) {
              if (!value) {
                throw new Error("Expected non-null, but got " + String(value));
              }
              return value;
            };
            const protocolFromUrl = function(url) {
              const protocol = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(url);
              if (!protocol) {
                return "_relative";
              }
              if (protocol[2] !== ":") {
                return null;
              }
              if (!/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(protocol[1])) {
                return null;
              }
              return protocol[1].toLowerCase();
            };
            var utils = {
              deflt,
              escape: utils_escape,
              hyphenate,
              getBaseElem,
              isCharacterBox,
              protocolFromUrl
            };
            ;
            const SETTINGS_SCHEMA = {
              displayMode: {
                type: "boolean",
                description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
                cli: "-d, --display-mode"
              },
              output: {
                type: {
                  enum: ["htmlAndMathml", "html", "mathml"]
                },
                description: "Determines the markup language of the output.",
                cli: "-F, --format <type>"
              },
              leqno: {
                type: "boolean",
                description: "Render display math in leqno style (left-justified tags)."
              },
              fleqn: {
                type: "boolean",
                description: "Render display math flush left."
              },
              throwOnError: {
                type: "boolean",
                default: true,
                cli: "-t, --no-throw-on-error",
                cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
              },
              errorColor: {
                type: "string",
                default: "#cc0000",
                cli: "-c, --error-color <color>",
                cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
                cliProcessor: (color2) => "#" + color2
              },
              macros: {
                type: "object",
                cli: "-m, --macro <def>",
                cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
                cliDefault: [],
                cliProcessor: (def, defs) => {
                  defs.push(def);
                  return defs;
                }
              },
              minRuleThickness: {
                type: "number",
                description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
                processor: (t) => Math.max(0, t),
                cli: "--min-rule-thickness <size>",
                cliProcessor: parseFloat
              },
              colorIsTextColor: {
                type: "boolean",
                description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
                cli: "-b, --color-is-text-color"
              },
              strict: {
                type: [{
                  enum: ["warn", "ignore", "error"]
                }, "boolean", "function"],
                description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
                cli: "-S, --strict",
                cliDefault: false
              },
              trust: {
                type: ["boolean", "function"],
                description: "Trust the input, enabling all HTML features such as \\url.",
                cli: "-T, --trust"
              },
              maxSize: {
                type: "number",
                default: Infinity,
                description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
                processor: (s) => Math.max(0, s),
                cli: "-s, --max-size <n>",
                cliProcessor: parseInt
              },
              maxExpand: {
                type: "number",
                default: 1e3,
                description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
                processor: (n) => Math.max(0, n),
                cli: "-e, --max-expand <n>",
                cliProcessor: (n) => n === "Infinity" ? Infinity : parseInt(n)
              },
              globalGroup: {
                type: "boolean",
                cli: false
              }
            };
            function getDefaultValue(schema4) {
              if (schema4.default) {
                return schema4.default;
              }
              const type2 = schema4.type;
              const defaultType = Array.isArray(type2) ? type2[0] : type2;
              if (typeof defaultType !== "string") {
                return defaultType.enum[0];
              }
              switch (defaultType) {
                case "boolean":
                  return false;
                case "string":
                  return "";
                case "number":
                  return 0;
                case "object":
                  return {};
              }
            }
            class Settings {
              constructor(options) {
                this.displayMode = void 0;
                this.output = void 0;
                this.leqno = void 0;
                this.fleqn = void 0;
                this.throwOnError = void 0;
                this.errorColor = void 0;
                this.macros = void 0;
                this.minRuleThickness = void 0;
                this.colorIsTextColor = void 0;
                this.strict = void 0;
                this.trust = void 0;
                this.maxSize = void 0;
                this.maxExpand = void 0;
                this.globalGroup = void 0;
                options = options || {};
                for (const prop2 in SETTINGS_SCHEMA) {
                  if (SETTINGS_SCHEMA.hasOwnProperty(prop2)) {
                    const schema4 = SETTINGS_SCHEMA[prop2];
                    this[prop2] = options[prop2] !== void 0 ? schema4.processor ? schema4.processor(options[prop2]) : options[prop2] : getDefaultValue(schema4);
                  }
                }
              }
              /**
               * Report nonstrict (non-LaTeX-compatible) input.
               * Can safely not be called if `this.strict` is false in JavaScript.
               */
              reportNonstrict(errorCode, errorMsg, token) {
                let strict = this.strict;
                if (typeof strict === "function") {
                  strict = strict(errorCode, errorMsg, token);
                }
                if (!strict || strict === "ignore") {
                  return;
                } else if (strict === true || strict === "error") {
                  throw new src_ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + (errorMsg + " [" + errorCode + "]"), token);
                } else if (strict === "warn") {
                  typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
                } else {
                  typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
                }
              }
              /**
               * Check whether to apply strict (LaTeX-adhering) behavior for unusual
               * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
               * instead, "error" translates to a return value of `true`, while "ignore"
               * translates to a return value of `false`.  May still print a warning:
               * "warn" prints a warning and returns `false`.
               * This is for the second category of `errorCode`s listed in the README.
               */
              useStrictBehavior(errorCode, errorMsg, token) {
                let strict = this.strict;
                if (typeof strict === "function") {
                  try {
                    strict = strict(errorCode, errorMsg, token);
                  } catch (error2) {
                    strict = "error";
                  }
                }
                if (!strict || strict === "ignore") {
                  return false;
                } else if (strict === true || strict === "error") {
                  return true;
                } else if (strict === "warn") {
                  typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
                  return false;
                } else {
                  typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
                  return false;
                }
              }
              /**
               * Check whether to test potentially dangerous input, and return
               * `true` (trusted) or `false` (untrusted).  The sole argument `context`
               * should be an object with `command` field specifying the relevant LaTeX
               * command (as a string starting with `\`), and any other arguments, etc.
               * If `context` has a `url` field, a `protocol` field will automatically
               * get added by this function (changing the specified object).
               */
              isTrusted(context) {
                if (context.url && !context.protocol) {
                  const protocol = utils.protocolFromUrl(context.url);
                  if (protocol == null) {
                    return false;
                  }
                  context.protocol = protocol;
                }
                const trust = typeof this.trust === "function" ? this.trust(context) : this.trust;
                return Boolean(trust);
              }
            }
            ;
            class Style2 {
              constructor(id2, size, cramped) {
                this.id = void 0;
                this.size = void 0;
                this.cramped = void 0;
                this.id = id2;
                this.size = size;
                this.cramped = cramped;
              }
              /**
               * Get the style of a superscript given a base in the current style.
               */
              sup() {
                return styles2[sup[this.id]];
              }
              /**
               * Get the style of a subscript given a base in the current style.
               */
              sub() {
                return styles2[sub[this.id]];
              }
              /**
               * Get the style of a fraction numerator given the fraction in the current
               * style.
               */
              fracNum() {
                return styles2[fracNum[this.id]];
              }
              /**
               * Get the style of a fraction denominator given the fraction in the current
               * style.
               */
              fracDen() {
                return styles2[fracDen[this.id]];
              }
              /**
               * Get the cramped version of a style (in particular, cramping a cramped style
               * doesn't change the style).
               */
              cramp() {
                return styles2[cramp[this.id]];
              }
              /**
               * Get a text or display version of this style.
               */
              text() {
                return styles2[Style_text[this.id]];
              }
              /**
               * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
               */
              isTight() {
                return this.size >= 2;
              }
            }
            const D = 0;
            const Dc = 1;
            const T2 = 2;
            const Tc = 3;
            const S = 4;
            const Sc = 5;
            const SS = 6;
            const SSc = 7;
            const styles2 = [new Style2(D, 0, false), new Style2(Dc, 0, true), new Style2(T2, 1, false), new Style2(Tc, 1, true), new Style2(S, 2, false), new Style2(Sc, 2, true), new Style2(SS, 3, false), new Style2(SSc, 3, true)];
            const sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];
            const sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
            const fracNum = [T2, Tc, S, Sc, SS, SSc, SS, SSc];
            const fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
            const cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];
            const Style_text = [D, Dc, T2, Tc, T2, Tc, T2, Tc];
            var src_Style = {
              DISPLAY: styles2[D],
              TEXT: styles2[T2],
              SCRIPT: styles2[S],
              SCRIPTSCRIPT: styles2[SS]
            };
            ;
            const scriptData = [{
              // Latin characters beyond the Latin-1 characters we have metrics for.
              // Needed for Czech, Hungarian and Turkish text, for example.
              name: "latin",
              blocks: [
                [256, 591],
                // Latin Extended-A and Latin Extended-B
                [768, 879]
                // Combining Diacritical marks
              ]
            }, {
              // The Cyrillic script used by Russian and related languages.
              // A Cyrillic subset used to be supported as explicitly defined
              // symbols in symbols.js
              name: "cyrillic",
              blocks: [[1024, 1279]]
            }, {
              // Armenian
              name: "armenian",
              blocks: [[1328, 1423]]
            }, {
              // The Brahmic scripts of South and Southeast Asia
              // Devanagari (0900–097F)
              // Bengali (0980–09FF)
              // Gurmukhi (0A00–0A7F)
              // Gujarati (0A80–0AFF)
              // Oriya (0B00–0B7F)
              // Tamil (0B80–0BFF)
              // Telugu (0C00–0C7F)
              // Kannada (0C80–0CFF)
              // Malayalam (0D00–0D7F)
              // Sinhala (0D80–0DFF)
              // Thai (0E00–0E7F)
              // Lao (0E80–0EFF)
              // Tibetan (0F00–0FFF)
              // Myanmar (1000–109F)
              name: "brahmic",
              blocks: [[2304, 4255]]
            }, {
              name: "georgian",
              blocks: [[4256, 4351]]
            }, {
              // Chinese and Japanese.
              // The "k" in cjk is for Korean, but we've separated Korean out
              name: "cjk",
              blocks: [
                [12288, 12543],
                // CJK symbols and punctuation, Hiragana, Katakana
                [19968, 40879],
                // CJK ideograms
                [65280, 65376]
                // Fullwidth punctuation
                // TODO: add halfwidth Katakana and Romanji glyphs
              ]
            }, {
              // Korean
              name: "hangul",
              blocks: [[44032, 55215]]
            }];
            function scriptFromCodepoint(codepoint) {
              for (let i = 0; i < scriptData.length; i++) {
                const script = scriptData[i];
                for (let i2 = 0; i2 < script.blocks.length; i2++) {
                  const block2 = script.blocks[i2];
                  if (codepoint >= block2[0] && codepoint <= block2[1]) {
                    return script.name;
                  }
                }
              }
              return null;
            }
            const allBlocks = [];
            scriptData.forEach((s) => s.blocks.forEach((b) => allBlocks.push(...b)));
            function supportedCodepoint(codepoint) {
              for (let i = 0; i < allBlocks.length; i += 2) {
                if (codepoint >= allBlocks[i] && codepoint <= allBlocks[i + 1]) {
                  return true;
                }
              }
              return false;
            }
            ;
            const hLinePad = 80;
            const sqrtMain = function(extraVinculum, hLinePad2) {
              return "M95," + (622 + extraVinculum + hLinePad2) + "\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl" + extraVinculum / 2.075 + " -" + extraVinculum + "\nc5.3,-9.3,12,-14,20,-14\nH400000v" + (40 + extraVinculum) + "H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM" + (834 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
            };
            const sqrtSize1 = function(extraVinculum, hLinePad2) {
              return "M263," + (601 + extraVinculum + hLinePad2) + "c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl" + extraVinculum / 2.084 + " -" + extraVinculum + "\nc4.7,-7.3,11,-11,19,-11\nH40000v" + (40 + extraVinculum) + "H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
            };
            const sqrtSize2 = function(extraVinculum, hLinePad2) {
              return "M983 " + (10 + extraVinculum + hLinePad2) + "\nl" + extraVinculum / 3.13 + " -" + extraVinculum + "\nc4,-6.7,10,-10,18,-10 H400000v" + (40 + extraVinculum) + "\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\nM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
            };
            const sqrtSize3 = function(extraVinculum, hLinePad2) {
              return "M424," + (2398 + extraVinculum + hLinePad2) + "\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\nl" + extraVinculum / 4.223 + " -" + extraVinculum + "c4,-6.7,10,-10,18,-10 H400000\nv" + (40 + extraVinculum) + "H1014.6\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\nc-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2z M" + (1001 + extraVinculum) + " " + hLinePad2 + "\nh400000v" + (40 + extraVinculum) + "h-400000z";
            };
            const sqrtSize4 = function(extraVinculum, hLinePad2) {
              return "M473," + (2713 + extraVinculum + hLinePad2) + "\nc339.3,-1799.3,509.3,-2700,510,-2702 l" + extraVinculum / 5.298 + " -" + extraVinculum + "\nc3.3,-7.3,9.3,-11,18,-11 H400000v" + (40 + extraVinculum) + "H1017.7\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\n606zM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "H1017.7z";
            };
            const phasePath = function(y2) {
              const x2 = y2 / 2;
              return "M400000 " + y2 + " H0 L" + x2 + " 0 l65 45 L145 " + (y2 - 80) + " H400000z";
            };
            const sqrtTall = function(extraVinculum, hLinePad2, viewBoxHeight) {
              const vertSegment = viewBoxHeight - 54 - hLinePad2 - extraVinculum;
              return "M702 " + (extraVinculum + hLinePad2) + "H400000" + (40 + extraVinculum) + "\nH742v" + vertSegment + "l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\n219 661 l218 661zM702 " + hLinePad2 + "H400000v" + (40 + extraVinculum) + "H742z";
            };
            const sqrtPath = function(size, extraVinculum, viewBoxHeight) {
              extraVinculum = 1e3 * extraVinculum;
              let path3 = "";
              switch (size) {
                case "sqrtMain":
                  path3 = sqrtMain(extraVinculum, hLinePad);
                  break;
                case "sqrtSize1":
                  path3 = sqrtSize1(extraVinculum, hLinePad);
                  break;
                case "sqrtSize2":
                  path3 = sqrtSize2(extraVinculum, hLinePad);
                  break;
                case "sqrtSize3":
                  path3 = sqrtSize3(extraVinculum, hLinePad);
                  break;
                case "sqrtSize4":
                  path3 = sqrtSize4(extraVinculum, hLinePad);
                  break;
                case "sqrtTall":
                  path3 = sqrtTall(extraVinculum, hLinePad, viewBoxHeight);
              }
              return path3;
            };
            const innerPath = function(name2, height) {
              switch (name2) {
                case "\u239C":
                  return "M291 0 H417 V" + height + " H291z M291 0 H417 V" + height + " H291z";
                case "\u2223":
                  return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z";
                case "\u2225":
                  return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z" + ("M367 0 H410 V" + height + " H367z M367 0 H410 V" + height + " H367z");
                case "\u239F":
                  return "M457 0 H583 V" + height + " H457z M457 0 H583 V" + height + " H457z";
                case "\u23A2":
                  return "M319 0 H403 V" + height + " H319z M319 0 H403 V" + height + " H319z";
                case "\u23A5":
                  return "M263 0 H347 V" + height + " H263z M263 0 H347 V" + height + " H263z";
                case "\u23AA":
                  return "M384 0 H504 V" + height + " H384z M384 0 H504 V" + height + " H384z";
                case "\u23D0":
                  return "M312 0 H355 V" + height + " H312z M312 0 H355 V" + height + " H312z";
                case "\u2016":
                  return "M257 0 H300 V" + height + " H257z M257 0 H300 V" + height + " H257z" + ("M478 0 H521 V" + height + " H478z M478 0 H521 V" + height + " H478z");
                default:
                  return "";
              }
            };
            const path2 = {
              // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
              doubleleftarrow: "M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",
              // doublerightarrow is from glyph U+21D2 in font KaTeX Main
              doublerightarrow: "M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",
              // leftarrow is from glyph U+2190 in font KaTeX Main
              leftarrow: "M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",
              // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
              leftbrace: "M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",
              leftbraceunder: "M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",
              // overgroup is from the MnSymbol package (public domain)
              leftgroup: "M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",
              leftgroupunder: "M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",
              // Harpoons are from glyph U+21BD in font KaTeX Main
              leftharpoon: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",
              leftharpoonplus: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",
              leftharpoondown: "M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",
              leftharpoondownplus: "M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",
              // hook is from glyph U+21A9 in font KaTeX Main
              lefthook: "M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",
              leftlinesegment: "M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",
              leftmapsto: "M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",
              // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
              leftToFrom: "M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",
              longequal: "M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",
              midbrace: "M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",
              midbraceunder: "M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",
              oiintSize1: "M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",
              oiintSize2: "M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",
              oiiintSize1: "M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",
              oiiintSize2: "M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",
              rightarrow: "M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",
              rightbrace: "M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",
              rightbraceunder: "M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",
              rightgroup: "M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",
              rightgroupunder: "M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",
              rightharpoon: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",
              rightharpoonplus: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",
              rightharpoondown: "M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",
              rightharpoondownplus: "M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",
              righthook: "M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",
              rightlinesegment: "M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",
              rightToFrom: "M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",
              // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
              twoheadleftarrow: "M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",
              twoheadrightarrow: "M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",
              // tilde1 is a modified version of a glyph from the MnSymbol package
              tilde1: "M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",
              // ditto tilde2, tilde3, & tilde4
              tilde2: "M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",
              tilde3: "M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",
              tilde4: "M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",
              // vec is from glyph U+20D7 in font KaTeX Main
              vec: "M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",
              // widehat1 is a modified version of a glyph from the MnSymbol package
              widehat1: "M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",
              // ditto widehat2, widehat3, & widehat4
              widehat2: "M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
              widehat3: "M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
              widehat4: "M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
              // widecheck paths are all inverted versions of widehat
              widecheck1: "M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",
              widecheck2: "M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
              widecheck3: "M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
              widecheck4: "M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
              // The next ten paths support reaction arrows from the mhchem package.
              // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
              // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
              baraboveleftarrow: "M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",
              // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
              rightarrowabovebar: "M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",
              // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
              // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
              baraboveshortleftharpoon: "M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",
              rightharpoonaboveshortbar: "M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",
              shortbaraboveleftharpoon: "M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",
              shortrightharpoonabovebar: "M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"
            };
            const tallDelim = function(label, midHeight) {
              switch (label) {
                case "lbrack":
                  return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v1759 h347 v-84\nH403z M403 1759 V0 H319 V1759 v" + midHeight + " v1759 h84z";
                case "rbrack":
                  return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v1759 H0 v84 H347z\nM347 1759 V0 H263 V1759 v" + midHeight + " v1759 h84z";
                case "vert":
                  return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z";
                case "doublevert":
                  return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z\nM367 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M410 15 H367 v585 v" + midHeight + " v585 h43z";
                case "lfloor":
                  return "M319 602 V0 H403 V602 v" + midHeight + " v1715 h263 v84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
                case "rfloor":
                  return "M319 602 V0 H403 V602 v" + midHeight + " v1799 H0 v-84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
                case "lceil":
                  return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v602 h84z\nM403 1759 V0 H319 V1759 v" + midHeight + " v602 h84z";
                case "rceil":
                  return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v602 h84z\nM347 1759 V0 h-84 V1759 v" + midHeight + " v602 h84z";
                case "lparen":
                  return "M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1\nc-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,\n-36,557 l0," + (midHeight + 84) + "c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,\n949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9\nc0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,\n-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189\nl0,-" + (midHeight + 92) + "c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,\n-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z";
                case "rparen":
                  return "M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,\n63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5\nc11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0," + (midHeight + 9) + "\nc-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664\nc-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11\nc0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17\nc242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558\nl0,-" + (midHeight + 144) + "c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,\n-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z";
                default:
                  throw new Error("Unknown stretchy delimiter.");
              }
            };
            ;
            var fontMetricsData = {
              "AMS-Regular": {
                "32": [0, 0, 0, 0, 0.25],
                "65": [0, 0.68889, 0, 0, 0.72222],
                "66": [0, 0.68889, 0, 0, 0.66667],
                "67": [0, 0.68889, 0, 0, 0.72222],
                "68": [0, 0.68889, 0, 0, 0.72222],
                "69": [0, 0.68889, 0, 0, 0.66667],
                "70": [0, 0.68889, 0, 0, 0.61111],
                "71": [0, 0.68889, 0, 0, 0.77778],
                "72": [0, 0.68889, 0, 0, 0.77778],
                "73": [0, 0.68889, 0, 0, 0.38889],
                "74": [0.16667, 0.68889, 0, 0, 0.5],
                "75": [0, 0.68889, 0, 0, 0.77778],
                "76": [0, 0.68889, 0, 0, 0.66667],
                "77": [0, 0.68889, 0, 0, 0.94445],
                "78": [0, 0.68889, 0, 0, 0.72222],
                "79": [0.16667, 0.68889, 0, 0, 0.77778],
                "80": [0, 0.68889, 0, 0, 0.61111],
                "81": [0.16667, 0.68889, 0, 0, 0.77778],
                "82": [0, 0.68889, 0, 0, 0.72222],
                "83": [0, 0.68889, 0, 0, 0.55556],
                "84": [0, 0.68889, 0, 0, 0.66667],
                "85": [0, 0.68889, 0, 0, 0.72222],
                "86": [0, 0.68889, 0, 0, 0.72222],
                "87": [0, 0.68889, 0, 0, 1],
                "88": [0, 0.68889, 0, 0, 0.72222],
                "89": [0, 0.68889, 0, 0, 0.72222],
                "90": [0, 0.68889, 0, 0, 0.66667],
                "107": [0, 0.68889, 0, 0, 0.55556],
                "160": [0, 0, 0, 0, 0.25],
                "165": [0, 0.675, 0.025, 0, 0.75],
                "174": [0.15559, 0.69224, 0, 0, 0.94666],
                "240": [0, 0.68889, 0, 0, 0.55556],
                "295": [0, 0.68889, 0, 0, 0.54028],
                "710": [0, 0.825, 0, 0, 2.33334],
                "732": [0, 0.9, 0, 0, 2.33334],
                "770": [0, 0.825, 0, 0, 2.33334],
                "771": [0, 0.9, 0, 0, 2.33334],
                "989": [0.08167, 0.58167, 0, 0, 0.77778],
                "1008": [0, 0.43056, 0.04028, 0, 0.66667],
                "8245": [0, 0.54986, 0, 0, 0.275],
                "8463": [0, 0.68889, 0, 0, 0.54028],
                "8487": [0, 0.68889, 0, 0, 0.72222],
                "8498": [0, 0.68889, 0, 0, 0.55556],
                "8502": [0, 0.68889, 0, 0, 0.66667],
                "8503": [0, 0.68889, 0, 0, 0.44445],
                "8504": [0, 0.68889, 0, 0, 0.66667],
                "8513": [0, 0.68889, 0, 0, 0.63889],
                "8592": [-0.03598, 0.46402, 0, 0, 0.5],
                "8594": [-0.03598, 0.46402, 0, 0, 0.5],
                "8602": [-0.13313, 0.36687, 0, 0, 1],
                "8603": [-0.13313, 0.36687, 0, 0, 1],
                "8606": [0.01354, 0.52239, 0, 0, 1],
                "8608": [0.01354, 0.52239, 0, 0, 1],
                "8610": [0.01354, 0.52239, 0, 0, 1.11111],
                "8611": [0.01354, 0.52239, 0, 0, 1.11111],
                "8619": [0, 0.54986, 0, 0, 1],
                "8620": [0, 0.54986, 0, 0, 1],
                "8621": [-0.13313, 0.37788, 0, 0, 1.38889],
                "8622": [-0.13313, 0.36687, 0, 0, 1],
                "8624": [0, 0.69224, 0, 0, 0.5],
                "8625": [0, 0.69224, 0, 0, 0.5],
                "8630": [0, 0.43056, 0, 0, 1],
                "8631": [0, 0.43056, 0, 0, 1],
                "8634": [0.08198, 0.58198, 0, 0, 0.77778],
                "8635": [0.08198, 0.58198, 0, 0, 0.77778],
                "8638": [0.19444, 0.69224, 0, 0, 0.41667],
                "8639": [0.19444, 0.69224, 0, 0, 0.41667],
                "8642": [0.19444, 0.69224, 0, 0, 0.41667],
                "8643": [0.19444, 0.69224, 0, 0, 0.41667],
                "8644": [0.1808, 0.675, 0, 0, 1],
                "8646": [0.1808, 0.675, 0, 0, 1],
                "8647": [0.1808, 0.675, 0, 0, 1],
                "8648": [0.19444, 0.69224, 0, 0, 0.83334],
                "8649": [0.1808, 0.675, 0, 0, 1],
                "8650": [0.19444, 0.69224, 0, 0, 0.83334],
                "8651": [0.01354, 0.52239, 0, 0, 1],
                "8652": [0.01354, 0.52239, 0, 0, 1],
                "8653": [-0.13313, 0.36687, 0, 0, 1],
                "8654": [-0.13313, 0.36687, 0, 0, 1],
                "8655": [-0.13313, 0.36687, 0, 0, 1],
                "8666": [0.13667, 0.63667, 0, 0, 1],
                "8667": [0.13667, 0.63667, 0, 0, 1],
                "8669": [-0.13313, 0.37788, 0, 0, 1],
                "8672": [-0.064, 0.437, 0, 0, 1.334],
                "8674": [-0.064, 0.437, 0, 0, 1.334],
                "8705": [0, 0.825, 0, 0, 0.5],
                "8708": [0, 0.68889, 0, 0, 0.55556],
                "8709": [0.08167, 0.58167, 0, 0, 0.77778],
                "8717": [0, 0.43056, 0, 0, 0.42917],
                "8722": [-0.03598, 0.46402, 0, 0, 0.5],
                "8724": [0.08198, 0.69224, 0, 0, 0.77778],
                "8726": [0.08167, 0.58167, 0, 0, 0.77778],
                "8733": [0, 0.69224, 0, 0, 0.77778],
                "8736": [0, 0.69224, 0, 0, 0.72222],
                "8737": [0, 0.69224, 0, 0, 0.72222],
                "8738": [0.03517, 0.52239, 0, 0, 0.72222],
                "8739": [0.08167, 0.58167, 0, 0, 0.22222],
                "8740": [0.25142, 0.74111, 0, 0, 0.27778],
                "8741": [0.08167, 0.58167, 0, 0, 0.38889],
                "8742": [0.25142, 0.74111, 0, 0, 0.5],
                "8756": [0, 0.69224, 0, 0, 0.66667],
                "8757": [0, 0.69224, 0, 0, 0.66667],
                "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
                "8765": [-0.13313, 0.37788, 0, 0, 0.77778],
                "8769": [-0.13313, 0.36687, 0, 0, 0.77778],
                "8770": [-0.03625, 0.46375, 0, 0, 0.77778],
                "8774": [0.30274, 0.79383, 0, 0, 0.77778],
                "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
                "8778": [0.08167, 0.58167, 0, 0, 0.77778],
                "8782": [0.06062, 0.54986, 0, 0, 0.77778],
                "8783": [0.06062, 0.54986, 0, 0, 0.77778],
                "8785": [0.08198, 0.58198, 0, 0, 0.77778],
                "8786": [0.08198, 0.58198, 0, 0, 0.77778],
                "8787": [0.08198, 0.58198, 0, 0, 0.77778],
                "8790": [0, 0.69224, 0, 0, 0.77778],
                "8791": [0.22958, 0.72958, 0, 0, 0.77778],
                "8796": [0.08198, 0.91667, 0, 0, 0.77778],
                "8806": [0.25583, 0.75583, 0, 0, 0.77778],
                "8807": [0.25583, 0.75583, 0, 0, 0.77778],
                "8808": [0.25142, 0.75726, 0, 0, 0.77778],
                "8809": [0.25142, 0.75726, 0, 0, 0.77778],
                "8812": [0.25583, 0.75583, 0, 0, 0.5],
                "8814": [0.20576, 0.70576, 0, 0, 0.77778],
                "8815": [0.20576, 0.70576, 0, 0, 0.77778],
                "8816": [0.30274, 0.79383, 0, 0, 0.77778],
                "8817": [0.30274, 0.79383, 0, 0, 0.77778],
                "8818": [0.22958, 0.72958, 0, 0, 0.77778],
                "8819": [0.22958, 0.72958, 0, 0, 0.77778],
                "8822": [0.1808, 0.675, 0, 0, 0.77778],
                "8823": [0.1808, 0.675, 0, 0, 0.77778],
                "8828": [0.13667, 0.63667, 0, 0, 0.77778],
                "8829": [0.13667, 0.63667, 0, 0, 0.77778],
                "8830": [0.22958, 0.72958, 0, 0, 0.77778],
                "8831": [0.22958, 0.72958, 0, 0, 0.77778],
                "8832": [0.20576, 0.70576, 0, 0, 0.77778],
                "8833": [0.20576, 0.70576, 0, 0, 0.77778],
                "8840": [0.30274, 0.79383, 0, 0, 0.77778],
                "8841": [0.30274, 0.79383, 0, 0, 0.77778],
                "8842": [0.13597, 0.63597, 0, 0, 0.77778],
                "8843": [0.13597, 0.63597, 0, 0, 0.77778],
                "8847": [0.03517, 0.54986, 0, 0, 0.77778],
                "8848": [0.03517, 0.54986, 0, 0, 0.77778],
                "8858": [0.08198, 0.58198, 0, 0, 0.77778],
                "8859": [0.08198, 0.58198, 0, 0, 0.77778],
                "8861": [0.08198, 0.58198, 0, 0, 0.77778],
                "8862": [0, 0.675, 0, 0, 0.77778],
                "8863": [0, 0.675, 0, 0, 0.77778],
                "8864": [0, 0.675, 0, 0, 0.77778],
                "8865": [0, 0.675, 0, 0, 0.77778],
                "8872": [0, 0.69224, 0, 0, 0.61111],
                "8873": [0, 0.69224, 0, 0, 0.72222],
                "8874": [0, 0.69224, 0, 0, 0.88889],
                "8876": [0, 0.68889, 0, 0, 0.61111],
                "8877": [0, 0.68889, 0, 0, 0.61111],
                "8878": [0, 0.68889, 0, 0, 0.72222],
                "8879": [0, 0.68889, 0, 0, 0.72222],
                "8882": [0.03517, 0.54986, 0, 0, 0.77778],
                "8883": [0.03517, 0.54986, 0, 0, 0.77778],
                "8884": [0.13667, 0.63667, 0, 0, 0.77778],
                "8885": [0.13667, 0.63667, 0, 0, 0.77778],
                "8888": [0, 0.54986, 0, 0, 1.11111],
                "8890": [0.19444, 0.43056, 0, 0, 0.55556],
                "8891": [0.19444, 0.69224, 0, 0, 0.61111],
                "8892": [0.19444, 0.69224, 0, 0, 0.61111],
                "8901": [0, 0.54986, 0, 0, 0.27778],
                "8903": [0.08167, 0.58167, 0, 0, 0.77778],
                "8905": [0.08167, 0.58167, 0, 0, 0.77778],
                "8906": [0.08167, 0.58167, 0, 0, 0.77778],
                "8907": [0, 0.69224, 0, 0, 0.77778],
                "8908": [0, 0.69224, 0, 0, 0.77778],
                "8909": [-0.03598, 0.46402, 0, 0, 0.77778],
                "8910": [0, 0.54986, 0, 0, 0.76042],
                "8911": [0, 0.54986, 0, 0, 0.76042],
                "8912": [0.03517, 0.54986, 0, 0, 0.77778],
                "8913": [0.03517, 0.54986, 0, 0, 0.77778],
                "8914": [0, 0.54986, 0, 0, 0.66667],
                "8915": [0, 0.54986, 0, 0, 0.66667],
                "8916": [0, 0.69224, 0, 0, 0.66667],
                "8918": [0.0391, 0.5391, 0, 0, 0.77778],
                "8919": [0.0391, 0.5391, 0, 0, 0.77778],
                "8920": [0.03517, 0.54986, 0, 0, 1.33334],
                "8921": [0.03517, 0.54986, 0, 0, 1.33334],
                "8922": [0.38569, 0.88569, 0, 0, 0.77778],
                "8923": [0.38569, 0.88569, 0, 0, 0.77778],
                "8926": [0.13667, 0.63667, 0, 0, 0.77778],
                "8927": [0.13667, 0.63667, 0, 0, 0.77778],
                "8928": [0.30274, 0.79383, 0, 0, 0.77778],
                "8929": [0.30274, 0.79383, 0, 0, 0.77778],
                "8934": [0.23222, 0.74111, 0, 0, 0.77778],
                "8935": [0.23222, 0.74111, 0, 0, 0.77778],
                "8936": [0.23222, 0.74111, 0, 0, 0.77778],
                "8937": [0.23222, 0.74111, 0, 0, 0.77778],
                "8938": [0.20576, 0.70576, 0, 0, 0.77778],
                "8939": [0.20576, 0.70576, 0, 0, 0.77778],
                "8940": [0.30274, 0.79383, 0, 0, 0.77778],
                "8941": [0.30274, 0.79383, 0, 0, 0.77778],
                "8994": [0.19444, 0.69224, 0, 0, 0.77778],
                "8995": [0.19444, 0.69224, 0, 0, 0.77778],
                "9416": [0.15559, 0.69224, 0, 0, 0.90222],
                "9484": [0, 0.69224, 0, 0, 0.5],
                "9488": [0, 0.69224, 0, 0, 0.5],
                "9492": [0, 0.37788, 0, 0, 0.5],
                "9496": [0, 0.37788, 0, 0, 0.5],
                "9585": [0.19444, 0.68889, 0, 0, 0.88889],
                "9586": [0.19444, 0.74111, 0, 0, 0.88889],
                "9632": [0, 0.675, 0, 0, 0.77778],
                "9633": [0, 0.675, 0, 0, 0.77778],
                "9650": [0, 0.54986, 0, 0, 0.72222],
                "9651": [0, 0.54986, 0, 0, 0.72222],
                "9654": [0.03517, 0.54986, 0, 0, 0.77778],
                "9660": [0, 0.54986, 0, 0, 0.72222],
                "9661": [0, 0.54986, 0, 0, 0.72222],
                "9664": [0.03517, 0.54986, 0, 0, 0.77778],
                "9674": [0.11111, 0.69224, 0, 0, 0.66667],
                "9733": [0.19444, 0.69224, 0, 0, 0.94445],
                "10003": [0, 0.69224, 0, 0, 0.83334],
                "10016": [0, 0.69224, 0, 0, 0.83334],
                "10731": [0.11111, 0.69224, 0, 0, 0.66667],
                "10846": [0.19444, 0.75583, 0, 0, 0.61111],
                "10877": [0.13667, 0.63667, 0, 0, 0.77778],
                "10878": [0.13667, 0.63667, 0, 0, 0.77778],
                "10885": [0.25583, 0.75583, 0, 0, 0.77778],
                "10886": [0.25583, 0.75583, 0, 0, 0.77778],
                "10887": [0.13597, 0.63597, 0, 0, 0.77778],
                "10888": [0.13597, 0.63597, 0, 0, 0.77778],
                "10889": [0.26167, 0.75726, 0, 0, 0.77778],
                "10890": [0.26167, 0.75726, 0, 0, 0.77778],
                "10891": [0.48256, 0.98256, 0, 0, 0.77778],
                "10892": [0.48256, 0.98256, 0, 0, 0.77778],
                "10901": [0.13667, 0.63667, 0, 0, 0.77778],
                "10902": [0.13667, 0.63667, 0, 0, 0.77778],
                "10933": [0.25142, 0.75726, 0, 0, 0.77778],
                "10934": [0.25142, 0.75726, 0, 0, 0.77778],
                "10935": [0.26167, 0.75726, 0, 0, 0.77778],
                "10936": [0.26167, 0.75726, 0, 0, 0.77778],
                "10937": [0.26167, 0.75726, 0, 0, 0.77778],
                "10938": [0.26167, 0.75726, 0, 0, 0.77778],
                "10949": [0.25583, 0.75583, 0, 0, 0.77778],
                "10950": [0.25583, 0.75583, 0, 0, 0.77778],
                "10955": [0.28481, 0.79383, 0, 0, 0.77778],
                "10956": [0.28481, 0.79383, 0, 0, 0.77778],
                "57350": [0.08167, 0.58167, 0, 0, 0.22222],
                "57351": [0.08167, 0.58167, 0, 0, 0.38889],
                "57352": [0.08167, 0.58167, 0, 0, 0.77778],
                "57353": [0, 0.43056, 0.04028, 0, 0.66667],
                "57356": [0.25142, 0.75726, 0, 0, 0.77778],
                "57357": [0.25142, 0.75726, 0, 0, 0.77778],
                "57358": [0.41951, 0.91951, 0, 0, 0.77778],
                "57359": [0.30274, 0.79383, 0, 0, 0.77778],
                "57360": [0.30274, 0.79383, 0, 0, 0.77778],
                "57361": [0.41951, 0.91951, 0, 0, 0.77778],
                "57366": [0.25142, 0.75726, 0, 0, 0.77778],
                "57367": [0.25142, 0.75726, 0, 0, 0.77778],
                "57368": [0.25142, 0.75726, 0, 0, 0.77778],
                "57369": [0.25142, 0.75726, 0, 0, 0.77778],
                "57370": [0.13597, 0.63597, 0, 0, 0.77778],
                "57371": [0.13597, 0.63597, 0, 0, 0.77778]
              },
              "Caligraphic-Regular": {
                "32": [0, 0, 0, 0, 0.25],
                "65": [0, 0.68333, 0, 0.19445, 0.79847],
                "66": [0, 0.68333, 0.03041, 0.13889, 0.65681],
                "67": [0, 0.68333, 0.05834, 0.13889, 0.52653],
                "68": [0, 0.68333, 0.02778, 0.08334, 0.77139],
                "69": [0, 0.68333, 0.08944, 0.11111, 0.52778],
                "70": [0, 0.68333, 0.09931, 0.11111, 0.71875],
                "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
                "72": [0, 0.68333, 965e-5, 0.11111, 0.84452],
                "73": [0, 0.68333, 0.07382, 0, 0.54452],
                "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
                "75": [0, 0.68333, 0.01445, 0.05556, 0.76195],
                "76": [0, 0.68333, 0, 0.13889, 0.68972],
                "77": [0, 0.68333, 0, 0.13889, 1.2009],
                "78": [0, 0.68333, 0.14736, 0.08334, 0.82049],
                "79": [0, 0.68333, 0.02778, 0.11111, 0.79611],
                "80": [0, 0.68333, 0.08222, 0.08334, 0.69556],
                "81": [0.09722, 0.68333, 0, 0.11111, 0.81667],
                "82": [0, 0.68333, 0, 0.08334, 0.8475],
                "83": [0, 0.68333, 0.075, 0.13889, 0.60556],
                "84": [0, 0.68333, 0.25417, 0, 0.54464],
                "85": [0, 0.68333, 0.09931, 0.08334, 0.62583],
                "86": [0, 0.68333, 0.08222, 0, 0.61278],
                "87": [0, 0.68333, 0.08222, 0.08334, 0.98778],
                "88": [0, 0.68333, 0.14643, 0.13889, 0.7133],
                "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
                "90": [0, 0.68333, 0.07944, 0.13889, 0.72473],
                "160": [0, 0, 0, 0, 0.25]
              },
              "Fraktur-Regular": {
                "32": [0, 0, 0, 0, 0.25],
                "33": [0, 0.69141, 0, 0, 0.29574],
                "34": [0, 0.69141, 0, 0, 0.21471],
                "38": [0, 0.69141, 0, 0, 0.73786],
                "39": [0, 0.69141, 0, 0, 0.21201],
                "40": [0.24982, 0.74947, 0, 0, 0.38865],
                "41": [0.24982, 0.74947, 0, 0, 0.38865],
                "42": [0, 0.62119, 0, 0, 0.27764],
                "43": [0.08319, 0.58283, 0, 0, 0.75623],
                "44": [0, 0.10803, 0, 0, 0.27764],
                "45": [0.08319, 0.58283, 0, 0, 0.75623],
                "46": [0, 0.10803, 0, 0, 0.27764],
                "47": [0.24982, 0.74947, 0, 0, 0.50181],
                "48": [0, 0.47534, 0, 0, 0.50181],
                "49": [0, 0.47534, 0, 0, 0.50181],
                "50": [0, 0.47534, 0, 0, 0.50181],
                "51": [0.18906, 0.47534, 0, 0, 0.50181],
                "52": [0.18906, 0.47534, 0, 0, 0.50181],
                "53": [0.18906, 0.47534, 0, 0, 0.50181],
                "54": [0, 0.69141, 0, 0, 0.50181],
                "55": [0.18906, 0.47534, 0, 0, 0.50181],
                "56": [0, 0.69141, 0, 0, 0.50181],
                "57": [0.18906, 0.47534, 0, 0, 0.50181],
                "58": [0, 0.47534, 0, 0, 0.21606],
                "59": [0.12604, 0.47534, 0, 0, 0.21606],
                "61": [-0.13099, 0.36866, 0, 0, 0.75623],
                "63": [0, 0.69141, 0, 0, 0.36245],
                "65": [0, 0.69141, 0, 0, 0.7176],
                "66": [0, 0.69141, 0, 0, 0.88397],
                "67": [0, 0.69141, 0, 0, 0.61254],
                "68": [0, 0.69141, 0, 0, 0.83158],
                "69": [0, 0.69141, 0, 0, 0.66278],
                "70": [0.12604, 0.69141, 0, 0, 0.61119],
                "71": [0, 0.69141, 0, 0, 0.78539],
                "72": [0.06302, 0.69141, 0, 0, 0.7203],
                "73": [0, 0.69141, 0, 0, 0.55448],
                "74": [0.12604, 0.69141, 0, 0, 0.55231],
                "75": [0, 0.69141, 0, 0, 0.66845],
                "76": [0, 0.69141, 0, 0, 0.66602],
                "77": [0, 0.69141, 0, 0, 1.04953],
                "78": [0, 0.69141, 0, 0, 0.83212],
                "79": [0, 0.69141, 0, 0, 0.82699],
                "80": [0.18906, 0.69141, 0, 0, 0.82753],
                "81": [0.03781, 0.69141, 0, 0, 0.82699],
                "82": [0, 0.69141, 0, 0, 0.82807],
                "83": [0, 0.69141, 0, 0, 0.82861],
                "84": [0, 0.69141, 0, 0, 0.66899],
                "85": [0, 0.69141, 0, 0, 0.64576],
                "86": [0, 0.69141, 0, 0, 0.83131],
                "87": [0, 0.69141, 0, 0, 1.04602],
                "88": [0, 0.69141, 0, 0, 0.71922],
                "89": [0.18906, 0.69141, 0, 0, 0.83293],
                "90": [0.12604, 0.69141, 0, 0, 0.60201],
                "91": [0.24982, 0.74947, 0, 0, 0.27764],
                "93": [0.24982, 0.74947, 0, 0, 0.27764],
                "94": [0, 0.69141, 0, 0, 0.49965],
                "97": [0, 0.47534, 0, 0, 0.50046],
                "98": [0, 0.69141, 0, 0, 0.51315],
                "99": [0, 0.47534, 0, 0, 0.38946],
                "100": [0, 0.62119, 0, 0, 0.49857],
                "101": [0, 0.47534, 0, 0, 0.40053],
                "102": [0.18906, 0.69141, 0, 0, 0.32626],
                "103": [0.18906, 0.47534, 0, 0, 0.5037],
                "104": [0.18906, 0.69141, 0, 0, 0.52126],
                "105": [0, 0.69141, 0, 0, 0.27899],
                "106": [0, 0.69141, 0, 0, 0.28088],
                "107": [0, 0.69141, 0, 0, 0.38946],
                "108": [0, 0.69141, 0, 0, 0.27953],
                "109": [0, 0.47534, 0, 0, 0.76676],
                "110": [0, 0.47534, 0, 0, 0.52666],
                "111": [0, 0.47534, 0, 0, 0.48885],
                "112": [0.18906, 0.52396, 0, 0, 0.50046],
                "113": [0.18906, 0.47534, 0, 0, 0.48912],
                "114": [0, 0.47534, 0, 0, 0.38919],
                "115": [0, 0.47534, 0, 0, 0.44266],
                "116": [0, 0.62119, 0, 0, 0.33301],
                "117": [0, 0.47534, 0, 0, 0.5172],
                "118": [0, 0.52396, 0, 0, 0.5118],
                "119": [0, 0.52396, 0, 0, 0.77351],
                "120": [0.18906, 0.47534, 0, 0, 0.38865],
                "121": [0.18906, 0.47534, 0, 0, 0.49884],
                "122": [0.18906, 0.47534, 0, 0, 0.39054],
                "160": [0, 0, 0, 0, 0.25],
                "8216": [0, 0.69141, 0, 0, 0.21471],
                "8217": [0, 0.69141, 0, 0, 0.21471],
                "58112": [0, 0.62119, 0, 0, 0.49749],
                "58113": [0, 0.62119, 0, 0, 0.4983],
                "58114": [0.18906, 0.69141, 0, 0, 0.33328],
                "58115": [0.18906, 0.69141, 0, 0, 0.32923],
                "58116": [0.18906, 0.47534, 0, 0, 0.50343],
                "58117": [0, 0.69141, 0, 0, 0.33301],
                "58118": [0, 0.62119, 0, 0, 0.33409],
                "58119": [0, 0.47534, 0, 0, 0.50073]
              },
              "Main-Bold": {
                "32": [0, 0, 0, 0, 0.25],
                "33": [0, 0.69444, 0, 0, 0.35],
                "34": [0, 0.69444, 0, 0, 0.60278],
                "35": [0.19444, 0.69444, 0, 0, 0.95833],
                "36": [0.05556, 0.75, 0, 0, 0.575],
                "37": [0.05556, 0.75, 0, 0, 0.95833],
                "38": [0, 0.69444, 0, 0, 0.89444],
                "39": [0, 0.69444, 0, 0, 0.31944],
                "40": [0.25, 0.75, 0, 0, 0.44722],
                "41": [0.25, 0.75, 0, 0, 0.44722],
                "42": [0, 0.75, 0, 0, 0.575],
                "43": [0.13333, 0.63333, 0, 0, 0.89444],
                "44": [0.19444, 0.15556, 0, 0, 0.31944],
                "45": [0, 0.44444, 0, 0, 0.38333],
                "46": [0, 0.15556, 0, 0, 0.31944],
                "47": [0.25, 0.75, 0, 0, 0.575],
                "48": [0, 0.64444, 0, 0, 0.575],
                "49": [0, 0.64444, 0, 0, 0.575],
                "50": [0, 0.64444, 0, 0, 0.575],
                "51": [0, 0.64444, 0, 0, 0.575],
                "52": [0, 0.64444, 0, 0, 0.575],
                "53": [0, 0.64444, 0, 0, 0.575],
                "54": [0, 0.64444, 0, 0, 0.575],
                "55": [0, 0.64444, 0, 0, 0.575],
                "56": [0, 0.64444, 0, 0, 0.575],
                "57": [0, 0.64444, 0, 0, 0.575],
                "58": [0, 0.44444, 0, 0, 0.31944],
                "59": [0.19444, 0.44444, 0, 0, 0.31944],
                "60": [0.08556, 0.58556, 0, 0, 0.89444],
                "61": [-0.10889, 0.39111, 0, 0, 0.89444],
                "62": [0.08556, 0.58556, 0, 0, 0.89444],
                "63": [0, 0.69444, 0, 0, 0.54305],
                "64": [0, 0.69444, 0, 0, 0.89444],
                "65": [0, 0.68611, 0, 0, 0.86944],
                "66": [0, 0.68611, 0, 0, 0.81805],
                "67": [0, 0.68611, 0, 0, 0.83055],
                "68": [0, 0.68611, 0, 0, 0.88194],
                "69": [0, 0.68611, 0, 0, 0.75555],
                "70": [0, 0.68611, 0, 0, 0.72361],
                "71": [0, 0.68611, 0, 0, 0.90416],
                "72": [0, 0.68611, 0, 0, 0.9],
                "73": [0, 0.68611, 0, 0, 0.43611],
                "74": [0, 0.68611, 0, 0, 0.59444],
                "75": [0, 0.68611, 0, 0, 0.90138],
                "76": [0, 0.68611, 0, 0, 0.69166],
                "77": [0, 0.68611, 0, 0, 1.09166],
                "78": [0, 0.68611, 0, 0, 0.9],
                "79": [0, 0.68611, 0, 0, 0.86388],
                "80": [0, 0.68611, 0, 0, 0.78611],
                "81": [0.19444, 0.68611, 0, 0, 0.86388],
                "82": [0, 0.68611, 0, 0, 0.8625],
                "83": [0, 0.68611, 0, 0, 0.63889],
                "84": [0, 0.68611, 0, 0, 0.8],
                "85": [0, 0.68611, 0, 0, 0.88472],
                "86": [0, 0.68611, 0.01597, 0, 0.86944],
                "87": [0, 0.68611, 0.01597, 0, 1.18888],
                "88": [0, 0.68611, 0, 0, 0.86944],
                "89": [0, 0.68611, 0.02875, 0, 0.86944],
                "90": [0, 0.68611, 0, 0, 0.70277],
                "91": [0.25, 0.75, 0, 0, 0.31944],
                "92": [0.25, 0.75, 0, 0, 0.575],
                "93": [0.25, 0.75, 0, 0, 0.31944],
                "94": [0, 0.69444, 0, 0, 0.575],
                "95": [0.31, 0.13444, 0.03194, 0, 0.575],
                "97": [0, 0.44444, 0, 0, 0.55902],
                "98": [0, 0.69444, 0, 0, 0.63889],
                "99": [0, 0.44444, 0, 0, 0.51111],
                "100": [0, 0.69444, 0, 0, 0.63889],
                "101": [0, 0.44444, 0, 0, 0.52708],
                "102": [0, 0.69444, 0.10903, 0, 0.35139],
                "103": [0.19444, 0.44444, 0.01597, 0, 0.575],
                "104": [0, 0.69444, 0, 0, 0.63889],
                "105": [0, 0.69444, 0, 0, 0.31944],
                "106": [0.19444, 0.69444, 0, 0, 0.35139],
                "107": [0, 0.69444, 0, 0, 0.60694],
                "108": [0, 0.69444, 0, 0, 0.31944],
                "109": [0, 0.44444, 0, 0, 0.95833],
                "110": [0, 0.44444, 0, 0, 0.63889],
                "111": [0, 0.44444, 0, 0, 0.575],
                "112": [0.19444, 0.44444, 0, 0, 0.63889],
                "113": [0.19444, 0.44444, 0, 0, 0.60694],
                "114": [0, 0.44444, 0, 0, 0.47361],
                "115": [0, 0.44444, 0, 0, 0.45361],
                "116": [0, 0.63492, 0, 0, 0.44722],
                "117": [0, 0.44444, 0, 0, 0.63889],
                "118": [0, 0.44444, 0.01597, 0, 0.60694],
                "119": [0, 0.44444, 0.01597, 0, 0.83055],
                "120": [0, 0.44444, 0, 0, 0.60694],
                "121": [0.19444, 0.44444, 0.01597, 0, 0.60694],
                "122": [0, 0.44444, 0, 0, 0.51111],
                "123": [0.25, 0.75, 0, 0, 0.575],
                "124": [0.25, 0.75, 0, 0, 0.31944],
                "125": [0.25, 0.75, 0, 0, 0.575],
                "126": [0.35, 0.34444, 0, 0, 0.575],
                "160": [0, 0, 0, 0, 0.25],
                "163": [0, 0.69444, 0, 0, 0.86853],
                "168": [0, 0.69444, 0, 0, 0.575],
                "172": [0, 0.44444, 0, 0, 0.76666],
                "176": [0, 0.69444, 0, 0, 0.86944],
                "177": [0.13333, 0.63333, 0, 0, 0.89444],
                "184": [0.17014, 0, 0, 0, 0.51111],
                "198": [0, 0.68611, 0, 0, 1.04166],
                "215": [0.13333, 0.63333, 0, 0, 0.89444],
                "216": [0.04861, 0.73472, 0, 0, 0.89444],
                "223": [0, 0.69444, 0, 0, 0.59722],
                "230": [0, 0.44444, 0, 0, 0.83055],
                "247": [0.13333, 0.63333, 0, 0, 0.89444],
                "248": [0.09722, 0.54167, 0, 0, 0.575],
                "305": [0, 0.44444, 0, 0, 0.31944],
                "338": [0, 0.68611, 0, 0, 1.16944],
                "339": [0, 0.44444, 0, 0, 0.89444],
                "567": [0.19444, 0.44444, 0, 0, 0.35139],
                "710": [0, 0.69444, 0, 0, 0.575],
                "711": [0, 0.63194, 0, 0, 0.575],
                "713": [0, 0.59611, 0, 0, 0.575],
                "714": [0, 0.69444, 0, 0, 0.575],
                "715": [0, 0.69444, 0, 0, 0.575],
                "728": [0, 0.69444, 0, 0, 0.575],
                "729": [0, 0.69444, 0, 0, 0.31944],
                "730": [0, 0.69444, 0, 0, 0.86944],
                "732": [0, 0.69444, 0, 0, 0.575],
                "733": [0, 0.69444, 0, 0, 0.575],
                "915": [0, 0.68611, 0, 0, 0.69166],
                "916": [0, 0.68611, 0, 0, 0.95833],
                "920": [0, 0.68611, 0, 0, 0.89444],
                "923": [0, 0.68611, 0, 0, 0.80555],
                "926": [0, 0.68611, 0, 0, 0.76666],
                "928": [0, 0.68611, 0, 0, 0.9],
                "931": [0, 0.68611, 0, 0, 0.83055],
                "933": [0, 0.68611, 0, 0, 0.89444],
                "934": [0, 0.68611, 0, 0, 0.83055],
                "936": [0, 0.68611, 0, 0, 0.89444],
                "937": [0, 0.68611, 0, 0, 0.83055],
                "8211": [0, 0.44444, 0.03194, 0, 0.575],
                "8212": [0, 0.44444, 0.03194, 0, 1.14999],
                "8216": [0, 0.69444, 0, 0, 0.31944],
                "8217": [0, 0.69444, 0, 0, 0.31944],
                "8220": [0, 0.69444, 0, 0, 0.60278],
                "8221": [0, 0.69444, 0, 0, 0.60278],
                "8224": [0.19444, 0.69444, 0, 0, 0.51111],
                "8225": [0.19444, 0.69444, 0, 0, 0.51111],
                "8242": [0, 0.55556, 0, 0, 0.34444],
                "8407": [0, 0.72444, 0.15486, 0, 0.575],
                "8463": [0, 0.69444, 0, 0, 0.66759],
                "8465": [0, 0.69444, 0, 0, 0.83055],
                "8467": [0, 0.69444, 0, 0, 0.47361],
                "8472": [0.19444, 0.44444, 0, 0, 0.74027],
                "8476": [0, 0.69444, 0, 0, 0.83055],
                "8501": [0, 0.69444, 0, 0, 0.70277],
                "8592": [-0.10889, 0.39111, 0, 0, 1.14999],
                "8593": [0.19444, 0.69444, 0, 0, 0.575],
                "8594": [-0.10889, 0.39111, 0, 0, 1.14999],
                "8595": [0.19444, 0.69444, 0, 0, 0.575],
                "8596": [-0.10889, 0.39111, 0, 0, 1.14999],
                "8597": [0.25, 0.75, 0, 0, 0.575],
                "8598": [0.19444, 0.69444, 0, 0, 1.14999],
                "8599": [0.19444, 0.69444, 0, 0, 1.14999],
                "8600": [0.19444, 0.69444, 0, 0, 1.14999],
                "8601": [0.19444, 0.69444, 0, 0, 1.14999],
                "8636": [-0.10889, 0.39111, 0, 0, 1.14999],
                "8637": [-0.10889, 0.39111, 0, 0, 1.14999],
                "8640": [-0.10889, 0.39111, 0, 0, 1.14999],
                "8641": [-0.10889, 0.39111, 0, 0, 1.14999],
                "8656": [-0.10889, 0.39111, 0, 0, 1.14999],
                "8657": [0.19444, 0.69444, 0, 0, 0.70277],
                "8658": [-0.10889, 0.39111, 0, 0, 1.14999],
                "8659": [0.19444, 0.69444, 0, 0, 0.70277],
                "8660": [-0.10889, 0.39111, 0, 0, 1.14999],
                "8661": [0.25, 0.75, 0, 0, 0.70277],
                "8704": [0, 0.69444, 0, 0, 0.63889],
                "8706": [0, 0.69444, 0.06389, 0, 0.62847],
                "8707": [0, 0.69444, 0, 0, 0.63889],
                "8709": [0.05556, 0.75, 0, 0, 0.575],
                "8711": [0, 0.68611, 0, 0, 0.95833],
                "8712": [0.08556, 0.58556, 0, 0, 0.76666],
                "8715": [0.08556, 0.58556, 0, 0, 0.76666],
                "8722": [0.13333, 0.63333, 0, 0, 0.89444],
                "8723": [0.13333, 0.63333, 0, 0, 0.89444],
                "8725": [0.25, 0.75, 0, 0, 0.575],
                "8726": [0.25, 0.75, 0, 0, 0.575],
                "8727": [-0.02778, 0.47222, 0, 0, 0.575],
                "8728": [-0.02639, 0.47361, 0, 0, 0.575],
                "8729": [-0.02639, 0.47361, 0, 0, 0.575],
                "8730": [0.18, 0.82, 0, 0, 0.95833],
                "8733": [0, 0.44444, 0, 0, 0.89444],
                "8734": [0, 0.44444, 0, 0, 1.14999],
                "8736": [0, 0.69224, 0, 0, 0.72222],
                "8739": [0.25, 0.75, 0, 0, 0.31944],
                "8741": [0.25, 0.75, 0, 0, 0.575],
                "8743": [0, 0.55556, 0, 0, 0.76666],
                "8744": [0, 0.55556, 0, 0, 0.76666],
                "8745": [0, 0.55556, 0, 0, 0.76666],
                "8746": [0, 0.55556, 0, 0, 0.76666],
                "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875],
                "8764": [-0.10889, 0.39111, 0, 0, 0.89444],
                "8768": [0.19444, 0.69444, 0, 0, 0.31944],
                "8771": [222e-5, 0.50222, 0, 0, 0.89444],
                "8773": [0.027, 0.638, 0, 0, 0.894],
                "8776": [0.02444, 0.52444, 0, 0, 0.89444],
                "8781": [222e-5, 0.50222, 0, 0, 0.89444],
                "8801": [222e-5, 0.50222, 0, 0, 0.89444],
                "8804": [0.19667, 0.69667, 0, 0, 0.89444],
                "8805": [0.19667, 0.69667, 0, 0, 0.89444],
                "8810": [0.08556, 0.58556, 0, 0, 1.14999],
                "8811": [0.08556, 0.58556, 0, 0, 1.14999],
                "8826": [0.08556, 0.58556, 0, 0, 0.89444],
                "8827": [0.08556, 0.58556, 0, 0, 0.89444],
                "8834": [0.08556, 0.58556, 0, 0, 0.89444],
                "8835": [0.08556, 0.58556, 0, 0, 0.89444],
                "8838": [0.19667, 0.69667, 0, 0, 0.89444],
                "8839": [0.19667, 0.69667, 0, 0, 0.89444],
                "8846": [0, 0.55556, 0, 0, 0.76666],
                "8849": [0.19667, 0.69667, 0, 0, 0.89444],
                "8850": [0.19667, 0.69667, 0, 0, 0.89444],
                "8851": [0, 0.55556, 0, 0, 0.76666],
                "8852": [0, 0.55556, 0, 0, 0.76666],
                "8853": [0.13333, 0.63333, 0, 0, 0.89444],
                "8854": [0.13333, 0.63333, 0, 0, 0.89444],
                "8855": [0.13333, 0.63333, 0, 0, 0.89444],
                "8856": [0.13333, 0.63333, 0, 0, 0.89444],
                "8857": [0.13333, 0.63333, 0, 0, 0.89444],
                "8866": [0, 0.69444, 0, 0, 0.70277],
                "8867": [0, 0.69444, 0, 0, 0.70277],
                "8868": [0, 0.69444, 0, 0, 0.89444],
                "8869": [0, 0.69444, 0, 0, 0.89444],
                "8900": [-0.02639, 0.47361, 0, 0, 0.575],
                "8901": [-0.02639, 0.47361, 0, 0, 0.31944],
                "8902": [-0.02778, 0.47222, 0, 0, 0.575],
                "8968": [0.25, 0.75, 0, 0, 0.51111],
                "8969": [0.25, 0.75, 0, 0, 0.51111],
                "8970": [0.25, 0.75, 0, 0, 0.51111],
                "8971": [0.25, 0.75, 0, 0, 0.51111],
                "8994": [-0.13889, 0.36111, 0, 0, 1.14999],
                "8995": [-0.13889, 0.36111, 0, 0, 1.14999],
                "9651": [0.19444, 0.69444, 0, 0, 1.02222],
                "9657": [-0.02778, 0.47222, 0, 0, 0.575],
                "9661": [0.19444, 0.69444, 0, 0, 1.02222],
                "9667": [-0.02778, 0.47222, 0, 0, 0.575],
                "9711": [0.19444, 0.69444, 0, 0, 1.14999],
                "9824": [0.12963, 0.69444, 0, 0, 0.89444],
                "9825": [0.12963, 0.69444, 0, 0, 0.89444],
                "9826": [0.12963, 0.69444, 0, 0, 0.89444],
                "9827": [0.12963, 0.69444, 0, 0, 0.89444],
                "9837": [0, 0.75, 0, 0, 0.44722],
                "9838": [0.19444, 0.69444, 0, 0, 0.44722],
                "9839": [0.19444, 0.69444, 0, 0, 0.44722],
                "10216": [0.25, 0.75, 0, 0, 0.44722],
                "10217": [0.25, 0.75, 0, 0, 0.44722],
                "10815": [0, 0.68611, 0, 0, 0.9],
                "10927": [0.19667, 0.69667, 0, 0, 0.89444],
                "10928": [0.19667, 0.69667, 0, 0, 0.89444],
                "57376": [0.19444, 0.69444, 0, 0, 0]
              },
              "Main-BoldItalic": {
                "32": [0, 0, 0, 0, 0.25],
                "33": [0, 0.69444, 0.11417, 0, 0.38611],
                "34": [0, 0.69444, 0.07939, 0, 0.62055],
                "35": [0.19444, 0.69444, 0.06833, 0, 0.94444],
                "37": [0.05556, 0.75, 0.12861, 0, 0.94444],
                "38": [0, 0.69444, 0.08528, 0, 0.88555],
                "39": [0, 0.69444, 0.12945, 0, 0.35555],
                "40": [0.25, 0.75, 0.15806, 0, 0.47333],
                "41": [0.25, 0.75, 0.03306, 0, 0.47333],
                "42": [0, 0.75, 0.14333, 0, 0.59111],
                "43": [0.10333, 0.60333, 0.03306, 0, 0.88555],
                "44": [0.19444, 0.14722, 0, 0, 0.35555],
                "45": [0, 0.44444, 0.02611, 0, 0.41444],
                "46": [0, 0.14722, 0, 0, 0.35555],
                "47": [0.25, 0.75, 0.15806, 0, 0.59111],
                "48": [0, 0.64444, 0.13167, 0, 0.59111],
                "49": [0, 0.64444, 0.13167, 0, 0.59111],
                "50": [0, 0.64444, 0.13167, 0, 0.59111],
                "51": [0, 0.64444, 0.13167, 0, 0.59111],
                "52": [0.19444, 0.64444, 0.13167, 0, 0.59111],
                "53": [0, 0.64444, 0.13167, 0, 0.59111],
                "54": [0, 0.64444, 0.13167, 0, 0.59111],
                "55": [0.19444, 0.64444, 0.13167, 0, 0.59111],
                "56": [0, 0.64444, 0.13167, 0, 0.59111],
                "57": [0, 0.64444, 0.13167, 0, 0.59111],
                "58": [0, 0.44444, 0.06695, 0, 0.35555],
                "59": [0.19444, 0.44444, 0.06695, 0, 0.35555],
                "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555],
                "63": [0, 0.69444, 0.11472, 0, 0.59111],
                "64": [0, 0.69444, 0.09208, 0, 0.88555],
                "65": [0, 0.68611, 0, 0, 0.86555],
                "66": [0, 0.68611, 0.0992, 0, 0.81666],
                "67": [0, 0.68611, 0.14208, 0, 0.82666],
                "68": [0, 0.68611, 0.09062, 0, 0.87555],
                "69": [0, 0.68611, 0.11431, 0, 0.75666],
                "70": [0, 0.68611, 0.12903, 0, 0.72722],
                "71": [0, 0.68611, 0.07347, 0, 0.89527],
                "72": [0, 0.68611, 0.17208, 0, 0.8961],
                "73": [0, 0.68611, 0.15681, 0, 0.47166],
                "74": [0, 0.68611, 0.145, 0, 0.61055],
                "75": [0, 0.68611, 0.14208, 0, 0.89499],
                "76": [0, 0.68611, 0, 0, 0.69777],
                "77": [0, 0.68611, 0.17208, 0, 1.07277],
                "78": [0, 0.68611, 0.17208, 0, 0.8961],
                "79": [0, 0.68611, 0.09062, 0, 0.85499],
                "80": [0, 0.68611, 0.0992, 0, 0.78721],
                "81": [0.19444, 0.68611, 0.09062, 0, 0.85499],
                "82": [0, 0.68611, 0.02559, 0, 0.85944],
                "83": [0, 0.68611, 0.11264, 0, 0.64999],
                "84": [0, 0.68611, 0.12903, 0, 0.7961],
                "85": [0, 0.68611, 0.17208, 0, 0.88083],
                "86": [0, 0.68611, 0.18625, 0, 0.86555],
                "87": [0, 0.68611, 0.18625, 0, 1.15999],
                "88": [0, 0.68611, 0.15681, 0, 0.86555],
                "89": [0, 0.68611, 0.19803, 0, 0.86555],
                "90": [0, 0.68611, 0.14208, 0, 0.70888],
                "91": [0.25, 0.75, 0.1875, 0, 0.35611],
                "93": [0.25, 0.75, 0.09972, 0, 0.35611],
                "94": [0, 0.69444, 0.06709, 0, 0.59111],
                "95": [0.31, 0.13444, 0.09811, 0, 0.59111],
                "97": [0, 0.44444, 0.09426, 0, 0.59111],
                "98": [0, 0.69444, 0.07861, 0, 0.53222],
                "99": [0, 0.44444, 0.05222, 0, 0.53222],
                "100": [0, 0.69444, 0.10861, 0, 0.59111],
                "101": [0, 0.44444, 0.085, 0, 0.53222],
                "102": [0.19444, 0.69444, 0.21778, 0, 0.4],
                "103": [0.19444, 0.44444, 0.105, 0, 0.53222],
                "104": [0, 0.69444, 0.09426, 0, 0.59111],
                "105": [0, 0.69326, 0.11387, 0, 0.35555],
                "106": [0.19444, 0.69326, 0.1672, 0, 0.35555],
                "107": [0, 0.69444, 0.11111, 0, 0.53222],
                "108": [0, 0.69444, 0.10861, 0, 0.29666],
                "109": [0, 0.44444, 0.09426, 0, 0.94444],
                "110": [0, 0.44444, 0.09426, 0, 0.64999],
                "111": [0, 0.44444, 0.07861, 0, 0.59111],
                "112": [0.19444, 0.44444, 0.07861, 0, 0.59111],
                "113": [0.19444, 0.44444, 0.105, 0, 0.53222],
                "114": [0, 0.44444, 0.11111, 0, 0.50167],
                "115": [0, 0.44444, 0.08167, 0, 0.48694],
                "116": [0, 0.63492, 0.09639, 0, 0.385],
                "117": [0, 0.44444, 0.09426, 0, 0.62055],
                "118": [0, 0.44444, 0.11111, 0, 0.53222],
                "119": [0, 0.44444, 0.11111, 0, 0.76777],
                "120": [0, 0.44444, 0.12583, 0, 0.56055],
                "121": [0.19444, 0.44444, 0.105, 0, 0.56166],
                "122": [0, 0.44444, 0.13889, 0, 0.49055],
                "126": [0.35, 0.34444, 0.11472, 0, 0.59111],
                "160": [0, 0, 0, 0, 0.25],
                "168": [0, 0.69444, 0.11473, 0, 0.59111],
                "176": [0, 0.69444, 0, 0, 0.94888],
                "184": [0.17014, 0, 0, 0, 0.53222],
                "198": [0, 0.68611, 0.11431, 0, 1.02277],
                "216": [0.04861, 0.73472, 0.09062, 0, 0.88555],
                "223": [0.19444, 0.69444, 0.09736, 0, 0.665],
                "230": [0, 0.44444, 0.085, 0, 0.82666],
                "248": [0.09722, 0.54167, 0.09458, 0, 0.59111],
                "305": [0, 0.44444, 0.09426, 0, 0.35555],
                "338": [0, 0.68611, 0.11431, 0, 1.14054],
                "339": [0, 0.44444, 0.085, 0, 0.82666],
                "567": [0.19444, 0.44444, 0.04611, 0, 0.385],
                "710": [0, 0.69444, 0.06709, 0, 0.59111],
                "711": [0, 0.63194, 0.08271, 0, 0.59111],
                "713": [0, 0.59444, 0.10444, 0, 0.59111],
                "714": [0, 0.69444, 0.08528, 0, 0.59111],
                "715": [0, 0.69444, 0, 0, 0.59111],
                "728": [0, 0.69444, 0.10333, 0, 0.59111],
                "729": [0, 0.69444, 0.12945, 0, 0.35555],
                "730": [0, 0.69444, 0, 0, 0.94888],
                "732": [0, 0.69444, 0.11472, 0, 0.59111],
                "733": [0, 0.69444, 0.11472, 0, 0.59111],
                "915": [0, 0.68611, 0.12903, 0, 0.69777],
                "916": [0, 0.68611, 0, 0, 0.94444],
                "920": [0, 0.68611, 0.09062, 0, 0.88555],
                "923": [0, 0.68611, 0, 0, 0.80666],
                "926": [0, 0.68611, 0.15092, 0, 0.76777],
                "928": [0, 0.68611, 0.17208, 0, 0.8961],
                "931": [0, 0.68611, 0.11431, 0, 0.82666],
                "933": [0, 0.68611, 0.10778, 0, 0.88555],
                "934": [0, 0.68611, 0.05632, 0, 0.82666],
                "936": [0, 0.68611, 0.10778, 0, 0.88555],
                "937": [0, 0.68611, 0.0992, 0, 0.82666],
                "8211": [0, 0.44444, 0.09811, 0, 0.59111],
                "8212": [0, 0.44444, 0.09811, 0, 1.18221],
                "8216": [0, 0.69444, 0.12945, 0, 0.35555],
                "8217": [0, 0.69444, 0.12945, 0, 0.35555],
                "8220": [0, 0.69444, 0.16772, 0, 0.62055],
                "8221": [0, 0.69444, 0.07939, 0, 0.62055]
              },
              "Main-Italic": {
                "32": [0, 0, 0, 0, 0.25],
                "33": [0, 0.69444, 0.12417, 0, 0.30667],
                "34": [0, 0.69444, 0.06961, 0, 0.51444],
                "35": [0.19444, 0.69444, 0.06616, 0, 0.81777],
                "37": [0.05556, 0.75, 0.13639, 0, 0.81777],
                "38": [0, 0.69444, 0.09694, 0, 0.76666],
                "39": [0, 0.69444, 0.12417, 0, 0.30667],
                "40": [0.25, 0.75, 0.16194, 0, 0.40889],
                "41": [0.25, 0.75, 0.03694, 0, 0.40889],
                "42": [0, 0.75, 0.14917, 0, 0.51111],
                "43": [0.05667, 0.56167, 0.03694, 0, 0.76666],
                "44": [0.19444, 0.10556, 0, 0, 0.30667],
                "45": [0, 0.43056, 0.02826, 0, 0.35778],
                "46": [0, 0.10556, 0, 0, 0.30667],
                "47": [0.25, 0.75, 0.16194, 0, 0.51111],
                "48": [0, 0.64444, 0.13556, 0, 0.51111],
                "49": [0, 0.64444, 0.13556, 0, 0.51111],
                "50": [0, 0.64444, 0.13556, 0, 0.51111],
                "51": [0, 0.64444, 0.13556, 0, 0.51111],
                "52": [0.19444, 0.64444, 0.13556, 0, 0.51111],
                "53": [0, 0.64444, 0.13556, 0, 0.51111],
                "54": [0, 0.64444, 0.13556, 0, 0.51111],
                "55": [0.19444, 0.64444, 0.13556, 0, 0.51111],
                "56": [0, 0.64444, 0.13556, 0, 0.51111],
                "57": [0, 0.64444, 0.13556, 0, 0.51111],
                "58": [0, 0.43056, 0.0582, 0, 0.30667],
                "59": [0.19444, 0.43056, 0.0582, 0, 0.30667],
                "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666],
                "63": [0, 0.69444, 0.1225, 0, 0.51111],
                "64": [0, 0.69444, 0.09597, 0, 0.76666],
                "65": [0, 0.68333, 0, 0, 0.74333],
                "66": [0, 0.68333, 0.10257, 0, 0.70389],
                "67": [0, 0.68333, 0.14528, 0, 0.71555],
                "68": [0, 0.68333, 0.09403, 0, 0.755],
                "69": [0, 0.68333, 0.12028, 0, 0.67833],
                "70": [0, 0.68333, 0.13305, 0, 0.65277],
                "71": [0, 0.68333, 0.08722, 0, 0.77361],
                "72": [0, 0.68333, 0.16389, 0, 0.74333],
                "73": [0, 0.68333, 0.15806, 0, 0.38555],
                "74": [0, 0.68333, 0.14028, 0, 0.525],
                "75": [0, 0.68333, 0.14528, 0, 0.76888],
                "76": [0, 0.68333, 0, 0, 0.62722],
                "77": [0, 0.68333, 0.16389, 0, 0.89666],
                "78": [0, 0.68333, 0.16389, 0, 0.74333],
                "79": [0, 0.68333, 0.09403, 0, 0.76666],
                "80": [0, 0.68333, 0.10257, 0, 0.67833],
                "81": [0.19444, 0.68333, 0.09403, 0, 0.76666],
                "82": [0, 0.68333, 0.03868, 0, 0.72944],
                "83": [0, 0.68333, 0.11972, 0, 0.56222],
                "84": [0, 0.68333, 0.13305, 0, 0.71555],
                "85": [0, 0.68333, 0.16389, 0, 0.74333],
                "86": [0, 0.68333, 0.18361, 0, 0.74333],
                "87": [0, 0.68333, 0.18361, 0, 0.99888],
                "88": [0, 0.68333, 0.15806, 0, 0.74333],
                "89": [0, 0.68333, 0.19383, 0, 0.74333],
                "90": [0, 0.68333, 0.14528, 0, 0.61333],
                "91": [0.25, 0.75, 0.1875, 0, 0.30667],
                "93": [0.25, 0.75, 0.10528, 0, 0.30667],
                "94": [0, 0.69444, 0.06646, 0, 0.51111],
                "95": [0.31, 0.12056, 0.09208, 0, 0.51111],
                "97": [0, 0.43056, 0.07671, 0, 0.51111],
                "98": [0, 0.69444, 0.06312, 0, 0.46],
                "99": [0, 0.43056, 0.05653, 0, 0.46],
                "100": [0, 0.69444, 0.10333, 0, 0.51111],
                "101": [0, 0.43056, 0.07514, 0, 0.46],
                "102": [0.19444, 0.69444, 0.21194, 0, 0.30667],
                "103": [0.19444, 0.43056, 0.08847, 0, 0.46],
                "104": [0, 0.69444, 0.07671, 0, 0.51111],
                "105": [0, 0.65536, 0.1019, 0, 0.30667],
                "106": [0.19444, 0.65536, 0.14467, 0, 0.30667],
                "107": [0, 0.69444, 0.10764, 0, 0.46],
                "108": [0, 0.69444, 0.10333, 0, 0.25555],
                "109": [0, 0.43056, 0.07671, 0, 0.81777],
                "110": [0, 0.43056, 0.07671, 0, 0.56222],
                "111": [0, 0.43056, 0.06312, 0, 0.51111],
                "112": [0.19444, 0.43056, 0.06312, 0, 0.51111],
                "113": [0.19444, 0.43056, 0.08847, 0, 0.46],
                "114": [0, 0.43056, 0.10764, 0, 0.42166],
                "115": [0, 0.43056, 0.08208, 0, 0.40889],
                "116": [0, 0.61508, 0.09486, 0, 0.33222],
                "117": [0, 0.43056, 0.07671, 0, 0.53666],
                "118": [0, 0.43056, 0.10764, 0, 0.46],
                "119": [0, 0.43056, 0.10764, 0, 0.66444],
                "120": [0, 0.43056, 0.12042, 0, 0.46389],
                "121": [0.19444, 0.43056, 0.08847, 0, 0.48555],
                "122": [0, 0.43056, 0.12292, 0, 0.40889],
                "126": [0.35, 0.31786, 0.11585, 0, 0.51111],
                "160": [0, 0, 0, 0, 0.25],
                "168": [0, 0.66786, 0.10474, 0, 0.51111],
                "176": [0, 0.69444, 0, 0, 0.83129],
                "184": [0.17014, 0, 0, 0, 0.46],
                "198": [0, 0.68333, 0.12028, 0, 0.88277],
                "216": [0.04861, 0.73194, 0.09403, 0, 0.76666],
                "223": [0.19444, 0.69444, 0.10514, 0, 0.53666],
                "230": [0, 0.43056, 0.07514, 0, 0.71555],
                "248": [0.09722, 0.52778, 0.09194, 0, 0.51111],
                "338": [0, 0.68333, 0.12028, 0, 0.98499],
                "339": [0, 0.43056, 0.07514, 0, 0.71555],
                "710": [0, 0.69444, 0.06646, 0, 0.51111],
                "711": [0, 0.62847, 0.08295, 0, 0.51111],
                "713": [0, 0.56167, 0.10333, 0, 0.51111],
                "714": [0, 0.69444, 0.09694, 0, 0.51111],
                "715": [0, 0.69444, 0, 0, 0.51111],
                "728": [0, 0.69444, 0.10806, 0, 0.51111],
                "729": [0, 0.66786, 0.11752, 0, 0.30667],
                "730": [0, 0.69444, 0, 0, 0.83129],
                "732": [0, 0.66786, 0.11585, 0, 0.51111],
                "733": [0, 0.69444, 0.1225, 0, 0.51111],
                "915": [0, 0.68333, 0.13305, 0, 0.62722],
                "916": [0, 0.68333, 0, 0, 0.81777],
                "920": [0, 0.68333, 0.09403, 0, 0.76666],
                "923": [0, 0.68333, 0, 0, 0.69222],
                "926": [0, 0.68333, 0.15294, 0, 0.66444],
                "928": [0, 0.68333, 0.16389, 0, 0.74333],
                "931": [0, 0.68333, 0.12028, 0, 0.71555],
                "933": [0, 0.68333, 0.11111, 0, 0.76666],
                "934": [0, 0.68333, 0.05986, 0, 0.71555],
                "936": [0, 0.68333, 0.11111, 0, 0.76666],
                "937": [0, 0.68333, 0.10257, 0, 0.71555],
                "8211": [0, 0.43056, 0.09208, 0, 0.51111],
                "8212": [0, 0.43056, 0.09208, 0, 1.02222],
                "8216": [0, 0.69444, 0.12417, 0, 0.30667],
                "8217": [0, 0.69444, 0.12417, 0, 0.30667],
                "8220": [0, 0.69444, 0.1685, 0, 0.51444],
                "8221": [0, 0.69444, 0.06961, 0, 0.51444],
                "8463": [0, 0.68889, 0, 0, 0.54028]
              },
              "Main-Regular": {
                "32": [0, 0, 0, 0, 0.25],
                "33": [0, 0.69444, 0, 0, 0.27778],
                "34": [0, 0.69444, 0, 0, 0.5],
                "35": [0.19444, 0.69444, 0, 0, 0.83334],
                "36": [0.05556, 0.75, 0, 0, 0.5],
                "37": [0.05556, 0.75, 0, 0, 0.83334],
                "38": [0, 0.69444, 0, 0, 0.77778],
                "39": [0, 0.69444, 0, 0, 0.27778],
                "40": [0.25, 0.75, 0, 0, 0.38889],
                "41": [0.25, 0.75, 0, 0, 0.38889],
                "42": [0, 0.75, 0, 0, 0.5],
                "43": [0.08333, 0.58333, 0, 0, 0.77778],
                "44": [0.19444, 0.10556, 0, 0, 0.27778],
                "45": [0, 0.43056, 0, 0, 0.33333],
                "46": [0, 0.10556, 0, 0, 0.27778],
                "47": [0.25, 0.75, 0, 0, 0.5],
                "48": [0, 0.64444, 0, 0, 0.5],
                "49": [0, 0.64444, 0, 0, 0.5],
                "50": [0, 0.64444, 0, 0, 0.5],
                "51": [0, 0.64444, 0, 0, 0.5],
                "52": [0, 0.64444, 0, 0, 0.5],
                "53": [0, 0.64444, 0, 0, 0.5],
                "54": [0, 0.64444, 0, 0, 0.5],
                "55": [0, 0.64444, 0, 0, 0.5],
                "56": [0, 0.64444, 0, 0, 0.5],
                "57": [0, 0.64444, 0, 0, 0.5],
                "58": [0, 0.43056, 0, 0, 0.27778],
                "59": [0.19444, 0.43056, 0, 0, 0.27778],
                "60": [0.0391, 0.5391, 0, 0, 0.77778],
                "61": [-0.13313, 0.36687, 0, 0, 0.77778],
                "62": [0.0391, 0.5391, 0, 0, 0.77778],
                "63": [0, 0.69444, 0, 0, 0.47222],
                "64": [0, 0.69444, 0, 0, 0.77778],
                "65": [0, 0.68333, 0, 0, 0.75],
                "66": [0, 0.68333, 0, 0, 0.70834],
                "67": [0, 0.68333, 0, 0, 0.72222],
                "68": [0, 0.68333, 0, 0, 0.76389],
                "69": [0, 0.68333, 0, 0, 0.68056],
                "70": [0, 0.68333, 0, 0, 0.65278],
                "71": [0, 0.68333, 0, 0, 0.78472],
                "72": [0, 0.68333, 0, 0, 0.75],
                "73": [0, 0.68333, 0, 0, 0.36111],
                "74": [0, 0.68333, 0, 0, 0.51389],
                "75": [0, 0.68333, 0, 0, 0.77778],
                "76": [0, 0.68333, 0, 0, 0.625],
                "77": [0, 0.68333, 0, 0, 0.91667],
                "78": [0, 0.68333, 0, 0, 0.75],
                "79": [0, 0.68333, 0, 0, 0.77778],
                "80": [0, 0.68333, 0, 0, 0.68056],
                "81": [0.19444, 0.68333, 0, 0, 0.77778],
                "82": [0, 0.68333, 0, 0, 0.73611],
                "83": [0, 0.68333, 0, 0, 0.55556],
                "84": [0, 0.68333, 0, 0, 0.72222],
                "85": [0, 0.68333, 0, 0, 0.75],
                "86": [0, 0.68333, 0.01389, 0, 0.75],
                "87": [0, 0.68333, 0.01389, 0, 1.02778],
                "88": [0, 0.68333, 0, 0, 0.75],
                "89": [0, 0.68333, 0.025, 0, 0.75],
                "90": [0, 0.68333, 0, 0, 0.61111],
                "91": [0.25, 0.75, 0, 0, 0.27778],
                "92": [0.25, 0.75, 0, 0, 0.5],
                "93": [0.25, 0.75, 0, 0, 0.27778],
                "94": [0, 0.69444, 0, 0, 0.5],
                "95": [0.31, 0.12056, 0.02778, 0, 0.5],
                "97": [0, 0.43056, 0, 0, 0.5],
                "98": [0, 0.69444, 0, 0, 0.55556],
                "99": [0, 0.43056, 0, 0, 0.44445],
                "100": [0, 0.69444, 0, 0, 0.55556],
                "101": [0, 0.43056, 0, 0, 0.44445],
                "102": [0, 0.69444, 0.07778, 0, 0.30556],
                "103": [0.19444, 0.43056, 0.01389, 0, 0.5],
                "104": [0, 0.69444, 0, 0, 0.55556],
                "105": [0, 0.66786, 0, 0, 0.27778],
                "106": [0.19444, 0.66786, 0, 0, 0.30556],
                "107": [0, 0.69444, 0, 0, 0.52778],
                "108": [0, 0.69444, 0, 0, 0.27778],
                "109": [0, 0.43056, 0, 0, 0.83334],
                "110": [0, 0.43056, 0, 0, 0.55556],
                "111": [0, 0.43056, 0, 0, 0.5],
                "112": [0.19444, 0.43056, 0, 0, 0.55556],
                "113": [0.19444, 0.43056, 0, 0, 0.52778],
                "114": [0, 0.43056, 0, 0, 0.39167],
                "115": [0, 0.43056, 0, 0, 0.39445],
                "116": [0, 0.61508, 0, 0, 0.38889],
                "117": [0, 0.43056, 0, 0, 0.55556],
                "118": [0, 0.43056, 0.01389, 0, 0.52778],
                "119": [0, 0.43056, 0.01389, 0, 0.72222],
                "120": [0, 0.43056, 0, 0, 0.52778],
                "121": [0.19444, 0.43056, 0.01389, 0, 0.52778],
                "122": [0, 0.43056, 0, 0, 0.44445],
                "123": [0.25, 0.75, 0, 0, 0.5],
                "124": [0.25, 0.75, 0, 0, 0.27778],
                "125": [0.25, 0.75, 0, 0, 0.5],
                "126": [0.35, 0.31786, 0, 0, 0.5],
                "160": [0, 0, 0, 0, 0.25],
                "163": [0, 0.69444, 0, 0, 0.76909],
                "167": [0.19444, 0.69444, 0, 0, 0.44445],
                "168": [0, 0.66786, 0, 0, 0.5],
                "172": [0, 0.43056, 0, 0, 0.66667],
                "176": [0, 0.69444, 0, 0, 0.75],
                "177": [0.08333, 0.58333, 0, 0, 0.77778],
                "182": [0.19444, 0.69444, 0, 0, 0.61111],
                "184": [0.17014, 0, 0, 0, 0.44445],
                "198": [0, 0.68333, 0, 0, 0.90278],
                "215": [0.08333, 0.58333, 0, 0, 0.77778],
                "216": [0.04861, 0.73194, 0, 0, 0.77778],
                "223": [0, 0.69444, 0, 0, 0.5],
                "230": [0, 0.43056, 0, 0, 0.72222],
                "247": [0.08333, 0.58333, 0, 0, 0.77778],
                "248": [0.09722, 0.52778, 0, 0, 0.5],
                "305": [0, 0.43056, 0, 0, 0.27778],
                "338": [0, 0.68333, 0, 0, 1.01389],
                "339": [0, 0.43056, 0, 0, 0.77778],
                "567": [0.19444, 0.43056, 0, 0, 0.30556],
                "710": [0, 0.69444, 0, 0, 0.5],
                "711": [0, 0.62847, 0, 0, 0.5],
                "713": [0, 0.56778, 0, 0, 0.5],
                "714": [0, 0.69444, 0, 0, 0.5],
                "715": [0, 0.69444, 0, 0, 0.5],
                "728": [0, 0.69444, 0, 0, 0.5],
                "729": [0, 0.66786, 0, 0, 0.27778],
                "730": [0, 0.69444, 0, 0, 0.75],
                "732": [0, 0.66786, 0, 0, 0.5],
                "733": [0, 0.69444, 0, 0, 0.5],
                "915": [0, 0.68333, 0, 0, 0.625],
                "916": [0, 0.68333, 0, 0, 0.83334],
                "920": [0, 0.68333, 0, 0, 0.77778],
                "923": [0, 0.68333, 0, 0, 0.69445],
                "926": [0, 0.68333, 0, 0, 0.66667],
                "928": [0, 0.68333, 0, 0, 0.75],
                "931": [0, 0.68333, 0, 0, 0.72222],
                "933": [0, 0.68333, 0, 0, 0.77778],
                "934": [0, 0.68333, 0, 0, 0.72222],
                "936": [0, 0.68333, 0, 0, 0.77778],
                "937": [0, 0.68333, 0, 0, 0.72222],
                "8211": [0, 0.43056, 0.02778, 0, 0.5],
                "8212": [0, 0.43056, 0.02778, 0, 1],
                "8216": [0, 0.69444, 0, 0, 0.27778],
                "8217": [0, 0.69444, 0, 0, 0.27778],
                "8220": [0, 0.69444, 0, 0, 0.5],
                "8221": [0, 0.69444, 0, 0, 0.5],
                "8224": [0.19444, 0.69444, 0, 0, 0.44445],
                "8225": [0.19444, 0.69444, 0, 0, 0.44445],
                "8230": [0, 0.123, 0, 0, 1.172],
                "8242": [0, 0.55556, 0, 0, 0.275],
                "8407": [0, 0.71444, 0.15382, 0, 0.5],
                "8463": [0, 0.68889, 0, 0, 0.54028],
                "8465": [0, 0.69444, 0, 0, 0.72222],
                "8467": [0, 0.69444, 0, 0.11111, 0.41667],
                "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646],
                "8476": [0, 0.69444, 0, 0, 0.72222],
                "8501": [0, 0.69444, 0, 0, 0.61111],
                "8592": [-0.13313, 0.36687, 0, 0, 1],
                "8593": [0.19444, 0.69444, 0, 0, 0.5],
                "8594": [-0.13313, 0.36687, 0, 0, 1],
                "8595": [0.19444, 0.69444, 0, 0, 0.5],
                "8596": [-0.13313, 0.36687, 0, 0, 1],
                "8597": [0.25, 0.75, 0, 0, 0.5],
                "8598": [0.19444, 0.69444, 0, 0, 1],
                "8599": [0.19444, 0.69444, 0, 0, 1],
                "8600": [0.19444, 0.69444, 0, 0, 1],
                "8601": [0.19444, 0.69444, 0, 0, 1],
                "8614": [0.011, 0.511, 0, 0, 1],
                "8617": [0.011, 0.511, 0, 0, 1.126],
                "8618": [0.011, 0.511, 0, 0, 1.126],
                "8636": [-0.13313, 0.36687, 0, 0, 1],
                "8637": [-0.13313, 0.36687, 0, 0, 1],
                "8640": [-0.13313, 0.36687, 0, 0, 1],
                "8641": [-0.13313, 0.36687, 0, 0, 1],
                "8652": [0.011, 0.671, 0, 0, 1],
                "8656": [-0.13313, 0.36687, 0, 0, 1],
                "8657": [0.19444, 0.69444, 0, 0, 0.61111],
                "8658": [-0.13313, 0.36687, 0, 0, 1],
                "8659": [0.19444, 0.69444, 0, 0, 0.61111],
                "8660": [-0.13313, 0.36687, 0, 0, 1],
                "8661": [0.25, 0.75, 0, 0, 0.61111],
                "8704": [0, 0.69444, 0, 0, 0.55556],
                "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309],
                "8707": [0, 0.69444, 0, 0, 0.55556],
                "8709": [0.05556, 0.75, 0, 0, 0.5],
                "8711": [0, 0.68333, 0, 0, 0.83334],
                "8712": [0.0391, 0.5391, 0, 0, 0.66667],
                "8715": [0.0391, 0.5391, 0, 0, 0.66667],
                "8722": [0.08333, 0.58333, 0, 0, 0.77778],
                "8723": [0.08333, 0.58333, 0, 0, 0.77778],
                "8725": [0.25, 0.75, 0, 0, 0.5],
                "8726": [0.25, 0.75, 0, 0, 0.5],
                "8727": [-0.03472, 0.46528, 0, 0, 0.5],
                "8728": [-0.05555, 0.44445, 0, 0, 0.5],
                "8729": [-0.05555, 0.44445, 0, 0, 0.5],
                "8730": [0.2, 0.8, 0, 0, 0.83334],
                "8733": [0, 0.43056, 0, 0, 0.77778],
                "8734": [0, 0.43056, 0, 0, 1],
                "8736": [0, 0.69224, 0, 0, 0.72222],
                "8739": [0.25, 0.75, 0, 0, 0.27778],
                "8741": [0.25, 0.75, 0, 0, 0.5],
                "8743": [0, 0.55556, 0, 0, 0.66667],
                "8744": [0, 0.55556, 0, 0, 0.66667],
                "8745": [0, 0.55556, 0, 0, 0.66667],
                "8746": [0, 0.55556, 0, 0, 0.66667],
                "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667],
                "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
                "8768": [0.19444, 0.69444, 0, 0, 0.27778],
                "8771": [-0.03625, 0.46375, 0, 0, 0.77778],
                "8773": [-0.022, 0.589, 0, 0, 0.778],
                "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
                "8781": [-0.03625, 0.46375, 0, 0, 0.77778],
                "8784": [-0.133, 0.673, 0, 0, 0.778],
                "8801": [-0.03625, 0.46375, 0, 0, 0.77778],
                "8804": [0.13597, 0.63597, 0, 0, 0.77778],
                "8805": [0.13597, 0.63597, 0, 0, 0.77778],
                "8810": [0.0391, 0.5391, 0, 0, 1],
                "8811": [0.0391, 0.5391, 0, 0, 1],
                "8826": [0.0391, 0.5391, 0, 0, 0.77778],
                "8827": [0.0391, 0.5391, 0, 0, 0.77778],
                "8834": [0.0391, 0.5391, 0, 0, 0.77778],
                "8835": [0.0391, 0.5391, 0, 0, 0.77778],
                "8838": [0.13597, 0.63597, 0, 0, 0.77778],
                "8839": [0.13597, 0.63597, 0, 0, 0.77778],
                "8846": [0, 0.55556, 0, 0, 0.66667],
                "8849": [0.13597, 0.63597, 0, 0, 0.77778],
                "8850": [0.13597, 0.63597, 0, 0, 0.77778],
                "8851": [0, 0.55556, 0, 0, 0.66667],
                "8852": [0, 0.55556, 0, 0, 0.66667],
                "8853": [0.08333, 0.58333, 0, 0, 0.77778],
                "8854": [0.08333, 0.58333, 0, 0, 0.77778],
                "8855": [0.08333, 0.58333, 0, 0, 0.77778],
                "8856": [0.08333, 0.58333, 0, 0, 0.77778],
                "8857": [0.08333, 0.58333, 0, 0, 0.77778],
                "8866": [0, 0.69444, 0, 0, 0.61111],
                "8867": [0, 0.69444, 0, 0, 0.61111],
                "8868": [0, 0.69444, 0, 0, 0.77778],
                "8869": [0, 0.69444, 0, 0, 0.77778],
                "8872": [0.249, 0.75, 0, 0, 0.867],
                "8900": [-0.05555, 0.44445, 0, 0, 0.5],
                "8901": [-0.05555, 0.44445, 0, 0, 0.27778],
                "8902": [-0.03472, 0.46528, 0, 0, 0.5],
                "8904": [5e-3, 0.505, 0, 0, 0.9],
                "8942": [0.03, 0.903, 0, 0, 0.278],
                "8943": [-0.19, 0.313, 0, 0, 1.172],
                "8945": [-0.1, 0.823, 0, 0, 1.282],
                "8968": [0.25, 0.75, 0, 0, 0.44445],
                "8969": [0.25, 0.75, 0, 0, 0.44445],
                "8970": [0.25, 0.75, 0, 0, 0.44445],
                "8971": [0.25, 0.75, 0, 0, 0.44445],
                "8994": [-0.14236, 0.35764, 0, 0, 1],
                "8995": [-0.14236, 0.35764, 0, 0, 1],
                "9136": [0.244, 0.744, 0, 0, 0.412],
                "9137": [0.244, 0.745, 0, 0, 0.412],
                "9651": [0.19444, 0.69444, 0, 0, 0.88889],
                "9657": [-0.03472, 0.46528, 0, 0, 0.5],
                "9661": [0.19444, 0.69444, 0, 0, 0.88889],
                "9667": [-0.03472, 0.46528, 0, 0, 0.5],
                "9711": [0.19444, 0.69444, 0, 0, 1],
                "9824": [0.12963, 0.69444, 0, 0, 0.77778],
                "9825": [0.12963, 0.69444, 0, 0, 0.77778],
                "9826": [0.12963, 0.69444, 0, 0, 0.77778],
                "9827": [0.12963, 0.69444, 0, 0, 0.77778],
                "9837": [0, 0.75, 0, 0, 0.38889],
                "9838": [0.19444, 0.69444, 0, 0, 0.38889],
                "9839": [0.19444, 0.69444, 0, 0, 0.38889],
                "10216": [0.25, 0.75, 0, 0, 0.38889],
                "10217": [0.25, 0.75, 0, 0, 0.38889],
                "10222": [0.244, 0.744, 0, 0, 0.412],
                "10223": [0.244, 0.745, 0, 0, 0.412],
                "10229": [0.011, 0.511, 0, 0, 1.609],
                "10230": [0.011, 0.511, 0, 0, 1.638],
                "10231": [0.011, 0.511, 0, 0, 1.859],
                "10232": [0.024, 0.525, 0, 0, 1.609],
                "10233": [0.024, 0.525, 0, 0, 1.638],
                "10234": [0.024, 0.525, 0, 0, 1.858],
                "10236": [0.011, 0.511, 0, 0, 1.638],
                "10815": [0, 0.68333, 0, 0, 0.75],
                "10927": [0.13597, 0.63597, 0, 0, 0.77778],
                "10928": [0.13597, 0.63597, 0, 0, 0.77778],
                "57376": [0.19444, 0.69444, 0, 0, 0]
              },
              "Math-BoldItalic": {
                "32": [0, 0, 0, 0, 0.25],
                "48": [0, 0.44444, 0, 0, 0.575],
                "49": [0, 0.44444, 0, 0, 0.575],
                "50": [0, 0.44444, 0, 0, 0.575],
                "51": [0.19444, 0.44444, 0, 0, 0.575],
                "52": [0.19444, 0.44444, 0, 0, 0.575],
                "53": [0.19444, 0.44444, 0, 0, 0.575],
                "54": [0, 0.64444, 0, 0, 0.575],
                "55": [0.19444, 0.44444, 0, 0, 0.575],
                "56": [0, 0.64444, 0, 0, 0.575],
                "57": [0.19444, 0.44444, 0, 0, 0.575],
                "65": [0, 0.68611, 0, 0, 0.86944],
                "66": [0, 0.68611, 0.04835, 0, 0.8664],
                "67": [0, 0.68611, 0.06979, 0, 0.81694],
                "68": [0, 0.68611, 0.03194, 0, 0.93812],
                "69": [0, 0.68611, 0.05451, 0, 0.81007],
                "70": [0, 0.68611, 0.15972, 0, 0.68889],
                "71": [0, 0.68611, 0, 0, 0.88673],
                "72": [0, 0.68611, 0.08229, 0, 0.98229],
                "73": [0, 0.68611, 0.07778, 0, 0.51111],
                "74": [0, 0.68611, 0.10069, 0, 0.63125],
                "75": [0, 0.68611, 0.06979, 0, 0.97118],
                "76": [0, 0.68611, 0, 0, 0.75555],
                "77": [0, 0.68611, 0.11424, 0, 1.14201],
                "78": [0, 0.68611, 0.11424, 0, 0.95034],
                "79": [0, 0.68611, 0.03194, 0, 0.83666],
                "80": [0, 0.68611, 0.15972, 0, 0.72309],
                "81": [0.19444, 0.68611, 0, 0, 0.86861],
                "82": [0, 0.68611, 421e-5, 0, 0.87235],
                "83": [0, 0.68611, 0.05382, 0, 0.69271],
                "84": [0, 0.68611, 0.15972, 0, 0.63663],
                "85": [0, 0.68611, 0.11424, 0, 0.80027],
                "86": [0, 0.68611, 0.25555, 0, 0.67778],
                "87": [0, 0.68611, 0.15972, 0, 1.09305],
                "88": [0, 0.68611, 0.07778, 0, 0.94722],
                "89": [0, 0.68611, 0.25555, 0, 0.67458],
                "90": [0, 0.68611, 0.06979, 0, 0.77257],
                "97": [0, 0.44444, 0, 0, 0.63287],
                "98": [0, 0.69444, 0, 0, 0.52083],
                "99": [0, 0.44444, 0, 0, 0.51342],
                "100": [0, 0.69444, 0, 0, 0.60972],
                "101": [0, 0.44444, 0, 0, 0.55361],
                "102": [0.19444, 0.69444, 0.11042, 0, 0.56806],
                "103": [0.19444, 0.44444, 0.03704, 0, 0.5449],
                "104": [0, 0.69444, 0, 0, 0.66759],
                "105": [0, 0.69326, 0, 0, 0.4048],
                "106": [0.19444, 0.69326, 0.0622, 0, 0.47083],
                "107": [0, 0.69444, 0.01852, 0, 0.6037],
                "108": [0, 0.69444, 88e-4, 0, 0.34815],
                "109": [0, 0.44444, 0, 0, 1.0324],
                "110": [0, 0.44444, 0, 0, 0.71296],
                "111": [0, 0.44444, 0, 0, 0.58472],
                "112": [0.19444, 0.44444, 0, 0, 0.60092],
                "113": [0.19444, 0.44444, 0.03704, 0, 0.54213],
                "114": [0, 0.44444, 0.03194, 0, 0.5287],
                "115": [0, 0.44444, 0, 0, 0.53125],
                "116": [0, 0.63492, 0, 0, 0.41528],
                "117": [0, 0.44444, 0, 0, 0.68102],
                "118": [0, 0.44444, 0.03704, 0, 0.56666],
                "119": [0, 0.44444, 0.02778, 0, 0.83148],
                "120": [0, 0.44444, 0, 0, 0.65903],
                "121": [0.19444, 0.44444, 0.03704, 0, 0.59028],
                "122": [0, 0.44444, 0.04213, 0, 0.55509],
                "160": [0, 0, 0, 0, 0.25],
                "915": [0, 0.68611, 0.15972, 0, 0.65694],
                "916": [0, 0.68611, 0, 0, 0.95833],
                "920": [0, 0.68611, 0.03194, 0, 0.86722],
                "923": [0, 0.68611, 0, 0, 0.80555],
                "926": [0, 0.68611, 0.07458, 0, 0.84125],
                "928": [0, 0.68611, 0.08229, 0, 0.98229],
                "931": [0, 0.68611, 0.05451, 0, 0.88507],
                "933": [0, 0.68611, 0.15972, 0, 0.67083],
                "934": [0, 0.68611, 0, 0, 0.76666],
                "936": [0, 0.68611, 0.11653, 0, 0.71402],
                "937": [0, 0.68611, 0.04835, 0, 0.8789],
                "945": [0, 0.44444, 0, 0, 0.76064],
                "946": [0.19444, 0.69444, 0.03403, 0, 0.65972],
                "947": [0.19444, 0.44444, 0.06389, 0, 0.59003],
                "948": [0, 0.69444, 0.03819, 0, 0.52222],
                "949": [0, 0.44444, 0, 0, 0.52882],
                "950": [0.19444, 0.69444, 0.06215, 0, 0.50833],
                "951": [0.19444, 0.44444, 0.03704, 0, 0.6],
                "952": [0, 0.69444, 0.03194, 0, 0.5618],
                "953": [0, 0.44444, 0, 0, 0.41204],
                "954": [0, 0.44444, 0, 0, 0.66759],
                "955": [0, 0.69444, 0, 0, 0.67083],
                "956": [0.19444, 0.44444, 0, 0, 0.70787],
                "957": [0, 0.44444, 0.06898, 0, 0.57685],
                "958": [0.19444, 0.69444, 0.03021, 0, 0.50833],
                "959": [0, 0.44444, 0, 0, 0.58472],
                "960": [0, 0.44444, 0.03704, 0, 0.68241],
                "961": [0.19444, 0.44444, 0, 0, 0.6118],
                "962": [0.09722, 0.44444, 0.07917, 0, 0.42361],
                "963": [0, 0.44444, 0.03704, 0, 0.68588],
                "964": [0, 0.44444, 0.13472, 0, 0.52083],
                "965": [0, 0.44444, 0.03704, 0, 0.63055],
                "966": [0.19444, 0.44444, 0, 0, 0.74722],
                "967": [0.19444, 0.44444, 0, 0, 0.71805],
                "968": [0.19444, 0.69444, 0.03704, 0, 0.75833],
                "969": [0, 0.44444, 0.03704, 0, 0.71782],
                "977": [0, 0.69444, 0, 0, 0.69155],
                "981": [0.19444, 0.69444, 0, 0, 0.7125],
                "982": [0, 0.44444, 0.03194, 0, 0.975],
                "1009": [0.19444, 0.44444, 0, 0, 0.6118],
                "1013": [0, 0.44444, 0, 0, 0.48333],
                "57649": [0, 0.44444, 0, 0, 0.39352],
                "57911": [0.19444, 0.44444, 0, 0, 0.43889]
              },
              "Math-Italic": {
                "32": [0, 0, 0, 0, 0.25],
                "48": [0, 0.43056, 0, 0, 0.5],
                "49": [0, 0.43056, 0, 0, 0.5],
                "50": [0, 0.43056, 0, 0, 0.5],
                "51": [0.19444, 0.43056, 0, 0, 0.5],
                "52": [0.19444, 0.43056, 0, 0, 0.5],
                "53": [0.19444, 0.43056, 0, 0, 0.5],
                "54": [0, 0.64444, 0, 0, 0.5],
                "55": [0.19444, 0.43056, 0, 0, 0.5],
                "56": [0, 0.64444, 0, 0, 0.5],
                "57": [0.19444, 0.43056, 0, 0, 0.5],
                "65": [0, 0.68333, 0, 0.13889, 0.75],
                "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
                "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
                "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
                "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
                "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
                "71": [0, 0.68333, 0, 0.08334, 0.78625],
                "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
                "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
                "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
                "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
                "76": [0, 0.68333, 0, 0.02778, 0.68056],
                "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
                "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
                "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
                "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
                "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
                "82": [0, 0.68333, 773e-5, 0.08334, 0.75929],
                "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
                "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
                "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
                "86": [0, 0.68333, 0.22222, 0, 0.58333],
                "87": [0, 0.68333, 0.13889, 0, 0.94445],
                "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
                "89": [0, 0.68333, 0.22222, 0, 0.58056],
                "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
                "97": [0, 0.43056, 0, 0, 0.52859],
                "98": [0, 0.69444, 0, 0, 0.42917],
                "99": [0, 0.43056, 0, 0.05556, 0.43276],
                "100": [0, 0.69444, 0, 0.16667, 0.52049],
                "101": [0, 0.43056, 0, 0.05556, 0.46563],
                "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
                "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
                "104": [0, 0.69444, 0, 0, 0.57616],
                "105": [0, 0.65952, 0, 0, 0.34451],
                "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
                "107": [0, 0.69444, 0.03148, 0, 0.5206],
                "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
                "109": [0, 0.43056, 0, 0, 0.87801],
                "110": [0, 0.43056, 0, 0, 0.60023],
                "111": [0, 0.43056, 0, 0.05556, 0.48472],
                "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
                "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
                "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
                "115": [0, 0.43056, 0, 0.05556, 0.46875],
                "116": [0, 0.61508, 0, 0.08334, 0.36111],
                "117": [0, 0.43056, 0, 0.02778, 0.57246],
                "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
                "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
                "120": [0, 0.43056, 0, 0.02778, 0.57153],
                "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
                "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
                "160": [0, 0, 0, 0, 0.25],
                "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
                "916": [0, 0.68333, 0, 0.16667, 0.83334],
                "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
                "923": [0, 0.68333, 0, 0.16667, 0.69445],
                "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
                "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
                "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
                "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
                "934": [0, 0.68333, 0, 0.08334, 0.66667],
                "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
                "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
                "945": [0, 0.43056, 37e-4, 0.02778, 0.6397],
                "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
                "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
                "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
                "949": [0, 0.43056, 0, 0.08334, 0.46632],
                "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
                "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
                "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
                "953": [0, 0.43056, 0, 0.05556, 0.35394],
                "954": [0, 0.43056, 0, 0, 0.57616],
                "955": [0, 0.69444, 0, 0, 0.58334],
                "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
                "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
                "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
                "959": [0, 0.43056, 0, 0.05556, 0.48472],
                "960": [0, 0.43056, 0.03588, 0, 0.57003],
                "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
                "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
                "963": [0, 0.43056, 0.03588, 0, 0.57141],
                "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
                "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
                "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
                "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
                "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
                "969": [0, 0.43056, 0.03588, 0, 0.62245],
                "977": [0, 0.69444, 0, 0.08334, 0.59144],
                "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
                "982": [0, 0.43056, 0.02778, 0, 0.82813],
                "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
                "1013": [0, 0.43056, 0, 0.05556, 0.4059],
                "57649": [0, 0.43056, 0, 0.02778, 0.32246],
                "57911": [0.19444, 0.43056, 0, 0.08334, 0.38403]
              },
              "SansSerif-Bold": {
                "32": [0, 0, 0, 0, 0.25],
                "33": [0, 0.69444, 0, 0, 0.36667],
                "34": [0, 0.69444, 0, 0, 0.55834],
                "35": [0.19444, 0.69444, 0, 0, 0.91667],
                "36": [0.05556, 0.75, 0, 0, 0.55],
                "37": [0.05556, 0.75, 0, 0, 1.02912],
                "38": [0, 0.69444, 0, 0, 0.83056],
                "39": [0, 0.69444, 0, 0, 0.30556],
                "40": [0.25, 0.75, 0, 0, 0.42778],
                "41": [0.25, 0.75, 0, 0, 0.42778],
                "42": [0, 0.75, 0, 0, 0.55],
                "43": [0.11667, 0.61667, 0, 0, 0.85556],
                "44": [0.10556, 0.13056, 0, 0, 0.30556],
                "45": [0, 0.45833, 0, 0, 0.36667],
                "46": [0, 0.13056, 0, 0, 0.30556],
                "47": [0.25, 0.75, 0, 0, 0.55],
                "48": [0, 0.69444, 0, 0, 0.55],
                "49": [0, 0.69444, 0, 0, 0.55],
                "50": [0, 0.69444, 0, 0, 0.55],
                "51": [0, 0.69444, 0, 0, 0.55],
                "52": [0, 0.69444, 0, 0, 0.55],
                "53": [0, 0.69444, 0, 0, 0.55],
                "54": [0, 0.69444, 0, 0, 0.55],
                "55": [0, 0.69444, 0, 0, 0.55],
                "56": [0, 0.69444, 0, 0, 0.55],
                "57": [0, 0.69444, 0, 0, 0.55],
                "58": [0, 0.45833, 0, 0, 0.30556],
                "59": [0.10556, 0.45833, 0, 0, 0.30556],
                "61": [-0.09375, 0.40625, 0, 0, 0.85556],
                "63": [0, 0.69444, 0, 0, 0.51945],
                "64": [0, 0.69444, 0, 0, 0.73334],
                "65": [0, 0.69444, 0, 0, 0.73334],
                "66": [0, 0.69444, 0, 0, 0.73334],
                "67": [0, 0.69444, 0, 0, 0.70278],
                "68": [0, 0.69444, 0, 0, 0.79445],
                "69": [0, 0.69444, 0, 0, 0.64167],
                "70": [0, 0.69444, 0, 0, 0.61111],
                "71": [0, 0.69444, 0, 0, 0.73334],
                "72": [0, 0.69444, 0, 0, 0.79445],
                "73": [0, 0.69444, 0, 0, 0.33056],
                "74": [0, 0.69444, 0, 0, 0.51945],
                "75": [0, 0.69444, 0, 0, 0.76389],
                "76": [0, 0.69444, 0, 0, 0.58056],
                "77": [0, 0.69444, 0, 0, 0.97778],
                "78": [0, 0.69444, 0, 0, 0.79445],
                "79": [0, 0.69444, 0, 0, 0.79445],
                "80": [0, 0.69444, 0, 0, 0.70278],
                "81": [0.10556, 0.69444, 0, 0, 0.79445],
                "82": [0, 0.69444, 0, 0, 0.70278],
                "83": [0, 0.69444, 0, 0, 0.61111],
                "84": [0, 0.69444, 0, 0, 0.73334],
                "85": [0, 0.69444, 0, 0, 0.76389],
                "86": [0, 0.69444, 0.01528, 0, 0.73334],
                "87": [0, 0.69444, 0.01528, 0, 1.03889],
                "88": [0, 0.69444, 0, 0, 0.73334],
                "89": [0, 0.69444, 0.0275, 0, 0.73334],
                "90": [0, 0.69444, 0, 0, 0.67223],
                "91": [0.25, 0.75, 0, 0, 0.34306],
                "93": [0.25, 0.75, 0, 0, 0.34306],
                "94": [0, 0.69444, 0, 0, 0.55],
                "95": [0.35, 0.10833, 0.03056, 0, 0.55],
                "97": [0, 0.45833, 0, 0, 0.525],
                "98": [0, 0.69444, 0, 0, 0.56111],
                "99": [0, 0.45833, 0, 0, 0.48889],
                "100": [0, 0.69444, 0, 0, 0.56111],
                "101": [0, 0.45833, 0, 0, 0.51111],
                "102": [0, 0.69444, 0.07639, 0, 0.33611],
                "103": [0.19444, 0.45833, 0.01528, 0, 0.55],
                "104": [0, 0.69444, 0, 0, 0.56111],
                "105": [0, 0.69444, 0, 0, 0.25556],
                "106": [0.19444, 0.69444, 0, 0, 0.28611],
                "107": [0, 0.69444, 0, 0, 0.53056],
                "108": [0, 0.69444, 0, 0, 0.25556],
                "109": [0, 0.45833, 0, 0, 0.86667],
                "110": [0, 0.45833, 0, 0, 0.56111],
                "111": [0, 0.45833, 0, 0, 0.55],
                "112": [0.19444, 0.45833, 0, 0, 0.56111],
                "113": [0.19444, 0.45833, 0, 0, 0.56111],
                "114": [0, 0.45833, 0.01528, 0, 0.37222],
                "115": [0, 0.45833, 0, 0, 0.42167],
                "116": [0, 0.58929, 0, 0, 0.40417],
                "117": [0, 0.45833, 0, 0, 0.56111],
                "118": [0, 0.45833, 0.01528, 0, 0.5],
                "119": [0, 0.45833, 0.01528, 0, 0.74445],
                "120": [0, 0.45833, 0, 0, 0.5],
                "121": [0.19444, 0.45833, 0.01528, 0, 0.5],
                "122": [0, 0.45833, 0, 0, 0.47639],
                "126": [0.35, 0.34444, 0, 0, 0.55],
                "160": [0, 0, 0, 0, 0.25],
                "168": [0, 0.69444, 0, 0, 0.55],
                "176": [0, 0.69444, 0, 0, 0.73334],
                "180": [0, 0.69444, 0, 0, 0.55],
                "184": [0.17014, 0, 0, 0, 0.48889],
                "305": [0, 0.45833, 0, 0, 0.25556],
                "567": [0.19444, 0.45833, 0, 0, 0.28611],
                "710": [0, 0.69444, 0, 0, 0.55],
                "711": [0, 0.63542, 0, 0, 0.55],
                "713": [0, 0.63778, 0, 0, 0.55],
                "728": [0, 0.69444, 0, 0, 0.55],
                "729": [0, 0.69444, 0, 0, 0.30556],
                "730": [0, 0.69444, 0, 0, 0.73334],
                "732": [0, 0.69444, 0, 0, 0.55],
                "733": [0, 0.69444, 0, 0, 0.55],
                "915": [0, 0.69444, 0, 0, 0.58056],
                "916": [0, 0.69444, 0, 0, 0.91667],
                "920": [0, 0.69444, 0, 0, 0.85556],
                "923": [0, 0.69444, 0, 0, 0.67223],
                "926": [0, 0.69444, 0, 0, 0.73334],
                "928": [0, 0.69444, 0, 0, 0.79445],
                "931": [0, 0.69444, 0, 0, 0.79445],
                "933": [0, 0.69444, 0, 0, 0.85556],
                "934": [0, 0.69444, 0, 0, 0.79445],
                "936": [0, 0.69444, 0, 0, 0.85556],
                "937": [0, 0.69444, 0, 0, 0.79445],
                "8211": [0, 0.45833, 0.03056, 0, 0.55],
                "8212": [0, 0.45833, 0.03056, 0, 1.10001],
                "8216": [0, 0.69444, 0, 0, 0.30556],
                "8217": [0, 0.69444, 0, 0, 0.30556],
                "8220": [0, 0.69444, 0, 0, 0.55834],
                "8221": [0, 0.69444, 0, 0, 0.55834]
              },
              "SansSerif-Italic": {
                "32": [0, 0, 0, 0, 0.25],
                "33": [0, 0.69444, 0.05733, 0, 0.31945],
                "34": [0, 0.69444, 316e-5, 0, 0.5],
                "35": [0.19444, 0.69444, 0.05087, 0, 0.83334],
                "36": [0.05556, 0.75, 0.11156, 0, 0.5],
                "37": [0.05556, 0.75, 0.03126, 0, 0.83334],
                "38": [0, 0.69444, 0.03058, 0, 0.75834],
                "39": [0, 0.69444, 0.07816, 0, 0.27778],
                "40": [0.25, 0.75, 0.13164, 0, 0.38889],
                "41": [0.25, 0.75, 0.02536, 0, 0.38889],
                "42": [0, 0.75, 0.11775, 0, 0.5],
                "43": [0.08333, 0.58333, 0.02536, 0, 0.77778],
                "44": [0.125, 0.08333, 0, 0, 0.27778],
                "45": [0, 0.44444, 0.01946, 0, 0.33333],
                "46": [0, 0.08333, 0, 0, 0.27778],
                "47": [0.25, 0.75, 0.13164, 0, 0.5],
                "48": [0, 0.65556, 0.11156, 0, 0.5],
                "49": [0, 0.65556, 0.11156, 0, 0.5],
                "50": [0, 0.65556, 0.11156, 0, 0.5],
                "51": [0, 0.65556, 0.11156, 0, 0.5],
                "52": [0, 0.65556, 0.11156, 0, 0.5],
                "53": [0, 0.65556, 0.11156, 0, 0.5],
                "54": [0, 0.65556, 0.11156, 0, 0.5],
                "55": [0, 0.65556, 0.11156, 0, 0.5],
                "56": [0, 0.65556, 0.11156, 0, 0.5],
                "57": [0, 0.65556, 0.11156, 0, 0.5],
                "58": [0, 0.44444, 0.02502, 0, 0.27778],
                "59": [0.125, 0.44444, 0.02502, 0, 0.27778],
                "61": [-0.13, 0.37, 0.05087, 0, 0.77778],
                "63": [0, 0.69444, 0.11809, 0, 0.47222],
                "64": [0, 0.69444, 0.07555, 0, 0.66667],
                "65": [0, 0.69444, 0, 0, 0.66667],
                "66": [0, 0.69444, 0.08293, 0, 0.66667],
                "67": [0, 0.69444, 0.11983, 0, 0.63889],
                "68": [0, 0.69444, 0.07555, 0, 0.72223],
                "69": [0, 0.69444, 0.11983, 0, 0.59722],
                "70": [0, 0.69444, 0.13372, 0, 0.56945],
                "71": [0, 0.69444, 0.11983, 0, 0.66667],
                "72": [0, 0.69444, 0.08094, 0, 0.70834],
                "73": [0, 0.69444, 0.13372, 0, 0.27778],
                "74": [0, 0.69444, 0.08094, 0, 0.47222],
                "75": [0, 0.69444, 0.11983, 0, 0.69445],
                "76": [0, 0.69444, 0, 0, 0.54167],
                "77": [0, 0.69444, 0.08094, 0, 0.875],
                "78": [0, 0.69444, 0.08094, 0, 0.70834],
                "79": [0, 0.69444, 0.07555, 0, 0.73611],
                "80": [0, 0.69444, 0.08293, 0, 0.63889],
                "81": [0.125, 0.69444, 0.07555, 0, 0.73611],
                "82": [0, 0.69444, 0.08293, 0, 0.64584],
                "83": [0, 0.69444, 0.09205, 0, 0.55556],
                "84": [0, 0.69444, 0.13372, 0, 0.68056],
                "85": [0, 0.69444, 0.08094, 0, 0.6875],
                "86": [0, 0.69444, 0.1615, 0, 0.66667],
                "87": [0, 0.69444, 0.1615, 0, 0.94445],
                "88": [0, 0.69444, 0.13372, 0, 0.66667],
                "89": [0, 0.69444, 0.17261, 0, 0.66667],
                "90": [0, 0.69444, 0.11983, 0, 0.61111],
                "91": [0.25, 0.75, 0.15942, 0, 0.28889],
                "93": [0.25, 0.75, 0.08719, 0, 0.28889],
                "94": [0, 0.69444, 0.0799, 0, 0.5],
                "95": [0.35, 0.09444, 0.08616, 0, 0.5],
                "97": [0, 0.44444, 981e-5, 0, 0.48056],
                "98": [0, 0.69444, 0.03057, 0, 0.51667],
                "99": [0, 0.44444, 0.08336, 0, 0.44445],
                "100": [0, 0.69444, 0.09483, 0, 0.51667],
                "101": [0, 0.44444, 0.06778, 0, 0.44445],
                "102": [0, 0.69444, 0.21705, 0, 0.30556],
                "103": [0.19444, 0.44444, 0.10836, 0, 0.5],
                "104": [0, 0.69444, 0.01778, 0, 0.51667],
                "105": [0, 0.67937, 0.09718, 0, 0.23889],
                "106": [0.19444, 0.67937, 0.09162, 0, 0.26667],
                "107": [0, 0.69444, 0.08336, 0, 0.48889],
                "108": [0, 0.69444, 0.09483, 0, 0.23889],
                "109": [0, 0.44444, 0.01778, 0, 0.79445],
                "110": [0, 0.44444, 0.01778, 0, 0.51667],
                "111": [0, 0.44444, 0.06613, 0, 0.5],
                "112": [0.19444, 0.44444, 0.0389, 0, 0.51667],
                "113": [0.19444, 0.44444, 0.04169, 0, 0.51667],
                "114": [0, 0.44444, 0.10836, 0, 0.34167],
                "115": [0, 0.44444, 0.0778, 0, 0.38333],
                "116": [0, 0.57143, 0.07225, 0, 0.36111],
                "117": [0, 0.44444, 0.04169, 0, 0.51667],
                "118": [0, 0.44444, 0.10836, 0, 0.46111],
                "119": [0, 0.44444, 0.10836, 0, 0.68334],
                "120": [0, 0.44444, 0.09169, 0, 0.46111],
                "121": [0.19444, 0.44444, 0.10836, 0, 0.46111],
                "122": [0, 0.44444, 0.08752, 0, 0.43472],
                "126": [0.35, 0.32659, 0.08826, 0, 0.5],
                "160": [0, 0, 0, 0, 0.25],
                "168": [0, 0.67937, 0.06385, 0, 0.5],
                "176": [0, 0.69444, 0, 0, 0.73752],
                "184": [0.17014, 0, 0, 0, 0.44445],
                "305": [0, 0.44444, 0.04169, 0, 0.23889],
                "567": [0.19444, 0.44444, 0.04169, 0, 0.26667],
                "710": [0, 0.69444, 0.0799, 0, 0.5],
                "711": [0, 0.63194, 0.08432, 0, 0.5],
                "713": [0, 0.60889, 0.08776, 0, 0.5],
                "714": [0, 0.69444, 0.09205, 0, 0.5],
                "715": [0, 0.69444, 0, 0, 0.5],
                "728": [0, 0.69444, 0.09483, 0, 0.5],
                "729": [0, 0.67937, 0.07774, 0, 0.27778],
                "730": [0, 0.69444, 0, 0, 0.73752],
                "732": [0, 0.67659, 0.08826, 0, 0.5],
                "733": [0, 0.69444, 0.09205, 0, 0.5],
                "915": [0, 0.69444, 0.13372, 0, 0.54167],
                "916": [0, 0.69444, 0, 0, 0.83334],
                "920": [0, 0.69444, 0.07555, 0, 0.77778],
                "923": [0, 0.69444, 0, 0, 0.61111],
                "926": [0, 0.69444, 0.12816, 0, 0.66667],
                "928": [0, 0.69444, 0.08094, 0, 0.70834],
                "931": [0, 0.69444, 0.11983, 0, 0.72222],
                "933": [0, 0.69444, 0.09031, 0, 0.77778],
                "934": [0, 0.69444, 0.04603, 0, 0.72222],
                "936": [0, 0.69444, 0.09031, 0, 0.77778],
                "937": [0, 0.69444, 0.08293, 0, 0.72222],
                "8211": [0, 0.44444, 0.08616, 0, 0.5],
                "8212": [0, 0.44444, 0.08616, 0, 1],
                "8216": [0, 0.69444, 0.07816, 0, 0.27778],
                "8217": [0, 0.69444, 0.07816, 0, 0.27778],
                "8220": [0, 0.69444, 0.14205, 0, 0.5],
                "8221": [0, 0.69444, 316e-5, 0, 0.5]
              },
              "SansSerif-Regular": {
                "32": [0, 0, 0, 0, 0.25],
                "33": [0, 0.69444, 0, 0, 0.31945],
                "34": [0, 0.69444, 0, 0, 0.5],
                "35": [0.19444, 0.69444, 0, 0, 0.83334],
                "36": [0.05556, 0.75, 0, 0, 0.5],
                "37": [0.05556, 0.75, 0, 0, 0.83334],
                "38": [0, 0.69444, 0, 0, 0.75834],
                "39": [0, 0.69444, 0, 0, 0.27778],
                "40": [0.25, 0.75, 0, 0, 0.38889],
                "41": [0.25, 0.75, 0, 0, 0.38889],
                "42": [0, 0.75, 0, 0, 0.5],
                "43": [0.08333, 0.58333, 0, 0, 0.77778],
                "44": [0.125, 0.08333, 0, 0, 0.27778],
                "45": [0, 0.44444, 0, 0, 0.33333],
                "46": [0, 0.08333, 0, 0, 0.27778],
                "47": [0.25, 0.75, 0, 0, 0.5],
                "48": [0, 0.65556, 0, 0, 0.5],
                "49": [0, 0.65556, 0, 0, 0.5],
                "50": [0, 0.65556, 0, 0, 0.5],
                "51": [0, 0.65556, 0, 0, 0.5],
                "52": [0, 0.65556, 0, 0, 0.5],
                "53": [0, 0.65556, 0, 0, 0.5],
                "54": [0, 0.65556, 0, 0, 0.5],
                "55": [0, 0.65556, 0, 0, 0.5],
                "56": [0, 0.65556, 0, 0, 0.5],
                "57": [0, 0.65556, 0, 0, 0.5],
                "58": [0, 0.44444, 0, 0, 0.27778],
                "59": [0.125, 0.44444, 0, 0, 0.27778],
                "61": [-0.13, 0.37, 0, 0, 0.77778],
                "63": [0, 0.69444, 0, 0, 0.47222],
                "64": [0, 0.69444, 0, 0, 0.66667],
                "65": [0, 0.69444, 0, 0, 0.66667],
                "66": [0, 0.69444, 0, 0, 0.66667],
                "67": [0, 0.69444, 0, 0, 0.63889],
                "68": [0, 0.69444, 0, 0, 0.72223],
                "69": [0, 0.69444, 0, 0, 0.59722],
                "70": [0, 0.69444, 0, 0, 0.56945],
                "71": [0, 0.69444, 0, 0, 0.66667],
                "72": [0, 0.69444, 0, 0, 0.70834],
                "73": [0, 0.69444, 0, 0, 0.27778],
                "74": [0, 0.69444, 0, 0, 0.47222],
                "75": [0, 0.69444, 0, 0, 0.69445],
                "76": [0, 0.69444, 0, 0, 0.54167],
                "77": [0, 0.69444, 0, 0, 0.875],
                "78": [0, 0.69444, 0, 0, 0.70834],
                "79": [0, 0.69444, 0, 0, 0.73611],
                "80": [0, 0.69444, 0, 0, 0.63889],
                "81": [0.125, 0.69444, 0, 0, 0.73611],
                "82": [0, 0.69444, 0, 0, 0.64584],
                "83": [0, 0.69444, 0, 0, 0.55556],
                "84": [0, 0.69444, 0, 0, 0.68056],
                "85": [0, 0.69444, 0, 0, 0.6875],
                "86": [0, 0.69444, 0.01389, 0, 0.66667],
                "87": [0, 0.69444, 0.01389, 0, 0.94445],
                "88": [0, 0.69444, 0, 0, 0.66667],
                "89": [0, 0.69444, 0.025, 0, 0.66667],
                "90": [0, 0.69444, 0, 0, 0.61111],
                "91": [0.25, 0.75, 0, 0, 0.28889],
                "93": [0.25, 0.75, 0, 0, 0.28889],
                "94": [0, 0.69444, 0, 0, 0.5],
                "95": [0.35, 0.09444, 0.02778, 0, 0.5],
                "97": [0, 0.44444, 0, 0, 0.48056],
                "98": [0, 0.69444, 0, 0, 0.51667],
                "99": [0, 0.44444, 0, 0, 0.44445],
                "100": [0, 0.69444, 0, 0, 0.51667],
                "101": [0, 0.44444, 0, 0, 0.44445],
                "102": [0, 0.69444, 0.06944, 0, 0.30556],
                "103": [0.19444, 0.44444, 0.01389, 0, 0.5],
                "104": [0, 0.69444, 0, 0, 0.51667],
                "105": [0, 0.67937, 0, 0, 0.23889],
                "106": [0.19444, 0.67937, 0, 0, 0.26667],
                "107": [0, 0.69444, 0, 0, 0.48889],
                "108": [0, 0.69444, 0, 0, 0.23889],
                "109": [0, 0.44444, 0, 0, 0.79445],
                "110": [0, 0.44444, 0, 0, 0.51667],
                "111": [0, 0.44444, 0, 0, 0.5],
                "112": [0.19444, 0.44444, 0, 0, 0.51667],
                "113": [0.19444, 0.44444, 0, 0, 0.51667],
                "114": [0, 0.44444, 0.01389, 0, 0.34167],
                "115": [0, 0.44444, 0, 0, 0.38333],
                "116": [0, 0.57143, 0, 0, 0.36111],
                "117": [0, 0.44444, 0, 0, 0.51667],
                "118": [0, 0.44444, 0.01389, 0, 0.46111],
                "119": [0, 0.44444, 0.01389, 0, 0.68334],
                "120": [0, 0.44444, 0, 0, 0.46111],
                "121": [0.19444, 0.44444, 0.01389, 0, 0.46111],
                "122": [0, 0.44444, 0, 0, 0.43472],
                "126": [0.35, 0.32659, 0, 0, 0.5],
                "160": [0, 0, 0, 0, 0.25],
                "168": [0, 0.67937, 0, 0, 0.5],
                "176": [0, 0.69444, 0, 0, 0.66667],
                "184": [0.17014, 0, 0, 0, 0.44445],
                "305": [0, 0.44444, 0, 0, 0.23889],
                "567": [0.19444, 0.44444, 0, 0, 0.26667],
                "710": [0, 0.69444, 0, 0, 0.5],
                "711": [0, 0.63194, 0, 0, 0.5],
                "713": [0, 0.60889, 0, 0, 0.5],
                "714": [0, 0.69444, 0, 0, 0.5],
                "715": [0, 0.69444, 0, 0, 0.5],
                "728": [0, 0.69444, 0, 0, 0.5],
                "729": [0, 0.67937, 0, 0, 0.27778],
                "730": [0, 0.69444, 0, 0, 0.66667],
                "732": [0, 0.67659, 0, 0, 0.5],
                "733": [0, 0.69444, 0, 0, 0.5],
                "915": [0, 0.69444, 0, 0, 0.54167],
                "916": [0, 0.69444, 0, 0, 0.83334],
                "920": [0, 0.69444, 0, 0, 0.77778],
                "923": [0, 0.69444, 0, 0, 0.61111],
                "926": [0, 0.69444, 0, 0, 0.66667],
                "928": [0, 0.69444, 0, 0, 0.70834],
                "931": [0, 0.69444, 0, 0, 0.72222],
                "933": [0, 0.69444, 0, 0, 0.77778],
                "934": [0, 0.69444, 0, 0, 0.72222],
                "936": [0, 0.69444, 0, 0, 0.77778],
                "937": [0, 0.69444, 0, 0, 0.72222],
                "8211": [0, 0.44444, 0.02778, 0, 0.5],
                "8212": [0, 0.44444, 0.02778, 0, 1],
                "8216": [0, 0.69444, 0, 0, 0.27778],
                "8217": [0, 0.69444, 0, 0, 0.27778],
                "8220": [0, 0.69444, 0, 0, 0.5],
                "8221": [0, 0.69444, 0, 0, 0.5]
              },
              "Script-Regular": {
                "32": [0, 0, 0, 0, 0.25],
                "65": [0, 0.7, 0.22925, 0, 0.80253],
                "66": [0, 0.7, 0.04087, 0, 0.90757],
                "67": [0, 0.7, 0.1689, 0, 0.66619],
                "68": [0, 0.7, 0.09371, 0, 0.77443],
                "69": [0, 0.7, 0.18583, 0, 0.56162],
                "70": [0, 0.7, 0.13634, 0, 0.89544],
                "71": [0, 0.7, 0.17322, 0, 0.60961],
                "72": [0, 0.7, 0.29694, 0, 0.96919],
                "73": [0, 0.7, 0.19189, 0, 0.80907],
                "74": [0.27778, 0.7, 0.19189, 0, 1.05159],
                "75": [0, 0.7, 0.31259, 0, 0.91364],
                "76": [0, 0.7, 0.19189, 0, 0.87373],
                "77": [0, 0.7, 0.15981, 0, 1.08031],
                "78": [0, 0.7, 0.3525, 0, 0.9015],
                "79": [0, 0.7, 0.08078, 0, 0.73787],
                "80": [0, 0.7, 0.08078, 0, 1.01262],
                "81": [0, 0.7, 0.03305, 0, 0.88282],
                "82": [0, 0.7, 0.06259, 0, 0.85],
                "83": [0, 0.7, 0.19189, 0, 0.86767],
                "84": [0, 0.7, 0.29087, 0, 0.74697],
                "85": [0, 0.7, 0.25815, 0, 0.79996],
                "86": [0, 0.7, 0.27523, 0, 0.62204],
                "87": [0, 0.7, 0.27523, 0, 0.80532],
                "88": [0, 0.7, 0.26006, 0, 0.94445],
                "89": [0, 0.7, 0.2939, 0, 0.70961],
                "90": [0, 0.7, 0.24037, 0, 0.8212],
                "160": [0, 0, 0, 0, 0.25]
              },
              "Size1-Regular": {
                "32": [0, 0, 0, 0, 0.25],
                "40": [0.35001, 0.85, 0, 0, 0.45834],
                "41": [0.35001, 0.85, 0, 0, 0.45834],
                "47": [0.35001, 0.85, 0, 0, 0.57778],
                "91": [0.35001, 0.85, 0, 0, 0.41667],
                "92": [0.35001, 0.85, 0, 0, 0.57778],
                "93": [0.35001, 0.85, 0, 0, 0.41667],
                "123": [0.35001, 0.85, 0, 0, 0.58334],
                "125": [0.35001, 0.85, 0, 0, 0.58334],
                "160": [0, 0, 0, 0, 0.25],
                "710": [0, 0.72222, 0, 0, 0.55556],
                "732": [0, 0.72222, 0, 0, 0.55556],
                "770": [0, 0.72222, 0, 0, 0.55556],
                "771": [0, 0.72222, 0, 0, 0.55556],
                "8214": [-99e-5, 0.601, 0, 0, 0.77778],
                "8593": [1e-5, 0.6, 0, 0, 0.66667],
                "8595": [1e-5, 0.6, 0, 0, 0.66667],
                "8657": [1e-5, 0.6, 0, 0, 0.77778],
                "8659": [1e-5, 0.6, 0, 0, 0.77778],
                "8719": [0.25001, 0.75, 0, 0, 0.94445],
                "8720": [0.25001, 0.75, 0, 0, 0.94445],
                "8721": [0.25001, 0.75, 0, 0, 1.05556],
                "8730": [0.35001, 0.85, 0, 0, 1],
                "8739": [-599e-5, 0.606, 0, 0, 0.33333],
                "8741": [-599e-5, 0.606, 0, 0, 0.55556],
                "8747": [0.30612, 0.805, 0.19445, 0, 0.47222],
                "8748": [0.306, 0.805, 0.19445, 0, 0.47222],
                "8749": [0.306, 0.805, 0.19445, 0, 0.47222],
                "8750": [0.30612, 0.805, 0.19445, 0, 0.47222],
                "8896": [0.25001, 0.75, 0, 0, 0.83334],
                "8897": [0.25001, 0.75, 0, 0, 0.83334],
                "8898": [0.25001, 0.75, 0, 0, 0.83334],
                "8899": [0.25001, 0.75, 0, 0, 0.83334],
                "8968": [0.35001, 0.85, 0, 0, 0.47222],
                "8969": [0.35001, 0.85, 0, 0, 0.47222],
                "8970": [0.35001, 0.85, 0, 0, 0.47222],
                "8971": [0.35001, 0.85, 0, 0, 0.47222],
                "9168": [-99e-5, 0.601, 0, 0, 0.66667],
                "10216": [0.35001, 0.85, 0, 0, 0.47222],
                "10217": [0.35001, 0.85, 0, 0, 0.47222],
                "10752": [0.25001, 0.75, 0, 0, 1.11111],
                "10753": [0.25001, 0.75, 0, 0, 1.11111],
                "10754": [0.25001, 0.75, 0, 0, 1.11111],
                "10756": [0.25001, 0.75, 0, 0, 0.83334],
                "10758": [0.25001, 0.75, 0, 0, 0.83334]
              },
              "Size2-Regular": {
                "32": [0, 0, 0, 0, 0.25],
                "40": [0.65002, 1.15, 0, 0, 0.59722],
                "41": [0.65002, 1.15, 0, 0, 0.59722],
                "47": [0.65002, 1.15, 0, 0, 0.81111],
                "91": [0.65002, 1.15, 0, 0, 0.47222],
                "92": [0.65002, 1.15, 0, 0, 0.81111],
                "93": [0.65002, 1.15, 0, 0, 0.47222],
                "123": [0.65002, 1.15, 0, 0, 0.66667],
                "125": [0.65002, 1.15, 0, 0, 0.66667],
                "160": [0, 0, 0, 0, 0.25],
                "710": [0, 0.75, 0, 0, 1],
                "732": [0, 0.75, 0, 0, 1],
                "770": [0, 0.75, 0, 0, 1],
                "771": [0, 0.75, 0, 0, 1],
                "8719": [0.55001, 1.05, 0, 0, 1.27778],
                "8720": [0.55001, 1.05, 0, 0, 1.27778],
                "8721": [0.55001, 1.05, 0, 0, 1.44445],
                "8730": [0.65002, 1.15, 0, 0, 1],
                "8747": [0.86225, 1.36, 0.44445, 0, 0.55556],
                "8748": [0.862, 1.36, 0.44445, 0, 0.55556],
                "8749": [0.862, 1.36, 0.44445, 0, 0.55556],
                "8750": [0.86225, 1.36, 0.44445, 0, 0.55556],
                "8896": [0.55001, 1.05, 0, 0, 1.11111],
                "8897": [0.55001, 1.05, 0, 0, 1.11111],
                "8898": [0.55001, 1.05, 0, 0, 1.11111],
                "8899": [0.55001, 1.05, 0, 0, 1.11111],
                "8968": [0.65002, 1.15, 0, 0, 0.52778],
                "8969": [0.65002, 1.15, 0, 0, 0.52778],
                "8970": [0.65002, 1.15, 0, 0, 0.52778],
                "8971": [0.65002, 1.15, 0, 0, 0.52778],
                "10216": [0.65002, 1.15, 0, 0, 0.61111],
                "10217": [0.65002, 1.15, 0, 0, 0.61111],
                "10752": [0.55001, 1.05, 0, 0, 1.51112],
                "10753": [0.55001, 1.05, 0, 0, 1.51112],
                "10754": [0.55001, 1.05, 0, 0, 1.51112],
                "10756": [0.55001, 1.05, 0, 0, 1.11111],
                "10758": [0.55001, 1.05, 0, 0, 1.11111]
              },
              "Size3-Regular": {
                "32": [0, 0, 0, 0, 0.25],
                "40": [0.95003, 1.45, 0, 0, 0.73611],
                "41": [0.95003, 1.45, 0, 0, 0.73611],
                "47": [0.95003, 1.45, 0, 0, 1.04445],
                "91": [0.95003, 1.45, 0, 0, 0.52778],
                "92": [0.95003, 1.45, 0, 0, 1.04445],
                "93": [0.95003, 1.45, 0, 0, 0.52778],
                "123": [0.95003, 1.45, 0, 0, 0.75],
                "125": [0.95003, 1.45, 0, 0, 0.75],
                "160": [0, 0, 0, 0, 0.25],
                "710": [0, 0.75, 0, 0, 1.44445],
                "732": [0, 0.75, 0, 0, 1.44445],
                "770": [0, 0.75, 0, 0, 1.44445],
                "771": [0, 0.75, 0, 0, 1.44445],
                "8730": [0.95003, 1.45, 0, 0, 1],
                "8968": [0.95003, 1.45, 0, 0, 0.58334],
                "8969": [0.95003, 1.45, 0, 0, 0.58334],
                "8970": [0.95003, 1.45, 0, 0, 0.58334],
                "8971": [0.95003, 1.45, 0, 0, 0.58334],
                "10216": [0.95003, 1.45, 0, 0, 0.75],
                "10217": [0.95003, 1.45, 0, 0, 0.75]
              },
              "Size4-Regular": {
                "32": [0, 0, 0, 0, 0.25],
                "40": [1.25003, 1.75, 0, 0, 0.79167],
                "41": [1.25003, 1.75, 0, 0, 0.79167],
                "47": [1.25003, 1.75, 0, 0, 1.27778],
                "91": [1.25003, 1.75, 0, 0, 0.58334],
                "92": [1.25003, 1.75, 0, 0, 1.27778],
                "93": [1.25003, 1.75, 0, 0, 0.58334],
                "123": [1.25003, 1.75, 0, 0, 0.80556],
                "125": [1.25003, 1.75, 0, 0, 0.80556],
                "160": [0, 0, 0, 0, 0.25],
                "710": [0, 0.825, 0, 0, 1.8889],
                "732": [0, 0.825, 0, 0, 1.8889],
                "770": [0, 0.825, 0, 0, 1.8889],
                "771": [0, 0.825, 0, 0, 1.8889],
                "8730": [1.25003, 1.75, 0, 0, 1],
                "8968": [1.25003, 1.75, 0, 0, 0.63889],
                "8969": [1.25003, 1.75, 0, 0, 0.63889],
                "8970": [1.25003, 1.75, 0, 0, 0.63889],
                "8971": [1.25003, 1.75, 0, 0, 0.63889],
                "9115": [0.64502, 1.155, 0, 0, 0.875],
                "9116": [1e-5, 0.6, 0, 0, 0.875],
                "9117": [0.64502, 1.155, 0, 0, 0.875],
                "9118": [0.64502, 1.155, 0, 0, 0.875],
                "9119": [1e-5, 0.6, 0, 0, 0.875],
                "9120": [0.64502, 1.155, 0, 0, 0.875],
                "9121": [0.64502, 1.155, 0, 0, 0.66667],
                "9122": [-99e-5, 0.601, 0, 0, 0.66667],
                "9123": [0.64502, 1.155, 0, 0, 0.66667],
                "9124": [0.64502, 1.155, 0, 0, 0.66667],
                "9125": [-99e-5, 0.601, 0, 0, 0.66667],
                "9126": [0.64502, 1.155, 0, 0, 0.66667],
                "9127": [1e-5, 0.9, 0, 0, 0.88889],
                "9128": [0.65002, 1.15, 0, 0, 0.88889],
                "9129": [0.90001, 0, 0, 0, 0.88889],
                "9130": [0, 0.3, 0, 0, 0.88889],
                "9131": [1e-5, 0.9, 0, 0, 0.88889],
                "9132": [0.65002, 1.15, 0, 0, 0.88889],
                "9133": [0.90001, 0, 0, 0, 0.88889],
                "9143": [0.88502, 0.915, 0, 0, 1.05556],
                "10216": [1.25003, 1.75, 0, 0, 0.80556],
                "10217": [1.25003, 1.75, 0, 0, 0.80556],
                "57344": [-499e-5, 0.605, 0, 0, 1.05556],
                "57345": [-499e-5, 0.605, 0, 0, 1.05556],
                "57680": [0, 0.12, 0, 0, 0.45],
                "57681": [0, 0.12, 0, 0, 0.45],
                "57682": [0, 0.12, 0, 0, 0.45],
                "57683": [0, 0.12, 0, 0, 0.45]
              },
              "Typewriter-Regular": {
                "32": [0, 0, 0, 0, 0.525],
                "33": [0, 0.61111, 0, 0, 0.525],
                "34": [0, 0.61111, 0, 0, 0.525],
                "35": [0, 0.61111, 0, 0, 0.525],
                "36": [0.08333, 0.69444, 0, 0, 0.525],
                "37": [0.08333, 0.69444, 0, 0, 0.525],
                "38": [0, 0.61111, 0, 0, 0.525],
                "39": [0, 0.61111, 0, 0, 0.525],
                "40": [0.08333, 0.69444, 0, 0, 0.525],
                "41": [0.08333, 0.69444, 0, 0, 0.525],
                "42": [0, 0.52083, 0, 0, 0.525],
                "43": [-0.08056, 0.53055, 0, 0, 0.525],
                "44": [0.13889, 0.125, 0, 0, 0.525],
                "45": [-0.08056, 0.53055, 0, 0, 0.525],
                "46": [0, 0.125, 0, 0, 0.525],
                "47": [0.08333, 0.69444, 0, 0, 0.525],
                "48": [0, 0.61111, 0, 0, 0.525],
                "49": [0, 0.61111, 0, 0, 0.525],
                "50": [0, 0.61111, 0, 0, 0.525],
                "51": [0, 0.61111, 0, 0, 0.525],
                "52": [0, 0.61111, 0, 0, 0.525],
                "53": [0, 0.61111, 0, 0, 0.525],
                "54": [0, 0.61111, 0, 0, 0.525],
                "55": [0, 0.61111, 0, 0, 0.525],
                "56": [0, 0.61111, 0, 0, 0.525],
                "57": [0, 0.61111, 0, 0, 0.525],
                "58": [0, 0.43056, 0, 0, 0.525],
                "59": [0.13889, 0.43056, 0, 0, 0.525],
                "60": [-0.05556, 0.55556, 0, 0, 0.525],
                "61": [-0.19549, 0.41562, 0, 0, 0.525],
                "62": [-0.05556, 0.55556, 0, 0, 0.525],
                "63": [0, 0.61111, 0, 0, 0.525],
                "64": [0, 0.61111, 0, 0, 0.525],
                "65": [0, 0.61111, 0, 0, 0.525],
                "66": [0, 0.61111, 0, 0, 0.525],
                "67": [0, 0.61111, 0, 0, 0.525],
                "68": [0, 0.61111, 0, 0, 0.525],
                "69": [0, 0.61111, 0, 0, 0.525],
                "70": [0, 0.61111, 0, 0, 0.525],
                "71": [0, 0.61111, 0, 0, 0.525],
                "72": [0, 0.61111, 0, 0, 0.525],
                "73": [0, 0.61111, 0, 0, 0.525],
                "74": [0, 0.61111, 0, 0, 0.525],
                "75": [0, 0.61111, 0, 0, 0.525],
                "76": [0, 0.61111, 0, 0, 0.525],
                "77": [0, 0.61111, 0, 0, 0.525],
                "78": [0, 0.61111, 0, 0, 0.525],
                "79": [0, 0.61111, 0, 0, 0.525],
                "80": [0, 0.61111, 0, 0, 0.525],
                "81": [0.13889, 0.61111, 0, 0, 0.525],
                "82": [0, 0.61111, 0, 0, 0.525],
                "83": [0, 0.61111, 0, 0, 0.525],
                "84": [0, 0.61111, 0, 0, 0.525],
                "85": [0, 0.61111, 0, 0, 0.525],
                "86": [0, 0.61111, 0, 0, 0.525],
                "87": [0, 0.61111, 0, 0, 0.525],
                "88": [0, 0.61111, 0, 0, 0.525],
                "89": [0, 0.61111, 0, 0, 0.525],
                "90": [0, 0.61111, 0, 0, 0.525],
                "91": [0.08333, 0.69444, 0, 0, 0.525],
                "92": [0.08333, 0.69444, 0, 0, 0.525],
                "93": [0.08333, 0.69444, 0, 0, 0.525],
                "94": [0, 0.61111, 0, 0, 0.525],
                "95": [0.09514, 0, 0, 0, 0.525],
                "96": [0, 0.61111, 0, 0, 0.525],
                "97": [0, 0.43056, 0, 0, 0.525],
                "98": [0, 0.61111, 0, 0, 0.525],
                "99": [0, 0.43056, 0, 0, 0.525],
                "100": [0, 0.61111, 0, 0, 0.525],
                "101": [0, 0.43056, 0, 0, 0.525],
                "102": [0, 0.61111, 0, 0, 0.525],
                "103": [0.22222, 0.43056, 0, 0, 0.525],
                "104": [0, 0.61111, 0, 0, 0.525],
                "105": [0, 0.61111, 0, 0, 0.525],
                "106": [0.22222, 0.61111, 0, 0, 0.525],
                "107": [0, 0.61111, 0, 0, 0.525],
                "108": [0, 0.61111, 0, 0, 0.525],
                "109": [0, 0.43056, 0, 0, 0.525],
                "110": [0, 0.43056, 0, 0, 0.525],
                "111": [0, 0.43056, 0, 0, 0.525],
                "112": [0.22222, 0.43056, 0, 0, 0.525],
                "113": [0.22222, 0.43056, 0, 0, 0.525],
                "114": [0, 0.43056, 0, 0, 0.525],
                "115": [0, 0.43056, 0, 0, 0.525],
                "116": [0, 0.55358, 0, 0, 0.525],
                "117": [0, 0.43056, 0, 0, 0.525],
                "118": [0, 0.43056, 0, 0, 0.525],
                "119": [0, 0.43056, 0, 0, 0.525],
                "120": [0, 0.43056, 0, 0, 0.525],
                "121": [0.22222, 0.43056, 0, 0, 0.525],
                "122": [0, 0.43056, 0, 0, 0.525],
                "123": [0.08333, 0.69444, 0, 0, 0.525],
                "124": [0.08333, 0.69444, 0, 0, 0.525],
                "125": [0.08333, 0.69444, 0, 0, 0.525],
                "126": [0, 0.61111, 0, 0, 0.525],
                "127": [0, 0.61111, 0, 0, 0.525],
                "160": [0, 0, 0, 0, 0.525],
                "176": [0, 0.61111, 0, 0, 0.525],
                "184": [0.19445, 0, 0, 0, 0.525],
                "305": [0, 0.43056, 0, 0, 0.525],
                "567": [0.22222, 0.43056, 0, 0, 0.525],
                "711": [0, 0.56597, 0, 0, 0.525],
                "713": [0, 0.56555, 0, 0, 0.525],
                "714": [0, 0.61111, 0, 0, 0.525],
                "715": [0, 0.61111, 0, 0, 0.525],
                "728": [0, 0.61111, 0, 0, 0.525],
                "730": [0, 0.61111, 0, 0, 0.525],
                "770": [0, 0.61111, 0, 0, 0.525],
                "771": [0, 0.61111, 0, 0, 0.525],
                "776": [0, 0.61111, 0, 0, 0.525],
                "915": [0, 0.61111, 0, 0, 0.525],
                "916": [0, 0.61111, 0, 0, 0.525],
                "920": [0, 0.61111, 0, 0, 0.525],
                "923": [0, 0.61111, 0, 0, 0.525],
                "926": [0, 0.61111, 0, 0, 0.525],
                "928": [0, 0.61111, 0, 0, 0.525],
                "931": [0, 0.61111, 0, 0, 0.525],
                "933": [0, 0.61111, 0, 0, 0.525],
                "934": [0, 0.61111, 0, 0, 0.525],
                "936": [0, 0.61111, 0, 0, 0.525],
                "937": [0, 0.61111, 0, 0, 0.525],
                "8216": [0, 0.61111, 0, 0, 0.525],
                "8217": [0, 0.61111, 0, 0, 0.525],
                "8242": [0, 0.61111, 0, 0, 0.525],
                "9251": [0.11111, 0.21944, 0, 0, 0.525]
              }
            };
            ;
            const sigmasAndXis = {
              slant: [0.25, 0.25, 0.25],
              // sigma1
              space: [0, 0, 0],
              // sigma2
              stretch: [0, 0, 0],
              // sigma3
              shrink: [0, 0, 0],
              // sigma4
              xHeight: [0.431, 0.431, 0.431],
              // sigma5
              quad: [1, 1.171, 1.472],
              // sigma6
              extraSpace: [0, 0, 0],
              // sigma7
              num1: [0.677, 0.732, 0.925],
              // sigma8
              num2: [0.394, 0.384, 0.387],
              // sigma9
              num3: [0.444, 0.471, 0.504],
              // sigma10
              denom1: [0.686, 0.752, 1.025],
              // sigma11
              denom2: [0.345, 0.344, 0.532],
              // sigma12
              sup1: [0.413, 0.503, 0.504],
              // sigma13
              sup2: [0.363, 0.431, 0.404],
              // sigma14
              sup3: [0.289, 0.286, 0.294],
              // sigma15
              sub1: [0.15, 0.143, 0.2],
              // sigma16
              sub2: [0.247, 0.286, 0.4],
              // sigma17
              supDrop: [0.386, 0.353, 0.494],
              // sigma18
              subDrop: [0.05, 0.071, 0.1],
              // sigma19
              delim1: [2.39, 1.7, 1.98],
              // sigma20
              delim2: [1.01, 1.157, 1.42],
              // sigma21
              axisHeight: [0.25, 0.25, 0.25],
              // sigma22
              // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
              // they correspond to the font parameters of the extension fonts (family 3).
              // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
              // match cmex7, we'd use cmex7.tfm values for script and scriptscript
              // values.
              defaultRuleThickness: [0.04, 0.049, 0.049],
              // xi8; cmex7: 0.049
              bigOpSpacing1: [0.111, 0.111, 0.111],
              // xi9
              bigOpSpacing2: [0.166, 0.166, 0.166],
              // xi10
              bigOpSpacing3: [0.2, 0.2, 0.2],
              // xi11
              bigOpSpacing4: [0.6, 0.611, 0.611],
              // xi12; cmex7: 0.611
              bigOpSpacing5: [0.1, 0.143, 0.143],
              // xi13; cmex7: 0.143
              // The \sqrt rule width is taken from the height of the surd character.
              // Since we use the same font at all sizes, this thickness doesn't scale.
              sqrtRuleThickness: [0.04, 0.04, 0.04],
              // This value determines how large a pt is, for metrics which are defined
              // in terms of pts.
              // This value is also used in katex.scss; if you change it make sure the
              // values match.
              ptPerEm: [10, 10, 10],
              // The space between adjacent `|` columns in an array definition. From
              // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
              doubleRuleSep: [0.2, 0.2, 0.2],
              // The width of separator lines in {array} environments. From
              // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
              arrayRuleWidth: [0.04, 0.04, 0.04],
              // Two values from LaTeX source2e:
              fboxsep: [0.3, 0.3, 0.3],
              //        3 pt / ptPerEm
              fboxrule: [0.04, 0.04, 0.04]
              // 0.4 pt / ptPerEm
            };
            const extraCharacterMap = {
              // Latin-1
              "\xC5": "A",
              "\xD0": "D",
              "\xDE": "o",
              "\xE5": "a",
              "\xF0": "d",
              "\xFE": "o",
              // Cyrillic
              "\u0410": "A",
              "\u0411": "B",
              "\u0412": "B",
              "\u0413": "F",
              "\u0414": "A",
              "\u0415": "E",
              "\u0416": "K",
              "\u0417": "3",
              "\u0418": "N",
              "\u0419": "N",
              "\u041A": "K",
              "\u041B": "N",
              "\u041C": "M",
              "\u041D": "H",
              "\u041E": "O",
              "\u041F": "N",
              "\u0420": "P",
              "\u0421": "C",
              "\u0422": "T",
              "\u0423": "y",
              "\u0424": "O",
              "\u0425": "X",
              "\u0426": "U",
              "\u0427": "h",
              "\u0428": "W",
              "\u0429": "W",
              "\u042A": "B",
              "\u042B": "X",
              "\u042C": "B",
              "\u042D": "3",
              "\u042E": "X",
              "\u042F": "R",
              "\u0430": "a",
              "\u0431": "b",
              "\u0432": "a",
              "\u0433": "r",
              "\u0434": "y",
              "\u0435": "e",
              "\u0436": "m",
              "\u0437": "e",
              "\u0438": "n",
              "\u0439": "n",
              "\u043A": "n",
              "\u043B": "n",
              "\u043C": "m",
              "\u043D": "n",
              "\u043E": "o",
              "\u043F": "n",
              "\u0440": "p",
              "\u0441": "c",
              "\u0442": "o",
              "\u0443": "y",
              "\u0444": "b",
              "\u0445": "x",
              "\u0446": "n",
              "\u0447": "n",
              "\u0448": "w",
              "\u0449": "w",
              "\u044A": "a",
              "\u044B": "m",
              "\u044C": "a",
              "\u044D": "e",
              "\u044E": "m",
              "\u044F": "r"
            };
            function setFontMetrics(fontName, metrics) {
              fontMetricsData[fontName] = metrics;
            }
            function getCharacterMetrics(character, font, mode) {
              if (!fontMetricsData[font]) {
                throw new Error("Font metrics not found for font: " + font + ".");
              }
              let ch = character.charCodeAt(0);
              let metrics = fontMetricsData[font][ch];
              if (!metrics && character[0] in extraCharacterMap) {
                ch = extraCharacterMap[character[0]].charCodeAt(0);
                metrics = fontMetricsData[font][ch];
              }
              if (!metrics && mode === "text") {
                if (supportedCodepoint(ch)) {
                  metrics = fontMetricsData[font][77];
                }
              }
              if (metrics) {
                return {
                  depth: metrics[0],
                  height: metrics[1],
                  italic: metrics[2],
                  skew: metrics[3],
                  width: metrics[4]
                };
              }
            }
            const fontMetricsBySizeIndex = {};
            function getGlobalMetrics(size) {
              let sizeIndex;
              if (size >= 5) {
                sizeIndex = 0;
              } else if (size >= 3) {
                sizeIndex = 1;
              } else {
                sizeIndex = 2;
              }
              if (!fontMetricsBySizeIndex[sizeIndex]) {
                const metrics = fontMetricsBySizeIndex[sizeIndex] = {
                  cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18
                };
                for (const key in sigmasAndXis) {
                  if (sigmasAndXis.hasOwnProperty(key)) {
                    metrics[key] = sigmasAndXis[key][sizeIndex];
                  }
                }
              }
              return fontMetricsBySizeIndex[sizeIndex];
            }
            ;
            const sizeStyleMap = [
              // Each element contains [textsize, scriptsize, scriptscriptsize].
              // The size mappings are taken from TeX with \normalsize=10pt.
              [1, 1, 1],
              // size1: [5, 5, 5]              \tiny
              [2, 1, 1],
              // size2: [6, 5, 5]
              [3, 1, 1],
              // size3: [7, 5, 5]              \scriptsize
              [4, 2, 1],
              // size4: [8, 6, 5]              \footnotesize
              [5, 2, 1],
              // size5: [9, 6, 5]              \small
              [6, 3, 1],
              // size6: [10, 7, 5]             \normalsize
              [7, 4, 2],
              // size7: [12, 8, 6]             \large
              [8, 6, 3],
              // size8: [14.4, 10, 7]          \Large
              [9, 7, 6],
              // size9: [17.28, 12, 10]        \LARGE
              [10, 8, 7],
              // size10: [20.74, 14.4, 12]     \huge
              [11, 10, 9]
              // size11: [24.88, 20.74, 17.28] \HUGE
            ];
            const sizeMultipliers = [
              // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
              // you change size indexes, change that function.
              0.5,
              0.6,
              0.7,
              0.8,
              0.9,
              1,
              1.2,
              1.44,
              1.728,
              2.074,
              2.488
            ];
            const sizeAtStyle = function(size, style) {
              return style.size < 2 ? size : sizeStyleMap[size - 1][style.size - 1];
            };
            class Options {
              // A font family applies to a group of fonts (i.e. SansSerif), while a font
              // represents a specific font (i.e. SansSerif Bold).
              // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
              /**
               * The base size index.
               */
              constructor(data2) {
                this.style = void 0;
                this.color = void 0;
                this.size = void 0;
                this.textSize = void 0;
                this.phantom = void 0;
                this.font = void 0;
                this.fontFamily = void 0;
                this.fontWeight = void 0;
                this.fontShape = void 0;
                this.sizeMultiplier = void 0;
                this.maxSize = void 0;
                this.minRuleThickness = void 0;
                this._fontMetrics = void 0;
                this.style = data2.style;
                this.color = data2.color;
                this.size = data2.size || Options.BASESIZE;
                this.textSize = data2.textSize || this.size;
                this.phantom = !!data2.phantom;
                this.font = data2.font || "";
                this.fontFamily = data2.fontFamily || "";
                this.fontWeight = data2.fontWeight || "";
                this.fontShape = data2.fontShape || "";
                this.sizeMultiplier = sizeMultipliers[this.size - 1];
                this.maxSize = data2.maxSize;
                this.minRuleThickness = data2.minRuleThickness;
                this._fontMetrics = void 0;
              }
              /**
               * Returns a new options object with the same properties as "this".  Properties
               * from "extension" will be copied to the new options object.
               */
              extend(extension) {
                const data2 = {
                  style: this.style,
                  size: this.size,
                  textSize: this.textSize,
                  color: this.color,
                  phantom: this.phantom,
                  font: this.font,
                  fontFamily: this.fontFamily,
                  fontWeight: this.fontWeight,
                  fontShape: this.fontShape,
                  maxSize: this.maxSize,
                  minRuleThickness: this.minRuleThickness
                };
                for (const key in extension) {
                  if (extension.hasOwnProperty(key)) {
                    data2[key] = extension[key];
                  }
                }
                return new Options(data2);
              }
              /**
               * Return an options object with the given style. If `this.style === style`,
               * returns `this`.
               */
              havingStyle(style) {
                if (this.style === style) {
                  return this;
                } else {
                  return this.extend({
                    style,
                    size: sizeAtStyle(this.textSize, style)
                  });
                }
              }
              /**
               * Return an options object with a cramped version of the current style. If
               * the current style is cramped, returns `this`.
               */
              havingCrampedStyle() {
                return this.havingStyle(this.style.cramp());
              }
              /**
               * Return an options object with the given size and in at least `\textstyle`.
               * Returns `this` if appropriate.
               */
              havingSize(size) {
                if (this.size === size && this.textSize === size) {
                  return this;
                } else {
                  return this.extend({
                    style: this.style.text(),
                    size,
                    textSize: size,
                    sizeMultiplier: sizeMultipliers[size - 1]
                  });
                }
              }
              /**
               * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
               * changes to at least `\textstyle`.
               */
              havingBaseStyle(style) {
                style = style || this.style.text();
                const wantSize = sizeAtStyle(Options.BASESIZE, style);
                if (this.size === wantSize && this.textSize === Options.BASESIZE && this.style === style) {
                  return this;
                } else {
                  return this.extend({
                    style,
                    size: wantSize
                  });
                }
              }
              /**
               * Remove the effect of sizing changes such as \Huge.
               * Keep the effect of the current style, such as \scriptstyle.
               */
              havingBaseSizing() {
                let size;
                switch (this.style.id) {
                  case 4:
                  case 5:
                    size = 3;
                    break;
                  case 6:
                  case 7:
                    size = 1;
                    break;
                  default:
                    size = 6;
                }
                return this.extend({
                  style: this.style.text(),
                  size
                });
              }
              /**
               * Create a new options object with the given color.
               */
              withColor(color2) {
                return this.extend({
                  color: color2
                });
              }
              /**
               * Create a new options object with "phantom" set to true.
               */
              withPhantom() {
                return this.extend({
                  phantom: true
                });
              }
              /**
               * Creates a new options object with the given math font or old text font.
               * @type {[type]}
               */
              withFont(font) {
                return this.extend({
                  font
                });
              }
              /**
               * Create a new options objects with the given fontFamily.
               */
              withTextFontFamily(fontFamily) {
                return this.extend({
                  fontFamily,
                  font: ""
                });
              }
              /**
               * Creates a new options object with the given font weight
               */
              withTextFontWeight(fontWeight) {
                return this.extend({
                  fontWeight,
                  font: ""
                });
              }
              /**
               * Creates a new options object with the given font weight
               */
              withTextFontShape(fontShape) {
                return this.extend({
                  fontShape,
                  font: ""
                });
              }
              /**
               * Return the CSS sizing classes required to switch from enclosing options
               * `oldOptions` to `this`. Returns an array of classes.
               */
              sizingClasses(oldOptions) {
                if (oldOptions.size !== this.size) {
                  return ["sizing", "reset-size" + oldOptions.size, "size" + this.size];
                } else {
                  return [];
                }
              }
              /**
               * Return the CSS sizing classes required to switch to the base size. Like
               * `this.havingSize(BASESIZE).sizingClasses(this)`.
               */
              baseSizingClasses() {
                if (this.size !== Options.BASESIZE) {
                  return ["sizing", "reset-size" + this.size, "size" + Options.BASESIZE];
                } else {
                  return [];
                }
              }
              /**
               * Return the font metrics for this size.
               */
              fontMetrics() {
                if (!this._fontMetrics) {
                  this._fontMetrics = getGlobalMetrics(this.size);
                }
                return this._fontMetrics;
              }
              /**
               * Gets the CSS color of the current options object
               */
              getColor() {
                if (this.phantom) {
                  return "transparent";
                } else {
                  return this.color;
                }
              }
            }
            Options.BASESIZE = 6;
            var src_Options = Options;
            ;
            const ptPerUnit = {
              // https://en.wikibooks.org/wiki/LaTeX/Lengths and
              // https://tex.stackexchange.com/a/8263
              "pt": 1,
              // TeX point
              "mm": 7227 / 2540,
              // millimeter
              "cm": 7227 / 254,
              // centimeter
              "in": 72.27,
              // inch
              "bp": 803 / 800,
              // big (PostScript) points
              "pc": 12,
              // pica
              "dd": 1238 / 1157,
              // didot
              "cc": 14856 / 1157,
              // cicero (12 didot)
              "nd": 685 / 642,
              // new didot
              "nc": 1370 / 107,
              // new cicero (12 new didot)
              "sp": 1 / 65536,
              // scaled point (TeX's internal smallest unit)
              // https://tex.stackexchange.com/a/41371
              "px": 803 / 800
              // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
            };
            const relativeUnit = {
              "ex": true,
              "em": true,
              "mu": true
            };
            const validUnit = function(unit) {
              if (typeof unit !== "string") {
                unit = unit.unit;
              }
              return unit in ptPerUnit || unit in relativeUnit || unit === "ex";
            };
            const calculateSize = function(sizeValue, options) {
              let scale;
              if (sizeValue.unit in ptPerUnit) {
                scale = ptPerUnit[sizeValue.unit] / options.fontMetrics().ptPerEm / options.sizeMultiplier;
              } else if (sizeValue.unit === "mu") {
                scale = options.fontMetrics().cssEmPerMu;
              } else {
                let unitOptions;
                if (options.style.isTight()) {
                  unitOptions = options.havingStyle(options.style.text());
                } else {
                  unitOptions = options;
                }
                if (sizeValue.unit === "ex") {
                  scale = unitOptions.fontMetrics().xHeight;
                } else if (sizeValue.unit === "em") {
                  scale = unitOptions.fontMetrics().quad;
                } else {
                  throw new src_ParseError("Invalid unit: '" + sizeValue.unit + "'");
                }
                if (unitOptions !== options) {
                  scale *= unitOptions.sizeMultiplier / options.sizeMultiplier;
                }
              }
              return Math.min(sizeValue.number * scale, options.maxSize);
            };
            const makeEm = function(n) {
              return +n.toFixed(4) + "em";
            };
            ;
            const createClass = function(classes) {
              return classes.filter((cls) => cls).join(" ");
            };
            const initNode = function(classes, options, style) {
              this.classes = classes || [];
              this.attributes = {};
              this.height = 0;
              this.depth = 0;
              this.maxFontSize = 0;
              this.style = style || {};
              if (options) {
                if (options.style.isTight()) {
                  this.classes.push("mtight");
                }
                const color2 = options.getColor();
                if (color2) {
                  this.style.color = color2;
                }
              }
            };
            const toNode = function(tagName) {
              const node = document.createElement(tagName);
              node.className = createClass(this.classes);
              for (const style in this.style) {
                if (this.style.hasOwnProperty(style)) {
                  node.style[style] = this.style[style];
                }
              }
              for (const attr2 in this.attributes) {
                if (this.attributes.hasOwnProperty(attr2)) {
                  node.setAttribute(attr2, this.attributes[attr2]);
                }
              }
              for (let i = 0; i < this.children.length; i++) {
                node.appendChild(this.children[i].toNode());
              }
              return node;
            };
            const invalidAttributeNameRegex = /[\s"'>/=\x00-\x1f]/;
            const toMarkup = function(tagName) {
              let markup = "<" + tagName;
              if (this.classes.length) {
                markup += ' class="' + utils.escape(createClass(this.classes)) + '"';
              }
              let styles3 = "";
              for (const style in this.style) {
                if (this.style.hasOwnProperty(style)) {
                  styles3 += utils.hyphenate(style) + ":" + this.style[style] + ";";
                }
              }
              if (styles3) {
                markup += ' style="' + utils.escape(styles3) + '"';
              }
              for (const attr2 in this.attributes) {
                if (this.attributes.hasOwnProperty(attr2)) {
                  if (invalidAttributeNameRegex.test(attr2)) {
                    throw new src_ParseError("Invalid attribute name '" + attr2 + "'");
                  }
                  markup += " " + attr2 + '="' + utils.escape(this.attributes[attr2]) + '"';
                }
              }
              markup += ">";
              for (let i = 0; i < this.children.length; i++) {
                markup += this.children[i].toMarkup();
              }
              markup += "</" + tagName + ">";
              return markup;
            };
            class Span {
              constructor(classes, children3, options, style) {
                this.children = void 0;
                this.attributes = void 0;
                this.classes = void 0;
                this.height = void 0;
                this.depth = void 0;
                this.width = void 0;
                this.maxFontSize = void 0;
                this.style = void 0;
                initNode.call(this, classes, options, style);
                this.children = children3 || [];
              }
              /**
               * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
               * all browsers support attributes the same, and having too many custom
               * attributes is probably bad.
               */
              setAttribute(attribute2, value) {
                this.attributes[attribute2] = value;
              }
              hasClass(className) {
                return this.classes.includes(className);
              }
              toNode() {
                return toNode.call(this, "span");
              }
              toMarkup() {
                return toMarkup.call(this, "span");
              }
            }
            class Anchor {
              constructor(href, classes, children3, options) {
                this.children = void 0;
                this.attributes = void 0;
                this.classes = void 0;
                this.height = void 0;
                this.depth = void 0;
                this.maxFontSize = void 0;
                this.style = void 0;
                initNode.call(this, classes, options);
                this.children = children3 || [];
                this.setAttribute("href", href);
              }
              setAttribute(attribute2, value) {
                this.attributes[attribute2] = value;
              }
              hasClass(className) {
                return this.classes.includes(className);
              }
              toNode() {
                return toNode.call(this, "a");
              }
              toMarkup() {
                return toMarkup.call(this, "a");
              }
            }
            class Img {
              constructor(src, alt, style) {
                this.src = void 0;
                this.alt = void 0;
                this.classes = void 0;
                this.height = void 0;
                this.depth = void 0;
                this.maxFontSize = void 0;
                this.style = void 0;
                this.alt = alt;
                this.src = src;
                this.classes = ["mord"];
                this.style = style;
              }
              hasClass(className) {
                return this.classes.includes(className);
              }
              toNode() {
                const node = document.createElement("img");
                node.src = this.src;
                node.alt = this.alt;
                node.className = "mord";
                for (const style in this.style) {
                  if (this.style.hasOwnProperty(style)) {
                    node.style[style] = this.style[style];
                  }
                }
                return node;
              }
              toMarkup() {
                let markup = '<img src="' + utils.escape(this.src) + '"' + (' alt="' + utils.escape(this.alt) + '"');
                let styles3 = "";
                for (const style in this.style) {
                  if (this.style.hasOwnProperty(style)) {
                    styles3 += utils.hyphenate(style) + ":" + this.style[style] + ";";
                  }
                }
                if (styles3) {
                  markup += ' style="' + utils.escape(styles3) + '"';
                }
                markup += "'/>";
                return markup;
              }
            }
            const iCombinations = {
              "\xEE": "\u0131\u0302",
              "\xEF": "\u0131\u0308",
              "\xED": "\u0131\u0301",
              // 'ī': '\u0131\u0304', // enable when we add Extended Latin
              "\xEC": "\u0131\u0300"
            };
            class SymbolNode {
              constructor(text3, height, depth, italic, skew2, width, classes, style) {
                this.text = void 0;
                this.height = void 0;
                this.depth = void 0;
                this.italic = void 0;
                this.skew = void 0;
                this.width = void 0;
                this.maxFontSize = void 0;
                this.classes = void 0;
                this.style = void 0;
                this.text = text3;
                this.height = height || 0;
                this.depth = depth || 0;
                this.italic = italic || 0;
                this.skew = skew2 || 0;
                this.width = width || 0;
                this.classes = classes || [];
                this.style = style || {};
                this.maxFontSize = 0;
                const script = scriptFromCodepoint(this.text.charCodeAt(0));
                if (script) {
                  this.classes.push(script + "_fallback");
                }
                if (/[îïíì]/.test(this.text)) {
                  this.text = iCombinations[this.text];
                }
              }
              hasClass(className) {
                return this.classes.includes(className);
              }
              /**
               * Creates a text node or span from a symbol node. Note that a span is only
               * created if it is needed.
               */
              toNode() {
                const node = document.createTextNode(this.text);
                let span = null;
                if (this.italic > 0) {
                  span = document.createElement("span");
                  span.style.marginRight = makeEm(this.italic);
                }
                if (this.classes.length > 0) {
                  span = span || document.createElement("span");
                  span.className = createClass(this.classes);
                }
                for (const style in this.style) {
                  if (this.style.hasOwnProperty(style)) {
                    span = span || document.createElement("span");
                    span.style[style] = this.style[style];
                  }
                }
                if (span) {
                  span.appendChild(node);
                  return span;
                } else {
                  return node;
                }
              }
              /**
               * Creates markup for a symbol node.
               */
              toMarkup() {
                let needsSpan = false;
                let markup = "<span";
                if (this.classes.length) {
                  needsSpan = true;
                  markup += ' class="';
                  markup += utils.escape(createClass(this.classes));
                  markup += '"';
                }
                let styles3 = "";
                if (this.italic > 0) {
                  styles3 += "margin-right:" + this.italic + "em;";
                }
                for (const style in this.style) {
                  if (this.style.hasOwnProperty(style)) {
                    styles3 += utils.hyphenate(style) + ":" + this.style[style] + ";";
                  }
                }
                if (styles3) {
                  needsSpan = true;
                  markup += ' style="' + utils.escape(styles3) + '"';
                }
                const escaped = utils.escape(this.text);
                if (needsSpan) {
                  markup += ">";
                  markup += escaped;
                  markup += "</span>";
                  return markup;
                } else {
                  return escaped;
                }
              }
            }
            class SvgNode {
              constructor(children3, attributes2) {
                this.children = void 0;
                this.attributes = void 0;
                this.children = children3 || [];
                this.attributes = attributes2 || {};
              }
              toNode() {
                const svgNS = "http://www.w3.org/2000/svg";
                const node = document.createElementNS(svgNS, "svg");
                for (const attr2 in this.attributes) {
                  if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
                    node.setAttribute(attr2, this.attributes[attr2]);
                  }
                }
                for (let i = 0; i < this.children.length; i++) {
                  node.appendChild(this.children[i].toNode());
                }
                return node;
              }
              toMarkup() {
                let markup = '<svg xmlns="http://www.w3.org/2000/svg"';
                for (const attr2 in this.attributes) {
                  if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
                    markup += " " + attr2 + '="' + utils.escape(this.attributes[attr2]) + '"';
                  }
                }
                markup += ">";
                for (let i = 0; i < this.children.length; i++) {
                  markup += this.children[i].toMarkup();
                }
                markup += "</svg>";
                return markup;
              }
            }
            class PathNode {
              constructor(pathName, alternate) {
                this.pathName = void 0;
                this.alternate = void 0;
                this.pathName = pathName;
                this.alternate = alternate;
              }
              toNode() {
                const svgNS = "http://www.w3.org/2000/svg";
                const node = document.createElementNS(svgNS, "path");
                if (this.alternate) {
                  node.setAttribute("d", this.alternate);
                } else {
                  node.setAttribute("d", path2[this.pathName]);
                }
                return node;
              }
              toMarkup() {
                if (this.alternate) {
                  return '<path d="' + utils.escape(this.alternate) + '"/>';
                } else {
                  return '<path d="' + utils.escape(path2[this.pathName]) + '"/>';
                }
              }
            }
            class LineNode {
              constructor(attributes2) {
                this.attributes = void 0;
                this.attributes = attributes2 || {};
              }
              toNode() {
                const svgNS = "http://www.w3.org/2000/svg";
                const node = document.createElementNS(svgNS, "line");
                for (const attr2 in this.attributes) {
                  if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
                    node.setAttribute(attr2, this.attributes[attr2]);
                  }
                }
                return node;
              }
              toMarkup() {
                let markup = "<line";
                for (const attr2 in this.attributes) {
                  if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
                    markup += " " + attr2 + '="' + utils.escape(this.attributes[attr2]) + '"';
                  }
                }
                markup += "/>";
                return markup;
              }
            }
            function assertSymbolDomNode(group) {
              if (group instanceof SymbolNode) {
                return group;
              } else {
                throw new Error("Expected symbolNode but got " + String(group) + ".");
              }
            }
            function assertSpan(group) {
              if (group instanceof Span) {
                return group;
              } else {
                throw new Error("Expected span<HtmlDomNode> but got " + String(group) + ".");
              }
            }
            ;
            const ATOMS = {
              "bin": 1,
              "close": 1,
              "inner": 1,
              "open": 1,
              "punct": 1,
              "rel": 1
            };
            const NON_ATOMS = {
              "accent-token": 1,
              "mathord": 1,
              "op-token": 1,
              "spacing": 1,
              "textord": 1
            };
            const symbols = {
              "math": {},
              "text": {}
            };
            var src_symbols = symbols;
            function defineSymbol(mode, font, group, replace2, name2, acceptUnicodeChar) {
              symbols[mode][name2] = {
                font,
                group,
                replace: replace2
              };
              if (acceptUnicodeChar && replace2) {
                symbols[mode][replace2] = symbols[mode][name2];
              }
            }
            const math = "math";
            const symbols_text = "text";
            const main = "main";
            const ams = "ams";
            const accent = "accent-token";
            const bin = "bin";
            const symbols_close = "close";
            const inner = "inner";
            const mathord = "mathord";
            const op = "op-token";
            const symbols_open = "open";
            const punct = "punct";
            const rel = "rel";
            const spacing = "spacing";
            const textord = "textord";
            defineSymbol(math, main, rel, "\u2261", "\\equiv", true);
            defineSymbol(math, main, rel, "\u227A", "\\prec", true);
            defineSymbol(math, main, rel, "\u227B", "\\succ", true);
            defineSymbol(math, main, rel, "\u223C", "\\sim", true);
            defineSymbol(math, main, rel, "\u22A5", "\\perp");
            defineSymbol(math, main, rel, "\u2AAF", "\\preceq", true);
            defineSymbol(math, main, rel, "\u2AB0", "\\succeq", true);
            defineSymbol(math, main, rel, "\u2243", "\\simeq", true);
            defineSymbol(math, main, rel, "\u2223", "\\mid", true);
            defineSymbol(math, main, rel, "\u226A", "\\ll", true);
            defineSymbol(math, main, rel, "\u226B", "\\gg", true);
            defineSymbol(math, main, rel, "\u224D", "\\asymp", true);
            defineSymbol(math, main, rel, "\u2225", "\\parallel");
            defineSymbol(math, main, rel, "\u22C8", "\\bowtie", true);
            defineSymbol(math, main, rel, "\u2323", "\\smile", true);
            defineSymbol(math, main, rel, "\u2291", "\\sqsubseteq", true);
            defineSymbol(math, main, rel, "\u2292", "\\sqsupseteq", true);
            defineSymbol(math, main, rel, "\u2250", "\\doteq", true);
            defineSymbol(math, main, rel, "\u2322", "\\frown", true);
            defineSymbol(math, main, rel, "\u220B", "\\ni", true);
            defineSymbol(math, main, rel, "\u221D", "\\propto", true);
            defineSymbol(math, main, rel, "\u22A2", "\\vdash", true);
            defineSymbol(math, main, rel, "\u22A3", "\\dashv", true);
            defineSymbol(math, main, rel, "\u220B", "\\owns");
            defineSymbol(math, main, punct, ".", "\\ldotp");
            defineSymbol(math, main, punct, "\u22C5", "\\cdotp");
            defineSymbol(math, main, textord, "#", "\\#");
            defineSymbol(symbols_text, main, textord, "#", "\\#");
            defineSymbol(math, main, textord, "&", "\\&");
            defineSymbol(symbols_text, main, textord, "&", "\\&");
            defineSymbol(math, main, textord, "\u2135", "\\aleph", true);
            defineSymbol(math, main, textord, "\u2200", "\\forall", true);
            defineSymbol(math, main, textord, "\u210F", "\\hbar", true);
            defineSymbol(math, main, textord, "\u2203", "\\exists", true);
            defineSymbol(math, main, textord, "\u2207", "\\nabla", true);
            defineSymbol(math, main, textord, "\u266D", "\\flat", true);
            defineSymbol(math, main, textord, "\u2113", "\\ell", true);
            defineSymbol(math, main, textord, "\u266E", "\\natural", true);
            defineSymbol(math, main, textord, "\u2663", "\\clubsuit", true);
            defineSymbol(math, main, textord, "\u2118", "\\wp", true);
            defineSymbol(math, main, textord, "\u266F", "\\sharp", true);
            defineSymbol(math, main, textord, "\u2662", "\\diamondsuit", true);
            defineSymbol(math, main, textord, "\u211C", "\\Re", true);
            defineSymbol(math, main, textord, "\u2661", "\\heartsuit", true);
            defineSymbol(math, main, textord, "\u2111", "\\Im", true);
            defineSymbol(math, main, textord, "\u2660", "\\spadesuit", true);
            defineSymbol(math, main, textord, "\xA7", "\\S", true);
            defineSymbol(symbols_text, main, textord, "\xA7", "\\S");
            defineSymbol(math, main, textord, "\xB6", "\\P", true);
            defineSymbol(symbols_text, main, textord, "\xB6", "\\P");
            defineSymbol(math, main, textord, "\u2020", "\\dag");
            defineSymbol(symbols_text, main, textord, "\u2020", "\\dag");
            defineSymbol(symbols_text, main, textord, "\u2020", "\\textdagger");
            defineSymbol(math, main, textord, "\u2021", "\\ddag");
            defineSymbol(symbols_text, main, textord, "\u2021", "\\ddag");
            defineSymbol(symbols_text, main, textord, "\u2021", "\\textdaggerdbl");
            defineSymbol(math, main, symbols_close, "\u23B1", "\\rmoustache", true);
            defineSymbol(math, main, symbols_open, "\u23B0", "\\lmoustache", true);
            defineSymbol(math, main, symbols_close, "\u27EF", "\\rgroup", true);
            defineSymbol(math, main, symbols_open, "\u27EE", "\\lgroup", true);
            defineSymbol(math, main, bin, "\u2213", "\\mp", true);
            defineSymbol(math, main, bin, "\u2296", "\\ominus", true);
            defineSymbol(math, main, bin, "\u228E", "\\uplus", true);
            defineSymbol(math, main, bin, "\u2293", "\\sqcap", true);
            defineSymbol(math, main, bin, "\u2217", "\\ast");
            defineSymbol(math, main, bin, "\u2294", "\\sqcup", true);
            defineSymbol(math, main, bin, "\u25EF", "\\bigcirc", true);
            defineSymbol(math, main, bin, "\u2219", "\\bullet", true);
            defineSymbol(math, main, bin, "\u2021", "\\ddagger");
            defineSymbol(math, main, bin, "\u2240", "\\wr", true);
            defineSymbol(math, main, bin, "\u2A3F", "\\amalg");
            defineSymbol(math, main, bin, "&", "\\And");
            defineSymbol(math, main, rel, "\u27F5", "\\longleftarrow", true);
            defineSymbol(math, main, rel, "\u21D0", "\\Leftarrow", true);
            defineSymbol(math, main, rel, "\u27F8", "\\Longleftarrow", true);
            defineSymbol(math, main, rel, "\u27F6", "\\longrightarrow", true);
            defineSymbol(math, main, rel, "\u21D2", "\\Rightarrow", true);
            defineSymbol(math, main, rel, "\u27F9", "\\Longrightarrow", true);
            defineSymbol(math, main, rel, "\u2194", "\\leftrightarrow", true);
            defineSymbol(math, main, rel, "\u27F7", "\\longleftrightarrow", true);
            defineSymbol(math, main, rel, "\u21D4", "\\Leftrightarrow", true);
            defineSymbol(math, main, rel, "\u27FA", "\\Longleftrightarrow", true);
            defineSymbol(math, main, rel, "\u21A6", "\\mapsto", true);
            defineSymbol(math, main, rel, "\u27FC", "\\longmapsto", true);
            defineSymbol(math, main, rel, "\u2197", "\\nearrow", true);
            defineSymbol(math, main, rel, "\u21A9", "\\hookleftarrow", true);
            defineSymbol(math, main, rel, "\u21AA", "\\hookrightarrow", true);
            defineSymbol(math, main, rel, "\u2198", "\\searrow", true);
            defineSymbol(math, main, rel, "\u21BC", "\\leftharpoonup", true);
            defineSymbol(math, main, rel, "\u21C0", "\\rightharpoonup", true);
            defineSymbol(math, main, rel, "\u2199", "\\swarrow", true);
            defineSymbol(math, main, rel, "\u21BD", "\\leftharpoondown", true);
            defineSymbol(math, main, rel, "\u21C1", "\\rightharpoondown", true);
            defineSymbol(math, main, rel, "\u2196", "\\nwarrow", true);
            defineSymbol(math, main, rel, "\u21CC", "\\rightleftharpoons", true);
            defineSymbol(math, ams, rel, "\u226E", "\\nless", true);
            defineSymbol(math, ams, rel, "\uE010", "\\@nleqslant");
            defineSymbol(math, ams, rel, "\uE011", "\\@nleqq");
            defineSymbol(math, ams, rel, "\u2A87", "\\lneq", true);
            defineSymbol(math, ams, rel, "\u2268", "\\lneqq", true);
            defineSymbol(math, ams, rel, "\uE00C", "\\@lvertneqq");
            defineSymbol(math, ams, rel, "\u22E6", "\\lnsim", true);
            defineSymbol(math, ams, rel, "\u2A89", "\\lnapprox", true);
            defineSymbol(math, ams, rel, "\u2280", "\\nprec", true);
            defineSymbol(math, ams, rel, "\u22E0", "\\npreceq", true);
            defineSymbol(math, ams, rel, "\u22E8", "\\precnsim", true);
            defineSymbol(math, ams, rel, "\u2AB9", "\\precnapprox", true);
            defineSymbol(math, ams, rel, "\u2241", "\\nsim", true);
            defineSymbol(math, ams, rel, "\uE006", "\\@nshortmid");
            defineSymbol(math, ams, rel, "\u2224", "\\nmid", true);
            defineSymbol(math, ams, rel, "\u22AC", "\\nvdash", true);
            defineSymbol(math, ams, rel, "\u22AD", "\\nvDash", true);
            defineSymbol(math, ams, rel, "\u22EA", "\\ntriangleleft");
            defineSymbol(math, ams, rel, "\u22EC", "\\ntrianglelefteq", true);
            defineSymbol(math, ams, rel, "\u228A", "\\subsetneq", true);
            defineSymbol(math, ams, rel, "\uE01A", "\\@varsubsetneq");
            defineSymbol(math, ams, rel, "\u2ACB", "\\subsetneqq", true);
            defineSymbol(math, ams, rel, "\uE017", "\\@varsubsetneqq");
            defineSymbol(math, ams, rel, "\u226F", "\\ngtr", true);
            defineSymbol(math, ams, rel, "\uE00F", "\\@ngeqslant");
            defineSymbol(math, ams, rel, "\uE00E", "\\@ngeqq");
            defineSymbol(math, ams, rel, "\u2A88", "\\gneq", true);
            defineSymbol(math, ams, rel, "\u2269", "\\gneqq", true);
            defineSymbol(math, ams, rel, "\uE00D", "\\@gvertneqq");
            defineSymbol(math, ams, rel, "\u22E7", "\\gnsim", true);
            defineSymbol(math, ams, rel, "\u2A8A", "\\gnapprox", true);
            defineSymbol(math, ams, rel, "\u2281", "\\nsucc", true);
            defineSymbol(math, ams, rel, "\u22E1", "\\nsucceq", true);
            defineSymbol(math, ams, rel, "\u22E9", "\\succnsim", true);
            defineSymbol(math, ams, rel, "\u2ABA", "\\succnapprox", true);
            defineSymbol(math, ams, rel, "\u2246", "\\ncong", true);
            defineSymbol(math, ams, rel, "\uE007", "\\@nshortparallel");
            defineSymbol(math, ams, rel, "\u2226", "\\nparallel", true);
            defineSymbol(math, ams, rel, "\u22AF", "\\nVDash", true);
            defineSymbol(math, ams, rel, "\u22EB", "\\ntriangleright");
            defineSymbol(math, ams, rel, "\u22ED", "\\ntrianglerighteq", true);
            defineSymbol(math, ams, rel, "\uE018", "\\@nsupseteqq");
            defineSymbol(math, ams, rel, "\u228B", "\\supsetneq", true);
            defineSymbol(math, ams, rel, "\uE01B", "\\@varsupsetneq");
            defineSymbol(math, ams, rel, "\u2ACC", "\\supsetneqq", true);
            defineSymbol(math, ams, rel, "\uE019", "\\@varsupsetneqq");
            defineSymbol(math, ams, rel, "\u22AE", "\\nVdash", true);
            defineSymbol(math, ams, rel, "\u2AB5", "\\precneqq", true);
            defineSymbol(math, ams, rel, "\u2AB6", "\\succneqq", true);
            defineSymbol(math, ams, rel, "\uE016", "\\@nsubseteqq");
            defineSymbol(math, ams, bin, "\u22B4", "\\unlhd");
            defineSymbol(math, ams, bin, "\u22B5", "\\unrhd");
            defineSymbol(math, ams, rel, "\u219A", "\\nleftarrow", true);
            defineSymbol(math, ams, rel, "\u219B", "\\nrightarrow", true);
            defineSymbol(math, ams, rel, "\u21CD", "\\nLeftarrow", true);
            defineSymbol(math, ams, rel, "\u21CF", "\\nRightarrow", true);
            defineSymbol(math, ams, rel, "\u21AE", "\\nleftrightarrow", true);
            defineSymbol(math, ams, rel, "\u21CE", "\\nLeftrightarrow", true);
            defineSymbol(math, ams, rel, "\u25B3", "\\vartriangle");
            defineSymbol(math, ams, textord, "\u210F", "\\hslash");
            defineSymbol(math, ams, textord, "\u25BD", "\\triangledown");
            defineSymbol(math, ams, textord, "\u25CA", "\\lozenge");
            defineSymbol(math, ams, textord, "\u24C8", "\\circledS");
            defineSymbol(math, ams, textord, "\xAE", "\\circledR");
            defineSymbol(symbols_text, ams, textord, "\xAE", "\\circledR");
            defineSymbol(math, ams, textord, "\u2221", "\\measuredangle", true);
            defineSymbol(math, ams, textord, "\u2204", "\\nexists");
            defineSymbol(math, ams, textord, "\u2127", "\\mho");
            defineSymbol(math, ams, textord, "\u2132", "\\Finv", true);
            defineSymbol(math, ams, textord, "\u2141", "\\Game", true);
            defineSymbol(math, ams, textord, "\u2035", "\\backprime");
            defineSymbol(math, ams, textord, "\u25B2", "\\blacktriangle");
            defineSymbol(math, ams, textord, "\u25BC", "\\blacktriangledown");
            defineSymbol(math, ams, textord, "\u25A0", "\\blacksquare");
            defineSymbol(math, ams, textord, "\u29EB", "\\blacklozenge");
            defineSymbol(math, ams, textord, "\u2605", "\\bigstar");
            defineSymbol(math, ams, textord, "\u2222", "\\sphericalangle", true);
            defineSymbol(math, ams, textord, "\u2201", "\\complement", true);
            defineSymbol(math, ams, textord, "\xF0", "\\eth", true);
            defineSymbol(symbols_text, main, textord, "\xF0", "\xF0");
            defineSymbol(math, ams, textord, "\u2571", "\\diagup");
            defineSymbol(math, ams, textord, "\u2572", "\\diagdown");
            defineSymbol(math, ams, textord, "\u25A1", "\\square");
            defineSymbol(math, ams, textord, "\u25A1", "\\Box");
            defineSymbol(math, ams, textord, "\u25CA", "\\Diamond");
            defineSymbol(math, ams, textord, "\xA5", "\\yen", true);
            defineSymbol(symbols_text, ams, textord, "\xA5", "\\yen", true);
            defineSymbol(math, ams, textord, "\u2713", "\\checkmark", true);
            defineSymbol(symbols_text, ams, textord, "\u2713", "\\checkmark");
            defineSymbol(math, ams, textord, "\u2136", "\\beth", true);
            defineSymbol(math, ams, textord, "\u2138", "\\daleth", true);
            defineSymbol(math, ams, textord, "\u2137", "\\gimel", true);
            defineSymbol(math, ams, textord, "\u03DD", "\\digamma", true);
            defineSymbol(math, ams, textord, "\u03F0", "\\varkappa");
            defineSymbol(math, ams, symbols_open, "\u250C", "\\@ulcorner", true);
            defineSymbol(math, ams, symbols_close, "\u2510", "\\@urcorner", true);
            defineSymbol(math, ams, symbols_open, "\u2514", "\\@llcorner", true);
            defineSymbol(math, ams, symbols_close, "\u2518", "\\@lrcorner", true);
            defineSymbol(math, ams, rel, "\u2266", "\\leqq", true);
            defineSymbol(math, ams, rel, "\u2A7D", "\\leqslant", true);
            defineSymbol(math, ams, rel, "\u2A95", "\\eqslantless", true);
            defineSymbol(math, ams, rel, "\u2272", "\\lesssim", true);
            defineSymbol(math, ams, rel, "\u2A85", "\\lessapprox", true);
            defineSymbol(math, ams, rel, "\u224A", "\\approxeq", true);
            defineSymbol(math, ams, bin, "\u22D6", "\\lessdot");
            defineSymbol(math, ams, rel, "\u22D8", "\\lll", true);
            defineSymbol(math, ams, rel, "\u2276", "\\lessgtr", true);
            defineSymbol(math, ams, rel, "\u22DA", "\\lesseqgtr", true);
            defineSymbol(math, ams, rel, "\u2A8B", "\\lesseqqgtr", true);
            defineSymbol(math, ams, rel, "\u2251", "\\doteqdot");
            defineSymbol(math, ams, rel, "\u2253", "\\risingdotseq", true);
            defineSymbol(math, ams, rel, "\u2252", "\\fallingdotseq", true);
            defineSymbol(math, ams, rel, "\u223D", "\\backsim", true);
            defineSymbol(math, ams, rel, "\u22CD", "\\backsimeq", true);
            defineSymbol(math, ams, rel, "\u2AC5", "\\subseteqq", true);
            defineSymbol(math, ams, rel, "\u22D0", "\\Subset", true);
            defineSymbol(math, ams, rel, "\u228F", "\\sqsubset", true);
            defineSymbol(math, ams, rel, "\u227C", "\\preccurlyeq", true);
            defineSymbol(math, ams, rel, "\u22DE", "\\curlyeqprec", true);
            defineSymbol(math, ams, rel, "\u227E", "\\precsim", true);
            defineSymbol(math, ams, rel, "\u2AB7", "\\precapprox", true);
            defineSymbol(math, ams, rel, "\u22B2", "\\vartriangleleft");
            defineSymbol(math, ams, rel, "\u22B4", "\\trianglelefteq");
            defineSymbol(math, ams, rel, "\u22A8", "\\vDash", true);
            defineSymbol(math, ams, rel, "\u22AA", "\\Vvdash", true);
            defineSymbol(math, ams, rel, "\u2323", "\\smallsmile");
            defineSymbol(math, ams, rel, "\u2322", "\\smallfrown");
            defineSymbol(math, ams, rel, "\u224F", "\\bumpeq", true);
            defineSymbol(math, ams, rel, "\u224E", "\\Bumpeq", true);
            defineSymbol(math, ams, rel, "\u2267", "\\geqq", true);
            defineSymbol(math, ams, rel, "\u2A7E", "\\geqslant", true);
            defineSymbol(math, ams, rel, "\u2A96", "\\eqslantgtr", true);
            defineSymbol(math, ams, rel, "\u2273", "\\gtrsim", true);
            defineSymbol(math, ams, rel, "\u2A86", "\\gtrapprox", true);
            defineSymbol(math, ams, bin, "\u22D7", "\\gtrdot");
            defineSymbol(math, ams, rel, "\u22D9", "\\ggg", true);
            defineSymbol(math, ams, rel, "\u2277", "\\gtrless", true);
            defineSymbol(math, ams, rel, "\u22DB", "\\gtreqless", true);
            defineSymbol(math, ams, rel, "\u2A8C", "\\gtreqqless", true);
            defineSymbol(math, ams, rel, "\u2256", "\\eqcirc", true);
            defineSymbol(math, ams, rel, "\u2257", "\\circeq", true);
            defineSymbol(math, ams, rel, "\u225C", "\\triangleq", true);
            defineSymbol(math, ams, rel, "\u223C", "\\thicksim");
            defineSymbol(math, ams, rel, "\u2248", "\\thickapprox");
            defineSymbol(math, ams, rel, "\u2AC6", "\\supseteqq", true);
            defineSymbol(math, ams, rel, "\u22D1", "\\Supset", true);
            defineSymbol(math, ams, rel, "\u2290", "\\sqsupset", true);
            defineSymbol(math, ams, rel, "\u227D", "\\succcurlyeq", true);
            defineSymbol(math, ams, rel, "\u22DF", "\\curlyeqsucc", true);
            defineSymbol(math, ams, rel, "\u227F", "\\succsim", true);
            defineSymbol(math, ams, rel, "\u2AB8", "\\succapprox", true);
            defineSymbol(math, ams, rel, "\u22B3", "\\vartriangleright");
            defineSymbol(math, ams, rel, "\u22B5", "\\trianglerighteq");
            defineSymbol(math, ams, rel, "\u22A9", "\\Vdash", true);
            defineSymbol(math, ams, rel, "\u2223", "\\shortmid");
            defineSymbol(math, ams, rel, "\u2225", "\\shortparallel");
            defineSymbol(math, ams, rel, "\u226C", "\\between", true);
            defineSymbol(math, ams, rel, "\u22D4", "\\pitchfork", true);
            defineSymbol(math, ams, rel, "\u221D", "\\varpropto");
            defineSymbol(math, ams, rel, "\u25C0", "\\blacktriangleleft");
            defineSymbol(math, ams, rel, "\u2234", "\\therefore", true);
            defineSymbol(math, ams, rel, "\u220D", "\\backepsilon");
            defineSymbol(math, ams, rel, "\u25B6", "\\blacktriangleright");
            defineSymbol(math, ams, rel, "\u2235", "\\because", true);
            defineSymbol(math, ams, rel, "\u22D8", "\\llless");
            defineSymbol(math, ams, rel, "\u22D9", "\\gggtr");
            defineSymbol(math, ams, bin, "\u22B2", "\\lhd");
            defineSymbol(math, ams, bin, "\u22B3", "\\rhd");
            defineSymbol(math, ams, rel, "\u2242", "\\eqsim", true);
            defineSymbol(math, main, rel, "\u22C8", "\\Join");
            defineSymbol(math, ams, rel, "\u2251", "\\Doteq", true);
            defineSymbol(math, ams, bin, "\u2214", "\\dotplus", true);
            defineSymbol(math, ams, bin, "\u2216", "\\smallsetminus");
            defineSymbol(math, ams, bin, "\u22D2", "\\Cap", true);
            defineSymbol(math, ams, bin, "\u22D3", "\\Cup", true);
            defineSymbol(math, ams, bin, "\u2A5E", "\\doublebarwedge", true);
            defineSymbol(math, ams, bin, "\u229F", "\\boxminus", true);
            defineSymbol(math, ams, bin, "\u229E", "\\boxplus", true);
            defineSymbol(math, ams, bin, "\u22C7", "\\divideontimes", true);
            defineSymbol(math, ams, bin, "\u22C9", "\\ltimes", true);
            defineSymbol(math, ams, bin, "\u22CA", "\\rtimes", true);
            defineSymbol(math, ams, bin, "\u22CB", "\\leftthreetimes", true);
            defineSymbol(math, ams, bin, "\u22CC", "\\rightthreetimes", true);
            defineSymbol(math, ams, bin, "\u22CF", "\\curlywedge", true);
            defineSymbol(math, ams, bin, "\u22CE", "\\curlyvee", true);
            defineSymbol(math, ams, bin, "\u229D", "\\circleddash", true);
            defineSymbol(math, ams, bin, "\u229B", "\\circledast", true);
            defineSymbol(math, ams, bin, "\u22C5", "\\centerdot");
            defineSymbol(math, ams, bin, "\u22BA", "\\intercal", true);
            defineSymbol(math, ams, bin, "\u22D2", "\\doublecap");
            defineSymbol(math, ams, bin, "\u22D3", "\\doublecup");
            defineSymbol(math, ams, bin, "\u22A0", "\\boxtimes", true);
            defineSymbol(math, ams, rel, "\u21E2", "\\dashrightarrow", true);
            defineSymbol(math, ams, rel, "\u21E0", "\\dashleftarrow", true);
            defineSymbol(math, ams, rel, "\u21C7", "\\leftleftarrows", true);
            defineSymbol(math, ams, rel, "\u21C6", "\\leftrightarrows", true);
            defineSymbol(math, ams, rel, "\u21DA", "\\Lleftarrow", true);
            defineSymbol(math, ams, rel, "\u219E", "\\twoheadleftarrow", true);
            defineSymbol(math, ams, rel, "\u21A2", "\\leftarrowtail", true);
            defineSymbol(math, ams, rel, "\u21AB", "\\looparrowleft", true);
            defineSymbol(math, ams, rel, "\u21CB", "\\leftrightharpoons", true);
            defineSymbol(math, ams, rel, "\u21B6", "\\curvearrowleft", true);
            defineSymbol(math, ams, rel, "\u21BA", "\\circlearrowleft", true);
            defineSymbol(math, ams, rel, "\u21B0", "\\Lsh", true);
            defineSymbol(math, ams, rel, "\u21C8", "\\upuparrows", true);
            defineSymbol(math, ams, rel, "\u21BF", "\\upharpoonleft", true);
            defineSymbol(math, ams, rel, "\u21C3", "\\downharpoonleft", true);
            defineSymbol(math, main, rel, "\u22B6", "\\origof", true);
            defineSymbol(math, main, rel, "\u22B7", "\\imageof", true);
            defineSymbol(math, ams, rel, "\u22B8", "\\multimap", true);
            defineSymbol(math, ams, rel, "\u21AD", "\\leftrightsquigarrow", true);
            defineSymbol(math, ams, rel, "\u21C9", "\\rightrightarrows", true);
            defineSymbol(math, ams, rel, "\u21C4", "\\rightleftarrows", true);
            defineSymbol(math, ams, rel, "\u21A0", "\\twoheadrightarrow", true);
            defineSymbol(math, ams, rel, "\u21A3", "\\rightarrowtail", true);
            defineSymbol(math, ams, rel, "\u21AC", "\\looparrowright", true);
            defineSymbol(math, ams, rel, "\u21B7", "\\curvearrowright", true);
            defineSymbol(math, ams, rel, "\u21BB", "\\circlearrowright", true);
            defineSymbol(math, ams, rel, "\u21B1", "\\Rsh", true);
            defineSymbol(math, ams, rel, "\u21CA", "\\downdownarrows", true);
            defineSymbol(math, ams, rel, "\u21BE", "\\upharpoonright", true);
            defineSymbol(math, ams, rel, "\u21C2", "\\downharpoonright", true);
            defineSymbol(math, ams, rel, "\u21DD", "\\rightsquigarrow", true);
            defineSymbol(math, ams, rel, "\u21DD", "\\leadsto");
            defineSymbol(math, ams, rel, "\u21DB", "\\Rrightarrow", true);
            defineSymbol(math, ams, rel, "\u21BE", "\\restriction");
            defineSymbol(math, main, textord, "\u2018", "`");
            defineSymbol(math, main, textord, "$", "\\$");
            defineSymbol(symbols_text, main, textord, "$", "\\$");
            defineSymbol(symbols_text, main, textord, "$", "\\textdollar");
            defineSymbol(math, main, textord, "%", "\\%");
            defineSymbol(symbols_text, main, textord, "%", "\\%");
            defineSymbol(math, main, textord, "_", "\\_");
            defineSymbol(symbols_text, main, textord, "_", "\\_");
            defineSymbol(symbols_text, main, textord, "_", "\\textunderscore");
            defineSymbol(math, main, textord, "\u2220", "\\angle", true);
            defineSymbol(math, main, textord, "\u221E", "\\infty", true);
            defineSymbol(math, main, textord, "\u2032", "\\prime");
            defineSymbol(math, main, textord, "\u25B3", "\\triangle");
            defineSymbol(math, main, textord, "\u0393", "\\Gamma", true);
            defineSymbol(math, main, textord, "\u0394", "\\Delta", true);
            defineSymbol(math, main, textord, "\u0398", "\\Theta", true);
            defineSymbol(math, main, textord, "\u039B", "\\Lambda", true);
            defineSymbol(math, main, textord, "\u039E", "\\Xi", true);
            defineSymbol(math, main, textord, "\u03A0", "\\Pi", true);
            defineSymbol(math, main, textord, "\u03A3", "\\Sigma", true);
            defineSymbol(math, main, textord, "\u03A5", "\\Upsilon", true);
            defineSymbol(math, main, textord, "\u03A6", "\\Phi", true);
            defineSymbol(math, main, textord, "\u03A8", "\\Psi", true);
            defineSymbol(math, main, textord, "\u03A9", "\\Omega", true);
            defineSymbol(math, main, textord, "A", "\u0391");
            defineSymbol(math, main, textord, "B", "\u0392");
            defineSymbol(math, main, textord, "E", "\u0395");
            defineSymbol(math, main, textord, "Z", "\u0396");
            defineSymbol(math, main, textord, "H", "\u0397");
            defineSymbol(math, main, textord, "I", "\u0399");
            defineSymbol(math, main, textord, "K", "\u039A");
            defineSymbol(math, main, textord, "M", "\u039C");
            defineSymbol(math, main, textord, "N", "\u039D");
            defineSymbol(math, main, textord, "O", "\u039F");
            defineSymbol(math, main, textord, "P", "\u03A1");
            defineSymbol(math, main, textord, "T", "\u03A4");
            defineSymbol(math, main, textord, "X", "\u03A7");
            defineSymbol(math, main, textord, "\xAC", "\\neg", true);
            defineSymbol(math, main, textord, "\xAC", "\\lnot");
            defineSymbol(math, main, textord, "\u22A4", "\\top");
            defineSymbol(math, main, textord, "\u22A5", "\\bot");
            defineSymbol(math, main, textord, "\u2205", "\\emptyset");
            defineSymbol(math, ams, textord, "\u2205", "\\varnothing");
            defineSymbol(math, main, mathord, "\u03B1", "\\alpha", true);
            defineSymbol(math, main, mathord, "\u03B2", "\\beta", true);
            defineSymbol(math, main, mathord, "\u03B3", "\\gamma", true);
            defineSymbol(math, main, mathord, "\u03B4", "\\delta", true);
            defineSymbol(math, main, mathord, "\u03F5", "\\epsilon", true);
            defineSymbol(math, main, mathord, "\u03B6", "\\zeta", true);
            defineSymbol(math, main, mathord, "\u03B7", "\\eta", true);
            defineSymbol(math, main, mathord, "\u03B8", "\\theta", true);
            defineSymbol(math, main, mathord, "\u03B9", "\\iota", true);
            defineSymbol(math, main, mathord, "\u03BA", "\\kappa", true);
            defineSymbol(math, main, mathord, "\u03BB", "\\lambda", true);
            defineSymbol(math, main, mathord, "\u03BC", "\\mu", true);
            defineSymbol(math, main, mathord, "\u03BD", "\\nu", true);
            defineSymbol(math, main, mathord, "\u03BE", "\\xi", true);
            defineSymbol(math, main, mathord, "\u03BF", "\\omicron", true);
            defineSymbol(math, main, mathord, "\u03C0", "\\pi", true);
            defineSymbol(math, main, mathord, "\u03C1", "\\rho", true);
            defineSymbol(math, main, mathord, "\u03C3", "\\sigma", true);
            defineSymbol(math, main, mathord, "\u03C4", "\\tau", true);
            defineSymbol(math, main, mathord, "\u03C5", "\\upsilon", true);
            defineSymbol(math, main, mathord, "\u03D5", "\\phi", true);
            defineSymbol(math, main, mathord, "\u03C7", "\\chi", true);
            defineSymbol(math, main, mathord, "\u03C8", "\\psi", true);
            defineSymbol(math, main, mathord, "\u03C9", "\\omega", true);
            defineSymbol(math, main, mathord, "\u03B5", "\\varepsilon", true);
            defineSymbol(math, main, mathord, "\u03D1", "\\vartheta", true);
            defineSymbol(math, main, mathord, "\u03D6", "\\varpi", true);
            defineSymbol(math, main, mathord, "\u03F1", "\\varrho", true);
            defineSymbol(math, main, mathord, "\u03C2", "\\varsigma", true);
            defineSymbol(math, main, mathord, "\u03C6", "\\varphi", true);
            defineSymbol(math, main, bin, "\u2217", "*", true);
            defineSymbol(math, main, bin, "+", "+");
            defineSymbol(math, main, bin, "\u2212", "-", true);
            defineSymbol(math, main, bin, "\u22C5", "\\cdot", true);
            defineSymbol(math, main, bin, "\u2218", "\\circ", true);
            defineSymbol(math, main, bin, "\xF7", "\\div", true);
            defineSymbol(math, main, bin, "\xB1", "\\pm", true);
            defineSymbol(math, main, bin, "\xD7", "\\times", true);
            defineSymbol(math, main, bin, "\u2229", "\\cap", true);
            defineSymbol(math, main, bin, "\u222A", "\\cup", true);
            defineSymbol(math, main, bin, "\u2216", "\\setminus", true);
            defineSymbol(math, main, bin, "\u2227", "\\land");
            defineSymbol(math, main, bin, "\u2228", "\\lor");
            defineSymbol(math, main, bin, "\u2227", "\\wedge", true);
            defineSymbol(math, main, bin, "\u2228", "\\vee", true);
            defineSymbol(math, main, textord, "\u221A", "\\surd");
            defineSymbol(math, main, symbols_open, "\u27E8", "\\langle", true);
            defineSymbol(math, main, symbols_open, "\u2223", "\\lvert");
            defineSymbol(math, main, symbols_open, "\u2225", "\\lVert");
            defineSymbol(math, main, symbols_close, "?", "?");
            defineSymbol(math, main, symbols_close, "!", "!");
            defineSymbol(math, main, symbols_close, "\u27E9", "\\rangle", true);
            defineSymbol(math, main, symbols_close, "\u2223", "\\rvert");
            defineSymbol(math, main, symbols_close, "\u2225", "\\rVert");
            defineSymbol(math, main, rel, "=", "=");
            defineSymbol(math, main, rel, ":", ":");
            defineSymbol(math, main, rel, "\u2248", "\\approx", true);
            defineSymbol(math, main, rel, "\u2245", "\\cong", true);
            defineSymbol(math, main, rel, "\u2265", "\\ge");
            defineSymbol(math, main, rel, "\u2265", "\\geq", true);
            defineSymbol(math, main, rel, "\u2190", "\\gets");
            defineSymbol(math, main, rel, ">", "\\gt", true);
            defineSymbol(math, main, rel, "\u2208", "\\in", true);
            defineSymbol(math, main, rel, "\uE020", "\\@not");
            defineSymbol(math, main, rel, "\u2282", "\\subset", true);
            defineSymbol(math, main, rel, "\u2283", "\\supset", true);
            defineSymbol(math, main, rel, "\u2286", "\\subseteq", true);
            defineSymbol(math, main, rel, "\u2287", "\\supseteq", true);
            defineSymbol(math, ams, rel, "\u2288", "\\nsubseteq", true);
            defineSymbol(math, ams, rel, "\u2289", "\\nsupseteq", true);
            defineSymbol(math, main, rel, "\u22A8", "\\models");
            defineSymbol(math, main, rel, "\u2190", "\\leftarrow", true);
            defineSymbol(math, main, rel, "\u2264", "\\le");
            defineSymbol(math, main, rel, "\u2264", "\\leq", true);
            defineSymbol(math, main, rel, "<", "\\lt", true);
            defineSymbol(math, main, rel, "\u2192", "\\rightarrow", true);
            defineSymbol(math, main, rel, "\u2192", "\\to");
            defineSymbol(math, ams, rel, "\u2271", "\\ngeq", true);
            defineSymbol(math, ams, rel, "\u2270", "\\nleq", true);
            defineSymbol(math, main, spacing, "\xA0", "\\ ");
            defineSymbol(math, main, spacing, "\xA0", "\\space");
            defineSymbol(math, main, spacing, "\xA0", "\\nobreakspace");
            defineSymbol(symbols_text, main, spacing, "\xA0", "\\ ");
            defineSymbol(symbols_text, main, spacing, "\xA0", " ");
            defineSymbol(symbols_text, main, spacing, "\xA0", "\\space");
            defineSymbol(symbols_text, main, spacing, "\xA0", "\\nobreakspace");
            defineSymbol(math, main, spacing, null, "\\nobreak");
            defineSymbol(math, main, spacing, null, "\\allowbreak");
            defineSymbol(math, main, punct, ",", ",");
            defineSymbol(math, main, punct, ";", ";");
            defineSymbol(math, ams, bin, "\u22BC", "\\barwedge", true);
            defineSymbol(math, ams, bin, "\u22BB", "\\veebar", true);
            defineSymbol(math, main, bin, "\u2299", "\\odot", true);
            defineSymbol(math, main, bin, "\u2295", "\\oplus", true);
            defineSymbol(math, main, bin, "\u2297", "\\otimes", true);
            defineSymbol(math, main, textord, "\u2202", "\\partial", true);
            defineSymbol(math, main, bin, "\u2298", "\\oslash", true);
            defineSymbol(math, ams, bin, "\u229A", "\\circledcirc", true);
            defineSymbol(math, ams, bin, "\u22A1", "\\boxdot", true);
            defineSymbol(math, main, bin, "\u25B3", "\\bigtriangleup");
            defineSymbol(math, main, bin, "\u25BD", "\\bigtriangledown");
            defineSymbol(math, main, bin, "\u2020", "\\dagger");
            defineSymbol(math, main, bin, "\u22C4", "\\diamond");
            defineSymbol(math, main, bin, "\u22C6", "\\star");
            defineSymbol(math, main, bin, "\u25C3", "\\triangleleft");
            defineSymbol(math, main, bin, "\u25B9", "\\triangleright");
            defineSymbol(math, main, symbols_open, "{", "\\{");
            defineSymbol(symbols_text, main, textord, "{", "\\{");
            defineSymbol(symbols_text, main, textord, "{", "\\textbraceleft");
            defineSymbol(math, main, symbols_close, "}", "\\}");
            defineSymbol(symbols_text, main, textord, "}", "\\}");
            defineSymbol(symbols_text, main, textord, "}", "\\textbraceright");
            defineSymbol(math, main, symbols_open, "{", "\\lbrace");
            defineSymbol(math, main, symbols_close, "}", "\\rbrace");
            defineSymbol(math, main, symbols_open, "[", "\\lbrack", true);
            defineSymbol(symbols_text, main, textord, "[", "\\lbrack", true);
            defineSymbol(math, main, symbols_close, "]", "\\rbrack", true);
            defineSymbol(symbols_text, main, textord, "]", "\\rbrack", true);
            defineSymbol(math, main, symbols_open, "(", "\\lparen", true);
            defineSymbol(math, main, symbols_close, ")", "\\rparen", true);
            defineSymbol(symbols_text, main, textord, "<", "\\textless", true);
            defineSymbol(symbols_text, main, textord, ">", "\\textgreater", true);
            defineSymbol(math, main, symbols_open, "\u230A", "\\lfloor", true);
            defineSymbol(math, main, symbols_close, "\u230B", "\\rfloor", true);
            defineSymbol(math, main, symbols_open, "\u2308", "\\lceil", true);
            defineSymbol(math, main, symbols_close, "\u2309", "\\rceil", true);
            defineSymbol(math, main, textord, "\\", "\\backslash");
            defineSymbol(math, main, textord, "\u2223", "|");
            defineSymbol(math, main, textord, "\u2223", "\\vert");
            defineSymbol(symbols_text, main, textord, "|", "\\textbar", true);
            defineSymbol(math, main, textord, "\u2225", "\\|");
            defineSymbol(math, main, textord, "\u2225", "\\Vert");
            defineSymbol(symbols_text, main, textord, "\u2225", "\\textbardbl");
            defineSymbol(symbols_text, main, textord, "~", "\\textasciitilde");
            defineSymbol(symbols_text, main, textord, "\\", "\\textbackslash");
            defineSymbol(symbols_text, main, textord, "^", "\\textasciicircum");
            defineSymbol(math, main, rel, "\u2191", "\\uparrow", true);
            defineSymbol(math, main, rel, "\u21D1", "\\Uparrow", true);
            defineSymbol(math, main, rel, "\u2193", "\\downarrow", true);
            defineSymbol(math, main, rel, "\u21D3", "\\Downarrow", true);
            defineSymbol(math, main, rel, "\u2195", "\\updownarrow", true);
            defineSymbol(math, main, rel, "\u21D5", "\\Updownarrow", true);
            defineSymbol(math, main, op, "\u2210", "\\coprod");
            defineSymbol(math, main, op, "\u22C1", "\\bigvee");
            defineSymbol(math, main, op, "\u22C0", "\\bigwedge");
            defineSymbol(math, main, op, "\u2A04", "\\biguplus");
            defineSymbol(math, main, op, "\u22C2", "\\bigcap");
            defineSymbol(math, main, op, "\u22C3", "\\bigcup");
            defineSymbol(math, main, op, "\u222B", "\\int");
            defineSymbol(math, main, op, "\u222B", "\\intop");
            defineSymbol(math, main, op, "\u222C", "\\iint");
            defineSymbol(math, main, op, "\u222D", "\\iiint");
            defineSymbol(math, main, op, "\u220F", "\\prod");
            defineSymbol(math, main, op, "\u2211", "\\sum");
            defineSymbol(math, main, op, "\u2A02", "\\bigotimes");
            defineSymbol(math, main, op, "\u2A01", "\\bigoplus");
            defineSymbol(math, main, op, "\u2A00", "\\bigodot");
            defineSymbol(math, main, op, "\u222E", "\\oint");
            defineSymbol(math, main, op, "\u222F", "\\oiint");
            defineSymbol(math, main, op, "\u2230", "\\oiiint");
            defineSymbol(math, main, op, "\u2A06", "\\bigsqcup");
            defineSymbol(math, main, op, "\u222B", "\\smallint");
            defineSymbol(symbols_text, main, inner, "\u2026", "\\textellipsis");
            defineSymbol(math, main, inner, "\u2026", "\\mathellipsis");
            defineSymbol(symbols_text, main, inner, "\u2026", "\\ldots", true);
            defineSymbol(math, main, inner, "\u2026", "\\ldots", true);
            defineSymbol(math, main, inner, "\u22EF", "\\@cdots", true);
            defineSymbol(math, main, inner, "\u22F1", "\\ddots", true);
            defineSymbol(math, main, textord, "\u22EE", "\\varvdots");
            defineSymbol(symbols_text, main, textord, "\u22EE", "\\varvdots");
            defineSymbol(math, main, accent, "\u02CA", "\\acute");
            defineSymbol(math, main, accent, "\u02CB", "\\grave");
            defineSymbol(math, main, accent, "\xA8", "\\ddot");
            defineSymbol(math, main, accent, "~", "\\tilde");
            defineSymbol(math, main, accent, "\u02C9", "\\bar");
            defineSymbol(math, main, accent, "\u02D8", "\\breve");
            defineSymbol(math, main, accent, "\u02C7", "\\check");
            defineSymbol(math, main, accent, "^", "\\hat");
            defineSymbol(math, main, accent, "\u20D7", "\\vec");
            defineSymbol(math, main, accent, "\u02D9", "\\dot");
            defineSymbol(math, main, accent, "\u02DA", "\\mathring");
            defineSymbol(math, main, mathord, "\uE131", "\\@imath");
            defineSymbol(math, main, mathord, "\uE237", "\\@jmath");
            defineSymbol(math, main, textord, "\u0131", "\u0131");
            defineSymbol(math, main, textord, "\u0237", "\u0237");
            defineSymbol(symbols_text, main, textord, "\u0131", "\\i", true);
            defineSymbol(symbols_text, main, textord, "\u0237", "\\j", true);
            defineSymbol(symbols_text, main, textord, "\xDF", "\\ss", true);
            defineSymbol(symbols_text, main, textord, "\xE6", "\\ae", true);
            defineSymbol(symbols_text, main, textord, "\u0153", "\\oe", true);
            defineSymbol(symbols_text, main, textord, "\xF8", "\\o", true);
            defineSymbol(symbols_text, main, textord, "\xC6", "\\AE", true);
            defineSymbol(symbols_text, main, textord, "\u0152", "\\OE", true);
            defineSymbol(symbols_text, main, textord, "\xD8", "\\O", true);
            defineSymbol(symbols_text, main, accent, "\u02CA", "\\'");
            defineSymbol(symbols_text, main, accent, "\u02CB", "\\`");
            defineSymbol(symbols_text, main, accent, "\u02C6", "\\^");
            defineSymbol(symbols_text, main, accent, "\u02DC", "\\~");
            defineSymbol(symbols_text, main, accent, "\u02C9", "\\=");
            defineSymbol(symbols_text, main, accent, "\u02D8", "\\u");
            defineSymbol(symbols_text, main, accent, "\u02D9", "\\.");
            defineSymbol(symbols_text, main, accent, "\xB8", "\\c");
            defineSymbol(symbols_text, main, accent, "\u02DA", "\\r");
            defineSymbol(symbols_text, main, accent, "\u02C7", "\\v");
            defineSymbol(symbols_text, main, accent, "\xA8", '\\"');
            defineSymbol(symbols_text, main, accent, "\u02DD", "\\H");
            defineSymbol(symbols_text, main, accent, "\u25EF", "\\textcircled");
            const ligatures = {
              "--": true,
              "---": true,
              "``": true,
              "''": true
            };
            defineSymbol(symbols_text, main, textord, "\u2013", "--", true);
            defineSymbol(symbols_text, main, textord, "\u2013", "\\textendash");
            defineSymbol(symbols_text, main, textord, "\u2014", "---", true);
            defineSymbol(symbols_text, main, textord, "\u2014", "\\textemdash");
            defineSymbol(symbols_text, main, textord, "\u2018", "`", true);
            defineSymbol(symbols_text, main, textord, "\u2018", "\\textquoteleft");
            defineSymbol(symbols_text, main, textord, "\u2019", "'", true);
            defineSymbol(symbols_text, main, textord, "\u2019", "\\textquoteright");
            defineSymbol(symbols_text, main, textord, "\u201C", "``", true);
            defineSymbol(symbols_text, main, textord, "\u201C", "\\textquotedblleft");
            defineSymbol(symbols_text, main, textord, "\u201D", "''", true);
            defineSymbol(symbols_text, main, textord, "\u201D", "\\textquotedblright");
            defineSymbol(math, main, textord, "\xB0", "\\degree", true);
            defineSymbol(symbols_text, main, textord, "\xB0", "\\degree");
            defineSymbol(symbols_text, main, textord, "\xB0", "\\textdegree", true);
            defineSymbol(math, main, textord, "\xA3", "\\pounds");
            defineSymbol(math, main, textord, "\xA3", "\\mathsterling", true);
            defineSymbol(symbols_text, main, textord, "\xA3", "\\pounds");
            defineSymbol(symbols_text, main, textord, "\xA3", "\\textsterling", true);
            defineSymbol(math, ams, textord, "\u2720", "\\maltese");
            defineSymbol(symbols_text, ams, textord, "\u2720", "\\maltese");
            const mathTextSymbols = '0123456789/@."';
            for (let i = 0; i < mathTextSymbols.length; i++) {
              const ch = mathTextSymbols.charAt(i);
              defineSymbol(math, main, textord, ch, ch);
            }
            const textSymbols = '0123456789!@*()-=+";:?/.,';
            for (let i = 0; i < textSymbols.length; i++) {
              const ch = textSymbols.charAt(i);
              defineSymbol(symbols_text, main, textord, ch, ch);
            }
            const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
            for (let i = 0; i < letters.length; i++) {
              const ch = letters.charAt(i);
              defineSymbol(math, main, mathord, ch, ch);
              defineSymbol(symbols_text, main, textord, ch, ch);
            }
            defineSymbol(math, ams, textord, "C", "\u2102");
            defineSymbol(symbols_text, ams, textord, "C", "\u2102");
            defineSymbol(math, ams, textord, "H", "\u210D");
            defineSymbol(symbols_text, ams, textord, "H", "\u210D");
            defineSymbol(math, ams, textord, "N", "\u2115");
            defineSymbol(symbols_text, ams, textord, "N", "\u2115");
            defineSymbol(math, ams, textord, "P", "\u2119");
            defineSymbol(symbols_text, ams, textord, "P", "\u2119");
            defineSymbol(math, ams, textord, "Q", "\u211A");
            defineSymbol(symbols_text, ams, textord, "Q", "\u211A");
            defineSymbol(math, ams, textord, "R", "\u211D");
            defineSymbol(symbols_text, ams, textord, "R", "\u211D");
            defineSymbol(math, ams, textord, "Z", "\u2124");
            defineSymbol(symbols_text, ams, textord, "Z", "\u2124");
            defineSymbol(math, main, mathord, "h", "\u210E");
            defineSymbol(symbols_text, main, mathord, "h", "\u210E");
            let wideChar = "";
            for (let i = 0; i < letters.length; i++) {
              const ch = letters.charAt(i);
              wideChar = String.fromCharCode(55349, 56320 + i);
              defineSymbol(math, main, mathord, ch, wideChar);
              defineSymbol(symbols_text, main, textord, ch, wideChar);
              wideChar = String.fromCharCode(55349, 56372 + i);
              defineSymbol(math, main, mathord, ch, wideChar);
              defineSymbol(symbols_text, main, textord, ch, wideChar);
              wideChar = String.fromCharCode(55349, 56424 + i);
              defineSymbol(math, main, mathord, ch, wideChar);
              defineSymbol(symbols_text, main, textord, ch, wideChar);
              wideChar = String.fromCharCode(55349, 56580 + i);
              defineSymbol(math, main, mathord, ch, wideChar);
              defineSymbol(symbols_text, main, textord, ch, wideChar);
              wideChar = String.fromCharCode(55349, 56684 + i);
              defineSymbol(math, main, mathord, ch, wideChar);
              defineSymbol(symbols_text, main, textord, ch, wideChar);
              wideChar = String.fromCharCode(55349, 56736 + i);
              defineSymbol(math, main, mathord, ch, wideChar);
              defineSymbol(symbols_text, main, textord, ch, wideChar);
              wideChar = String.fromCharCode(55349, 56788 + i);
              defineSymbol(math, main, mathord, ch, wideChar);
              defineSymbol(symbols_text, main, textord, ch, wideChar);
              wideChar = String.fromCharCode(55349, 56840 + i);
              defineSymbol(math, main, mathord, ch, wideChar);
              defineSymbol(symbols_text, main, textord, ch, wideChar);
              wideChar = String.fromCharCode(55349, 56944 + i);
              defineSymbol(math, main, mathord, ch, wideChar);
              defineSymbol(symbols_text, main, textord, ch, wideChar);
              if (i < 26) {
                wideChar = String.fromCharCode(55349, 56632 + i);
                defineSymbol(math, main, mathord, ch, wideChar);
                defineSymbol(symbols_text, main, textord, ch, wideChar);
                wideChar = String.fromCharCode(55349, 56476 + i);
                defineSymbol(math, main, mathord, ch, wideChar);
                defineSymbol(symbols_text, main, textord, ch, wideChar);
              }
            }
            wideChar = String.fromCharCode(55349, 56668);
            defineSymbol(math, main, mathord, "k", wideChar);
            defineSymbol(symbols_text, main, textord, "k", wideChar);
            for (let i = 0; i < 10; i++) {
              const ch = i.toString();
              wideChar = String.fromCharCode(55349, 57294 + i);
              defineSymbol(math, main, mathord, ch, wideChar);
              defineSymbol(symbols_text, main, textord, ch, wideChar);
              wideChar = String.fromCharCode(55349, 57314 + i);
              defineSymbol(math, main, mathord, ch, wideChar);
              defineSymbol(symbols_text, main, textord, ch, wideChar);
              wideChar = String.fromCharCode(55349, 57324 + i);
              defineSymbol(math, main, mathord, ch, wideChar);
              defineSymbol(symbols_text, main, textord, ch, wideChar);
              wideChar = String.fromCharCode(55349, 57334 + i);
              defineSymbol(math, main, mathord, ch, wideChar);
              defineSymbol(symbols_text, main, textord, ch, wideChar);
            }
            const extraLatin = "\xD0\xDE\xFE";
            for (let i = 0; i < extraLatin.length; i++) {
              const ch = extraLatin.charAt(i);
              defineSymbol(math, main, mathord, ch, ch);
              defineSymbol(symbols_text, main, textord, ch, ch);
            }
            ;
            const wideLatinLetterData = [
              ["mathbf", "textbf", "Main-Bold"],
              // A-Z bold upright
              ["mathbf", "textbf", "Main-Bold"],
              // a-z bold upright
              ["mathnormal", "textit", "Math-Italic"],
              // A-Z italic
              ["mathnormal", "textit", "Math-Italic"],
              // a-z italic
              ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
              // A-Z bold italic
              ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
              // a-z bold italic
              // Map fancy A-Z letters to script, not calligraphic.
              // This aligns with unicode-math and math fonts (except Cambria Math).
              ["mathscr", "textscr", "Script-Regular"],
              // A-Z script
              ["", "", ""],
              // a-z script.  No font
              ["", "", ""],
              // A-Z bold script. No font
              ["", "", ""],
              // a-z bold script. No font
              ["mathfrak", "textfrak", "Fraktur-Regular"],
              // A-Z Fraktur
              ["mathfrak", "textfrak", "Fraktur-Regular"],
              // a-z Fraktur
              ["mathbb", "textbb", "AMS-Regular"],
              // A-Z double-struck
              ["mathbb", "textbb", "AMS-Regular"],
              // k double-struck
              // Note that we are using a bold font, but font metrics for regular Fraktur.
              ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
              // A-Z bold Fraktur
              ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
              // a-z bold Fraktur
              ["mathsf", "textsf", "SansSerif-Regular"],
              // A-Z sans-serif
              ["mathsf", "textsf", "SansSerif-Regular"],
              // a-z sans-serif
              ["mathboldsf", "textboldsf", "SansSerif-Bold"],
              // A-Z bold sans-serif
              ["mathboldsf", "textboldsf", "SansSerif-Bold"],
              // a-z bold sans-serif
              ["mathitsf", "textitsf", "SansSerif-Italic"],
              // A-Z italic sans-serif
              ["mathitsf", "textitsf", "SansSerif-Italic"],
              // a-z italic sans-serif
              ["", "", ""],
              // A-Z bold italic sans. No font
              ["", "", ""],
              // a-z bold italic sans. No font
              ["mathtt", "texttt", "Typewriter-Regular"],
              // A-Z monospace
              ["mathtt", "texttt", "Typewriter-Regular"]
              // a-z monospace
            ];
            const wideNumeralData = [
              ["mathbf", "textbf", "Main-Bold"],
              // 0-9 bold
              ["", "", ""],
              // 0-9 double-struck. No KaTeX font.
              ["mathsf", "textsf", "SansSerif-Regular"],
              // 0-9 sans-serif
              ["mathboldsf", "textboldsf", "SansSerif-Bold"],
              // 0-9 bold sans-serif
              ["mathtt", "texttt", "Typewriter-Regular"]
              // 0-9 monospace
            ];
            const wideCharacterFont = function(wideChar2, mode) {
              const H2 = wideChar2.charCodeAt(0);
              const L = wideChar2.charCodeAt(1);
              const codePoint = (H2 - 55296) * 1024 + (L - 56320) + 65536;
              const j2 = mode === "math" ? 0 : 1;
              if (119808 <= codePoint && codePoint < 120484) {
                const i = Math.floor((codePoint - 119808) / 26);
                return [wideLatinLetterData[i][2], wideLatinLetterData[i][j2]];
              } else if (120782 <= codePoint && codePoint <= 120831) {
                const i = Math.floor((codePoint - 120782) / 10);
                return [wideNumeralData[i][2], wideNumeralData[i][j2]];
              } else if (codePoint === 120485 || codePoint === 120486) {
                return [wideLatinLetterData[0][2], wideLatinLetterData[0][j2]];
              } else if (120486 < codePoint && codePoint < 120782) {
                return ["", ""];
              } else {
                throw new src_ParseError("Unsupported character: " + wideChar2);
              }
            };
            ;
            class DocumentFragment {
              // Never used; needed for satisfying interface.
              constructor(children3) {
                this.children = void 0;
                this.classes = void 0;
                this.height = void 0;
                this.depth = void 0;
                this.maxFontSize = void 0;
                this.style = void 0;
                this.children = children3;
                this.classes = [];
                this.height = 0;
                this.depth = 0;
                this.maxFontSize = 0;
                this.style = {};
              }
              hasClass(className) {
                return this.classes.includes(className);
              }
              /** Convert the fragment into a node. */
              toNode() {
                const frag = document.createDocumentFragment();
                for (let i = 0; i < this.children.length; i++) {
                  frag.appendChild(this.children[i].toNode());
                }
                return frag;
              }
              /** Convert the fragment into HTML markup. */
              toMarkup() {
                let markup = "";
                for (let i = 0; i < this.children.length; i++) {
                  markup += this.children[i].toMarkup();
                }
                return markup;
              }
              /**
               * Converts the math node into a string, similar to innerText. Applies to
               * MathDomNode's only.
               */
              toText() {
                const toText = (child) => child.toText();
                return this.children.map(toText).join("");
              }
            }
            ;
            const lookupSymbol = function(value, fontName, mode) {
              if (src_symbols[mode][value] && src_symbols[mode][value].replace) {
                value = src_symbols[mode][value].replace;
              }
              return {
                value,
                metrics: getCharacterMetrics(value, fontName, mode)
              };
            };
            const makeSymbol = function(value, fontName, mode, options, classes) {
              const lookup = lookupSymbol(value, fontName, mode);
              const metrics = lookup.metrics;
              value = lookup.value;
              let symbolNode;
              if (metrics) {
                let italic = metrics.italic;
                if (mode === "text" || options && options.font === "mathit") {
                  italic = 0;
                }
                symbolNode = new SymbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);
              } else {
                typeof console !== "undefined" && console.warn("No character metrics " + ("for '" + value + "' in style '" + fontName + "' and mode '" + mode + "'"));
                symbolNode = new SymbolNode(value, 0, 0, 0, 0, 0, classes);
              }
              if (options) {
                symbolNode.maxFontSize = options.sizeMultiplier;
                if (options.style.isTight()) {
                  symbolNode.classes.push("mtight");
                }
                const color2 = options.getColor();
                if (color2) {
                  symbolNode.style.color = color2;
                }
              }
              return symbolNode;
            };
            const mathsym = function(value, mode, options, classes) {
              if (classes === void 0) {
                classes = [];
              }
              if (options.font === "boldsymbol" && lookupSymbol(value, "Main-Bold", mode).metrics) {
                return makeSymbol(value, "Main-Bold", mode, options, classes.concat(["mathbf"]));
              } else if (value === "\\" || src_symbols[mode][value].font === "main") {
                return makeSymbol(value, "Main-Regular", mode, options, classes);
              } else {
                return makeSymbol(value, "AMS-Regular", mode, options, classes.concat(["amsrm"]));
              }
            };
            const boldsymbol = function(value, mode, options, classes, type2) {
              if (type2 !== "textord" && lookupSymbol(value, "Math-BoldItalic", mode).metrics) {
                return {
                  fontName: "Math-BoldItalic",
                  fontClass: "boldsymbol"
                };
              } else {
                return {
                  fontName: "Main-Bold",
                  fontClass: "mathbf"
                };
              }
            };
            const makeOrd = function(group, options, type2) {
              const mode = group.mode;
              const text3 = group.text;
              const classes = ["mord"];
              const isFont = mode === "math" || mode === "text" && options.font;
              const fontOrFamily = isFont ? options.font : options.fontFamily;
              let wideFontName = "";
              let wideFontClass = "";
              if (text3.charCodeAt(0) === 55349) {
                [wideFontName, wideFontClass] = wideCharacterFont(text3, mode);
              }
              if (wideFontName.length > 0) {
                return makeSymbol(text3, wideFontName, mode, options, classes.concat(wideFontClass));
              } else if (fontOrFamily) {
                let fontName;
                let fontClasses;
                if (fontOrFamily === "boldsymbol") {
                  const fontData = boldsymbol(text3, mode, options, classes, type2);
                  fontName = fontData.fontName;
                  fontClasses = [fontData.fontClass];
                } else if (isFont) {
                  fontName = fontMap[fontOrFamily].fontName;
                  fontClasses = [fontOrFamily];
                } else {
                  fontName = retrieveTextFontName(fontOrFamily, options.fontWeight, options.fontShape);
                  fontClasses = [fontOrFamily, options.fontWeight, options.fontShape];
                }
                if (lookupSymbol(text3, fontName, mode).metrics) {
                  return makeSymbol(text3, fontName, mode, options, classes.concat(fontClasses));
                } else if (ligatures.hasOwnProperty(text3) && fontName.slice(0, 10) === "Typewriter") {
                  const parts = [];
                  for (let i = 0; i < text3.length; i++) {
                    parts.push(makeSymbol(text3[i], fontName, mode, options, classes.concat(fontClasses)));
                  }
                  return makeFragment(parts);
                }
              }
              if (type2 === "mathord") {
                return makeSymbol(text3, "Math-Italic", mode, options, classes.concat(["mathnormal"]));
              } else if (type2 === "textord") {
                const font = src_symbols[mode][text3] && src_symbols[mode][text3].font;
                if (font === "ams") {
                  const fontName = retrieveTextFontName("amsrm", options.fontWeight, options.fontShape);
                  return makeSymbol(text3, fontName, mode, options, classes.concat("amsrm", options.fontWeight, options.fontShape));
                } else if (font === "main" || !font) {
                  const fontName = retrieveTextFontName("textrm", options.fontWeight, options.fontShape);
                  return makeSymbol(text3, fontName, mode, options, classes.concat(options.fontWeight, options.fontShape));
                } else {
                  const fontName = retrieveTextFontName(font, options.fontWeight, options.fontShape);
                  return makeSymbol(text3, fontName, mode, options, classes.concat(fontName, options.fontWeight, options.fontShape));
                }
              } else {
                throw new Error("unexpected type: " + type2 + " in makeOrd");
              }
            };
            const canCombine = (prev2, next2) => {
              if (createClass(prev2.classes) !== createClass(next2.classes) || prev2.skew !== next2.skew || prev2.maxFontSize !== next2.maxFontSize) {
                return false;
              }
              if (prev2.classes.length === 1) {
                const cls = prev2.classes[0];
                if (cls === "mbin" || cls === "mord") {
                  return false;
                }
              }
              for (const style in prev2.style) {
                if (prev2.style.hasOwnProperty(style) && prev2.style[style] !== next2.style[style]) {
                  return false;
                }
              }
              for (const style in next2.style) {
                if (next2.style.hasOwnProperty(style) && prev2.style[style] !== next2.style[style]) {
                  return false;
                }
              }
              return true;
            };
            const tryCombineChars = (chars) => {
              for (let i = 0; i < chars.length - 1; i++) {
                const prev2 = chars[i];
                const next2 = chars[i + 1];
                if (prev2 instanceof SymbolNode && next2 instanceof SymbolNode && canCombine(prev2, next2)) {
                  prev2.text += next2.text;
                  prev2.height = Math.max(prev2.height, next2.height);
                  prev2.depth = Math.max(prev2.depth, next2.depth);
                  prev2.italic = next2.italic;
                  chars.splice(i + 1, 1);
                  i--;
                }
              }
              return chars;
            };
            const sizeElementFromChildren = function(elem) {
              let height = 0;
              let depth = 0;
              let maxFontSize = 0;
              for (let i = 0; i < elem.children.length; i++) {
                const child = elem.children[i];
                if (child.height > height) {
                  height = child.height;
                }
                if (child.depth > depth) {
                  depth = child.depth;
                }
                if (child.maxFontSize > maxFontSize) {
                  maxFontSize = child.maxFontSize;
                }
              }
              elem.height = height;
              elem.depth = depth;
              elem.maxFontSize = maxFontSize;
            };
            const makeSpan = function(classes, children3, options, style) {
              const span = new Span(classes, children3, options, style);
              sizeElementFromChildren(span);
              return span;
            };
            const makeSvgSpan = (classes, children3, options, style) => new Span(classes, children3, options, style);
            const makeLineSpan = function(className, options, thickness) {
              const line = makeSpan([className], [], options);
              line.height = Math.max(thickness || options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
              line.style.borderBottomWidth = makeEm(line.height);
              line.maxFontSize = 1;
              return line;
            };
            const makeAnchor = function(href, classes, children3, options) {
              const anchor = new Anchor(href, classes, children3, options);
              sizeElementFromChildren(anchor);
              return anchor;
            };
            const makeFragment = function(children3) {
              const fragment = new DocumentFragment(children3);
              sizeElementFromChildren(fragment);
              return fragment;
            };
            const wrapFragment = function(group, options) {
              if (group instanceof DocumentFragment) {
                return makeSpan([], [group], options);
              }
              return group;
            };
            const getVListChildrenAndDepth = function(params) {
              if (params.positionType === "individualShift") {
                const oldChildren = params.children;
                const children3 = [oldChildren[0]];
                const depth2 = -oldChildren[0].shift - oldChildren[0].elem.depth;
                let currPos = depth2;
                for (let i = 1; i < oldChildren.length; i++) {
                  const diff = -oldChildren[i].shift - currPos - oldChildren[i].elem.depth;
                  const size = diff - (oldChildren[i - 1].elem.height + oldChildren[i - 1].elem.depth);
                  currPos = currPos + diff;
                  children3.push({
                    type: "kern",
                    size
                  });
                  children3.push(oldChildren[i]);
                }
                return {
                  children: children3,
                  depth: depth2
                };
              }
              let depth;
              if (params.positionType === "top") {
                let bottom = params.positionData;
                for (let i = 0; i < params.children.length; i++) {
                  const child = params.children[i];
                  bottom -= child.type === "kern" ? child.size : child.elem.height + child.elem.depth;
                }
                depth = bottom;
              } else if (params.positionType === "bottom") {
                depth = -params.positionData;
              } else {
                const firstChild = params.children[0];
                if (firstChild.type !== "elem") {
                  throw new Error('First child must have type "elem".');
                }
                if (params.positionType === "shift") {
                  depth = -firstChild.elem.depth - params.positionData;
                } else if (params.positionType === "firstBaseline") {
                  depth = -firstChild.elem.depth;
                } else {
                  throw new Error("Invalid positionType " + params.positionType + ".");
                }
              }
              return {
                children: params.children,
                depth
              };
            };
            const makeVList = function(params, options) {
              const {
                children: children3,
                depth
              } = getVListChildrenAndDepth(params);
              let pstrutSize = 0;
              for (let i = 0; i < children3.length; i++) {
                const child = children3[i];
                if (child.type === "elem") {
                  const elem = child.elem;
                  pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);
                }
              }
              pstrutSize += 2;
              const pstrut = makeSpan(["pstrut"], []);
              pstrut.style.height = makeEm(pstrutSize);
              const realChildren = [];
              let minPos = depth;
              let maxPos = depth;
              let currPos = depth;
              for (let i = 0; i < children3.length; i++) {
                const child = children3[i];
                if (child.type === "kern") {
                  currPos += child.size;
                } else {
                  const elem = child.elem;
                  const classes = child.wrapperClasses || [];
                  const style = child.wrapperStyle || {};
                  const childWrap = makeSpan(classes, [pstrut, elem], void 0, style);
                  childWrap.style.top = makeEm(-pstrutSize - currPos - elem.depth);
                  if (child.marginLeft) {
                    childWrap.style.marginLeft = child.marginLeft;
                  }
                  if (child.marginRight) {
                    childWrap.style.marginRight = child.marginRight;
                  }
                  realChildren.push(childWrap);
                  currPos += elem.height + elem.depth;
                }
                minPos = Math.min(minPos, currPos);
                maxPos = Math.max(maxPos, currPos);
              }
              const vlist = makeSpan(["vlist"], realChildren);
              vlist.style.height = makeEm(maxPos);
              let rows;
              if (minPos < 0) {
                const emptySpan = makeSpan([], []);
                const depthStrut = makeSpan(["vlist"], [emptySpan]);
                depthStrut.style.height = makeEm(-minPos);
                const topStrut = makeSpan(["vlist-s"], [new SymbolNode("\u200B")]);
                rows = [makeSpan(["vlist-r"], [vlist, topStrut]), makeSpan(["vlist-r"], [depthStrut])];
              } else {
                rows = [makeSpan(["vlist-r"], [vlist])];
              }
              const vtable = makeSpan(["vlist-t"], rows);
              if (rows.length === 2) {
                vtable.classes.push("vlist-t2");
              }
              vtable.height = maxPos;
              vtable.depth = -minPos;
              return vtable;
            };
            const makeGlue = (measurement, options) => {
              const rule = makeSpan(["mspace"], [], options);
              const size = calculateSize(measurement, options);
              rule.style.marginRight = makeEm(size);
              return rule;
            };
            const retrieveTextFontName = function(fontFamily, fontWeight, fontShape) {
              let baseFontName = "";
              switch (fontFamily) {
                case "amsrm":
                  baseFontName = "AMS";
                  break;
                case "textrm":
                  baseFontName = "Main";
                  break;
                case "textsf":
                  baseFontName = "SansSerif";
                  break;
                case "texttt":
                  baseFontName = "Typewriter";
                  break;
                default:
                  baseFontName = fontFamily;
              }
              let fontStylesName;
              if (fontWeight === "textbf" && fontShape === "textit") {
                fontStylesName = "BoldItalic";
              } else if (fontWeight === "textbf") {
                fontStylesName = "Bold";
              } else if (fontWeight === "textit") {
                fontStylesName = "Italic";
              } else {
                fontStylesName = "Regular";
              }
              return baseFontName + "-" + fontStylesName;
            };
            const fontMap = {
              // styles
              "mathbf": {
                variant: "bold",
                fontName: "Main-Bold"
              },
              "mathrm": {
                variant: "normal",
                fontName: "Main-Regular"
              },
              "textit": {
                variant: "italic",
                fontName: "Main-Italic"
              },
              "mathit": {
                variant: "italic",
                fontName: "Main-Italic"
              },
              "mathnormal": {
                variant: "italic",
                fontName: "Math-Italic"
              },
              "mathsfit": {
                variant: "sans-serif-italic",
                fontName: "SansSerif-Italic"
              },
              // "boldsymbol" is missing because they require the use of multiple fonts:
              // Math-BoldItalic and Main-Bold.  This is handled by a special case in
              // makeOrd which ends up calling boldsymbol.
              // families
              "mathbb": {
                variant: "double-struck",
                fontName: "AMS-Regular"
              },
              "mathcal": {
                variant: "script",
                fontName: "Caligraphic-Regular"
              },
              "mathfrak": {
                variant: "fraktur",
                fontName: "Fraktur-Regular"
              },
              "mathscr": {
                variant: "script",
                fontName: "Script-Regular"
              },
              "mathsf": {
                variant: "sans-serif",
                fontName: "SansSerif-Regular"
              },
              "mathtt": {
                variant: "monospace",
                fontName: "Typewriter-Regular"
              }
            };
            const svgData = {
              //   path, width, height
              vec: ["vec", 0.471, 0.714],
              // values from the font glyph
              oiintSize1: ["oiintSize1", 0.957, 0.499],
              // oval to overlay the integrand
              oiintSize2: ["oiintSize2", 1.472, 0.659],
              oiiintSize1: ["oiiintSize1", 1.304, 0.499],
              oiiintSize2: ["oiiintSize2", 1.98, 0.659]
            };
            const staticSvg = function(value, options) {
              const [pathName, width, height] = svgData[value];
              const path3 = new PathNode(pathName);
              const svgNode2 = new SvgNode([path3], {
                "width": makeEm(width),
                "height": makeEm(height),
                // Override CSS rule `.katex svg { width: 100% }`
                "style": "width:" + makeEm(width),
                "viewBox": "0 0 " + 1e3 * width + " " + 1e3 * height,
                "preserveAspectRatio": "xMinYMin"
              });
              const span = makeSvgSpan(["overlay"], [svgNode2], options);
              span.height = height;
              span.style.height = makeEm(height);
              span.style.width = makeEm(width);
              return span;
            };
            var buildCommon = {
              fontMap,
              makeSymbol,
              mathsym,
              makeSpan,
              makeSvgSpan,
              makeLineSpan,
              makeAnchor,
              makeFragment,
              wrapFragment,
              makeVList,
              makeOrd,
              makeGlue,
              staticSvg,
              svgData,
              tryCombineChars
            };
            ;
            const thinspace = {
              number: 3,
              unit: "mu"
            };
            const mediumspace = {
              number: 4,
              unit: "mu"
            };
            const thickspace = {
              number: 5,
              unit: "mu"
            };
            const spacings = {
              mord: {
                mop: thinspace,
                mbin: mediumspace,
                mrel: thickspace,
                minner: thinspace
              },
              mop: {
                mord: thinspace,
                mop: thinspace,
                mrel: thickspace,
                minner: thinspace
              },
              mbin: {
                mord: mediumspace,
                mop: mediumspace,
                mopen: mediumspace,
                minner: mediumspace
              },
              mrel: {
                mord: thickspace,
                mop: thickspace,
                mopen: thickspace,
                minner: thickspace
              },
              mopen: {},
              mclose: {
                mop: thinspace,
                mbin: mediumspace,
                mrel: thickspace,
                minner: thinspace
              },
              mpunct: {
                mord: thinspace,
                mop: thinspace,
                mrel: thickspace,
                mopen: thinspace,
                mclose: thinspace,
                mpunct: thinspace,
                minner: thinspace
              },
              minner: {
                mord: thinspace,
                mop: thinspace,
                mbin: mediumspace,
                mrel: thickspace,
                mopen: thinspace,
                mpunct: thinspace,
                minner: thinspace
              }
            };
            const tightSpacings = {
              mord: {
                mop: thinspace
              },
              mop: {
                mord: thinspace,
                mop: thinspace
              },
              mbin: {},
              mrel: {},
              mopen: {},
              mclose: {
                mop: thinspace
              },
              mpunct: {},
              minner: {
                mop: thinspace
              }
            };
            ;
            const _functions = {};
            const _htmlGroupBuilders = {};
            const _mathmlGroupBuilders = {};
            function defineFunction(_ref) {
              let {
                type: type2,
                names,
                props,
                handler,
                htmlBuilder: htmlBuilder2,
                mathmlBuilder: mathmlBuilder2
              } = _ref;
              const data2 = {
                type: type2,
                numArgs: props.numArgs,
                argTypes: props.argTypes,
                allowedInArgument: !!props.allowedInArgument,
                allowedInText: !!props.allowedInText,
                allowedInMath: props.allowedInMath === void 0 ? true : props.allowedInMath,
                numOptionalArgs: props.numOptionalArgs || 0,
                infix: !!props.infix,
                primitive: !!props.primitive,
                handler
              };
              for (let i = 0; i < names.length; ++i) {
                _functions[names[i]] = data2;
              }
              if (type2) {
                if (htmlBuilder2) {
                  _htmlGroupBuilders[type2] = htmlBuilder2;
                }
                if (mathmlBuilder2) {
                  _mathmlGroupBuilders[type2] = mathmlBuilder2;
                }
              }
            }
            function defineFunctionBuilders(_ref2) {
              let {
                type: type2,
                htmlBuilder: htmlBuilder2,
                mathmlBuilder: mathmlBuilder2
              } = _ref2;
              defineFunction({
                type: type2,
                names: [],
                props: {
                  numArgs: 0
                },
                handler() {
                  throw new Error("Should never be called.");
                },
                htmlBuilder: htmlBuilder2,
                mathmlBuilder: mathmlBuilder2
              });
            }
            const normalizeArgument = function(arg) {
              return arg.type === "ordgroup" && arg.body.length === 1 ? arg.body[0] : arg;
            };
            const ordargument = function(arg) {
              return arg.type === "ordgroup" ? arg.body : [arg];
            };
            ;
            const buildHTML_makeSpan = buildCommon.makeSpan;
            const binLeftCanceller = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"];
            const binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"];
            const styleMap = {
              "display": src_Style.DISPLAY,
              "text": src_Style.TEXT,
              "script": src_Style.SCRIPT,
              "scriptscript": src_Style.SCRIPTSCRIPT
            };
            const DomEnum = {
              mord: "mord",
              mop: "mop",
              mbin: "mbin",
              mrel: "mrel",
              mopen: "mopen",
              mclose: "mclose",
              mpunct: "mpunct",
              minner: "minner"
            };
            const buildExpression = function(expression, options, isRealGroup, surrounding) {
              if (surrounding === void 0) {
                surrounding = [null, null];
              }
              const groups = [];
              for (let i = 0; i < expression.length; i++) {
                const output = buildGroup(expression[i], options);
                if (output instanceof DocumentFragment) {
                  const children3 = output.children;
                  groups.push(...children3);
                } else {
                  groups.push(output);
                }
              }
              buildCommon.tryCombineChars(groups);
              if (!isRealGroup) {
                return groups;
              }
              let glueOptions = options;
              if (expression.length === 1) {
                const node = expression[0];
                if (node.type === "sizing") {
                  glueOptions = options.havingSize(node.size);
                } else if (node.type === "styling") {
                  glueOptions = options.havingStyle(styleMap[node.style]);
                }
              }
              const dummyPrev = buildHTML_makeSpan([surrounding[0] || "leftmost"], [], options);
              const dummyNext = buildHTML_makeSpan([surrounding[1] || "rightmost"], [], options);
              const isRoot = isRealGroup === "root";
              traverseNonSpaceNodes(groups, (node, prev2) => {
                const prevType = prev2.classes[0];
                const type2 = node.classes[0];
                if (prevType === "mbin" && binRightCanceller.includes(type2)) {
                  prev2.classes[0] = "mord";
                } else if (type2 === "mbin" && binLeftCanceller.includes(prevType)) {
                  node.classes[0] = "mord";
                }
              }, {
                node: dummyPrev
              }, dummyNext, isRoot);
              traverseNonSpaceNodes(groups, (node, prev2) => {
                const prevType = getTypeOfDomTree(prev2);
                const type2 = getTypeOfDomTree(node);
                const space = prevType && type2 ? node.hasClass("mtight") ? tightSpacings[prevType][type2] : spacings[prevType][type2] : null;
                if (space) {
                  return buildCommon.makeGlue(space, glueOptions);
                }
              }, {
                node: dummyPrev
              }, dummyNext, isRoot);
              return groups;
            };
            const traverseNonSpaceNodes = function(nodes, callback, prev2, next2, isRoot) {
              if (next2) {
                nodes.push(next2);
              }
              let i = 0;
              for (; i < nodes.length; i++) {
                const node = nodes[i];
                const partialGroup = checkPartialGroup(node);
                if (partialGroup) {
                  traverseNonSpaceNodes(partialGroup.children, callback, prev2, null, isRoot);
                  continue;
                }
                const nonspace = !node.hasClass("mspace");
                if (nonspace) {
                  const result = callback(node, prev2.node);
                  if (result) {
                    if (prev2.insertAfter) {
                      prev2.insertAfter(result);
                    } else {
                      nodes.unshift(result);
                      i++;
                    }
                  }
                }
                if (nonspace) {
                  prev2.node = node;
                } else if (isRoot && node.hasClass("newline")) {
                  prev2.node = buildHTML_makeSpan(["leftmost"]);
                }
                prev2.insertAfter = /* @__PURE__ */ ((index2) => (n) => {
                  nodes.splice(index2 + 1, 0, n);
                  i++;
                })(i);
              }
              if (next2) {
                nodes.pop();
              }
            };
            const checkPartialGroup = function(node) {
              if (node instanceof DocumentFragment || node instanceof Anchor || node instanceof Span && node.hasClass("enclosing")) {
                return node;
              }
              return null;
            };
            const getOutermostNode = function(node, side) {
              const partialGroup = checkPartialGroup(node);
              if (partialGroup) {
                const children3 = partialGroup.children;
                if (children3.length) {
                  if (side === "right") {
                    return getOutermostNode(children3[children3.length - 1], "right");
                  } else if (side === "left") {
                    return getOutermostNode(children3[0], "left");
                  }
                }
              }
              return node;
            };
            const getTypeOfDomTree = function(node, side) {
              if (!node) {
                return null;
              }
              if (side) {
                node = getOutermostNode(node, side);
              }
              return DomEnum[node.classes[0]] || null;
            };
            const makeNullDelimiter = function(options, classes) {
              const moreClasses = ["nulldelimiter"].concat(options.baseSizingClasses());
              return buildHTML_makeSpan(classes.concat(moreClasses));
            };
            const buildGroup = function(group, options, baseOptions) {
              if (!group) {
                return buildHTML_makeSpan();
              }
              if (_htmlGroupBuilders[group.type]) {
                let groupNode = _htmlGroupBuilders[group.type](group, options);
                if (baseOptions && options.size !== baseOptions.size) {
                  groupNode = buildHTML_makeSpan(options.sizingClasses(baseOptions), [groupNode], options);
                  const multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
                  groupNode.height *= multiplier;
                  groupNode.depth *= multiplier;
                }
                return groupNode;
              } else {
                throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
              }
            };
            function buildHTMLUnbreakable(children3, options) {
              const body = buildHTML_makeSpan(["base"], children3, options);
              const strut = buildHTML_makeSpan(["strut"]);
              strut.style.height = makeEm(body.height + body.depth);
              if (body.depth) {
                strut.style.verticalAlign = makeEm(-body.depth);
              }
              body.children.unshift(strut);
              return body;
            }
            function buildHTML(tree, options) {
              let tag = null;
              if (tree.length === 1 && tree[0].type === "tag") {
                tag = tree[0].tag;
                tree = tree[0].body;
              }
              const expression = buildExpression(tree, options, "root");
              let eqnNum;
              if (expression.length === 2 && expression[1].hasClass("tag")) {
                eqnNum = expression.pop();
              }
              const children3 = [];
              let parts = [];
              for (let i = 0; i < expression.length; i++) {
                parts.push(expression[i]);
                if (expression[i].hasClass("mbin") || expression[i].hasClass("mrel") || expression[i].hasClass("allowbreak")) {
                  let nobreak = false;
                  while (i < expression.length - 1 && expression[i + 1].hasClass("mspace") && !expression[i + 1].hasClass("newline")) {
                    i++;
                    parts.push(expression[i]);
                    if (expression[i].hasClass("nobreak")) {
                      nobreak = true;
                    }
                  }
                  if (!nobreak) {
                    children3.push(buildHTMLUnbreakable(parts, options));
                    parts = [];
                  }
                } else if (expression[i].hasClass("newline")) {
                  parts.pop();
                  if (parts.length > 0) {
                    children3.push(buildHTMLUnbreakable(parts, options));
                    parts = [];
                  }
                  children3.push(expression[i]);
                }
              }
              if (parts.length > 0) {
                children3.push(buildHTMLUnbreakable(parts, options));
              }
              let tagChild;
              if (tag) {
                tagChild = buildHTMLUnbreakable(buildExpression(tag, options, true));
                tagChild.classes = ["tag"];
                children3.push(tagChild);
              } else if (eqnNum) {
                children3.push(eqnNum);
              }
              const htmlNode = buildHTML_makeSpan(["katex-html"], children3);
              htmlNode.setAttribute("aria-hidden", "true");
              if (tagChild) {
                const strut = tagChild.children[0];
                strut.style.height = makeEm(htmlNode.height + htmlNode.depth);
                if (htmlNode.depth) {
                  strut.style.verticalAlign = makeEm(-htmlNode.depth);
                }
              }
              return htmlNode;
            }
            ;
            function newDocumentFragment(children3) {
              return new DocumentFragment(children3);
            }
            class MathNode {
              constructor(type2, children3, classes) {
                this.type = void 0;
                this.attributes = void 0;
                this.children = void 0;
                this.classes = void 0;
                this.type = type2;
                this.attributes = {};
                this.children = children3 || [];
                this.classes = classes || [];
              }
              /**
               * Sets an attribute on a MathML node. MathML depends on attributes to convey a
               * semantic content, so this is used heavily.
               */
              setAttribute(name2, value) {
                this.attributes[name2] = value;
              }
              /**
               * Gets an attribute on a MathML node.
               */
              getAttribute(name2) {
                return this.attributes[name2];
              }
              /**
               * Converts the math node into a MathML-namespaced DOM element.
               */
              toNode() {
                const node = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
                for (const attr2 in this.attributes) {
                  if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
                    node.setAttribute(attr2, this.attributes[attr2]);
                  }
                }
                if (this.classes.length > 0) {
                  node.className = createClass(this.classes);
                }
                for (let i = 0; i < this.children.length; i++) {
                  if (this.children[i] instanceof TextNode && this.children[i + 1] instanceof TextNode) {
                    let text3 = this.children[i].toText() + this.children[++i].toText();
                    while (this.children[i + 1] instanceof TextNode) {
                      text3 += this.children[++i].toText();
                    }
                    node.appendChild(new TextNode(text3).toNode());
                  } else {
                    node.appendChild(this.children[i].toNode());
                  }
                }
                return node;
              }
              /**
               * Converts the math node into an HTML markup string.
               */
              toMarkup() {
                let markup = "<" + this.type;
                for (const attr2 in this.attributes) {
                  if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
                    markup += " " + attr2 + '="';
                    markup += utils.escape(this.attributes[attr2]);
                    markup += '"';
                  }
                }
                if (this.classes.length > 0) {
                  markup += ' class ="' + utils.escape(createClass(this.classes)) + '"';
                }
                markup += ">";
                for (let i = 0; i < this.children.length; i++) {
                  markup += this.children[i].toMarkup();
                }
                markup += "</" + this.type + ">";
                return markup;
              }
              /**
               * Converts the math node into a string, similar to innerText, but escaped.
               */
              toText() {
                return this.children.map((child) => child.toText()).join("");
              }
            }
            class TextNode {
              constructor(text3) {
                this.text = void 0;
                this.text = text3;
              }
              /**
               * Converts the text node into a DOM text node.
               */
              toNode() {
                return document.createTextNode(this.text);
              }
              /**
               * Converts the text node into escaped HTML markup
               * (representing the text itself).
               */
              toMarkup() {
                return utils.escape(this.toText());
              }
              /**
               * Converts the text node into a string
               * (representing the text itself).
               */
              toText() {
                return this.text;
              }
            }
            class SpaceNode {
              /**
               * Create a Space node with width given in CSS ems.
               */
              constructor(width) {
                this.width = void 0;
                this.character = void 0;
                this.width = width;
                if (width >= 0.05555 && width <= 0.05556) {
                  this.character = "\u200A";
                } else if (width >= 0.1666 && width <= 0.1667) {
                  this.character = "\u2009";
                } else if (width >= 0.2222 && width <= 0.2223) {
                  this.character = "\u2005";
                } else if (width >= 0.2777 && width <= 0.2778) {
                  this.character = "\u2005\u200A";
                } else if (width >= -0.05556 && width <= -0.05555) {
                  this.character = "\u200A\u2063";
                } else if (width >= -0.1667 && width <= -0.1666) {
                  this.character = "\u2009\u2063";
                } else if (width >= -0.2223 && width <= -0.2222) {
                  this.character = "\u205F\u2063";
                } else if (width >= -0.2778 && width <= -0.2777) {
                  this.character = "\u2005\u2063";
                } else {
                  this.character = null;
                }
              }
              /**
               * Converts the math node into a MathML-namespaced DOM element.
               */
              toNode() {
                if (this.character) {
                  return document.createTextNode(this.character);
                } else {
                  const node = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
                  node.setAttribute("width", makeEm(this.width));
                  return node;
                }
              }
              /**
               * Converts the math node into an HTML markup string.
               */
              toMarkup() {
                if (this.character) {
                  return "<mtext>" + this.character + "</mtext>";
                } else {
                  return '<mspace width="' + makeEm(this.width) + '"/>';
                }
              }
              /**
               * Converts the math node into a string, similar to innerText.
               */
              toText() {
                if (this.character) {
                  return this.character;
                } else {
                  return " ";
                }
              }
            }
            var mathMLTree = {
              MathNode,
              TextNode,
              SpaceNode,
              newDocumentFragment
            };
            ;
            const makeText = function(text3, mode, options) {
              if (src_symbols[mode][text3] && src_symbols[mode][text3].replace && text3.charCodeAt(0) !== 55349 && !(ligatures.hasOwnProperty(text3) && options && (options.fontFamily && options.fontFamily.slice(4, 6) === "tt" || options.font && options.font.slice(4, 6) === "tt"))) {
                text3 = src_symbols[mode][text3].replace;
              }
              return new mathMLTree.TextNode(text3);
            };
            const makeRow = function(body) {
              if (body.length === 1) {
                return body[0];
              } else {
                return new mathMLTree.MathNode("mrow", body);
              }
            };
            const getVariant = function(group, options) {
              if (options.fontFamily === "texttt") {
                return "monospace";
              } else if (options.fontFamily === "textsf") {
                if (options.fontShape === "textit" && options.fontWeight === "textbf") {
                  return "sans-serif-bold-italic";
                } else if (options.fontShape === "textit") {
                  return "sans-serif-italic";
                } else if (options.fontWeight === "textbf") {
                  return "bold-sans-serif";
                } else {
                  return "sans-serif";
                }
              } else if (options.fontShape === "textit" && options.fontWeight === "textbf") {
                return "bold-italic";
              } else if (options.fontShape === "textit") {
                return "italic";
              } else if (options.fontWeight === "textbf") {
                return "bold";
              }
              const font = options.font;
              if (!font || font === "mathnormal") {
                return null;
              }
              const mode = group.mode;
              if (font === "mathit") {
                return "italic";
              } else if (font === "boldsymbol") {
                return group.type === "textord" ? "bold" : "bold-italic";
              } else if (font === "mathbf") {
                return "bold";
              } else if (font === "mathbb") {
                return "double-struck";
              } else if (font === "mathsfit") {
                return "sans-serif-italic";
              } else if (font === "mathfrak") {
                return "fraktur";
              } else if (font === "mathscr" || font === "mathcal") {
                return "script";
              } else if (font === "mathsf") {
                return "sans-serif";
              } else if (font === "mathtt") {
                return "monospace";
              }
              let text3 = group.text;
              if (["\\imath", "\\jmath"].includes(text3)) {
                return null;
              }
              if (src_symbols[mode][text3] && src_symbols[mode][text3].replace) {
                text3 = src_symbols[mode][text3].replace;
              }
              const fontName = buildCommon.fontMap[font].fontName;
              if (getCharacterMetrics(text3, fontName, mode)) {
                return buildCommon.fontMap[font].variant;
              }
              return null;
            };
            function isNumberPunctuation(group) {
              if (!group) {
                return false;
              }
              if (group.type === "mi" && group.children.length === 1) {
                const child = group.children[0];
                return child instanceof TextNode && child.text === ".";
              } else if (group.type === "mo" && group.children.length === 1 && group.getAttribute("separator") === "true" && group.getAttribute("lspace") === "0em" && group.getAttribute("rspace") === "0em") {
                const child = group.children[0];
                return child instanceof TextNode && child.text === ",";
              } else {
                return false;
              }
            }
            const buildMathML_buildExpression = function(expression, options, isOrdgroup) {
              if (expression.length === 1) {
                const group = buildMathML_buildGroup(expression[0], options);
                if (isOrdgroup && group instanceof MathNode && group.type === "mo") {
                  group.setAttribute("lspace", "0em");
                  group.setAttribute("rspace", "0em");
                }
                return [group];
              }
              const groups = [];
              let lastGroup;
              for (let i = 0; i < expression.length; i++) {
                const group = buildMathML_buildGroup(expression[i], options);
                if (group instanceof MathNode && lastGroup instanceof MathNode) {
                  if (group.type === "mtext" && lastGroup.type === "mtext" && group.getAttribute("mathvariant") === lastGroup.getAttribute("mathvariant")) {
                    lastGroup.children.push(...group.children);
                    continue;
                  } else if (group.type === "mn" && lastGroup.type === "mn") {
                    lastGroup.children.push(...group.children);
                    continue;
                  } else if (isNumberPunctuation(group) && lastGroup.type === "mn") {
                    lastGroup.children.push(...group.children);
                    continue;
                  } else if (group.type === "mn" && isNumberPunctuation(lastGroup)) {
                    group.children = [...lastGroup.children, ...group.children];
                    groups.pop();
                  } else if ((group.type === "msup" || group.type === "msub") && group.children.length >= 1 && (lastGroup.type === "mn" || isNumberPunctuation(lastGroup))) {
                    const base2 = group.children[0];
                    if (base2 instanceof MathNode && base2.type === "mn") {
                      base2.children = [...lastGroup.children, ...base2.children];
                      groups.pop();
                    }
                  } else if (lastGroup.type === "mi" && lastGroup.children.length === 1) {
                    const lastChild = lastGroup.children[0];
                    if (lastChild instanceof TextNode && lastChild.text === "\u0338" && (group.type === "mo" || group.type === "mi" || group.type === "mn")) {
                      const child = group.children[0];
                      if (child instanceof TextNode && child.text.length > 0) {
                        child.text = child.text.slice(0, 1) + "\u0338" + child.text.slice(1);
                        groups.pop();
                      }
                    }
                  }
                }
                groups.push(group);
                lastGroup = group;
              }
              return groups;
            };
            const buildExpressionRow = function(expression, options, isOrdgroup) {
              return makeRow(buildMathML_buildExpression(expression, options, isOrdgroup));
            };
            const buildMathML_buildGroup = function(group, options) {
              if (!group) {
                return new mathMLTree.MathNode("mrow");
              }
              if (_mathmlGroupBuilders[group.type]) {
                const result = _mathmlGroupBuilders[group.type](group, options);
                return result;
              } else {
                throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
              }
            };
            function buildMathML(tree, texExpression, options, isDisplayMode, forMathmlOnly) {
              const expression = buildMathML_buildExpression(tree, options);
              let wrapper;
              if (expression.length === 1 && expression[0] instanceof MathNode && ["mrow", "mtable"].includes(expression[0].type)) {
                wrapper = expression[0];
              } else {
                wrapper = new mathMLTree.MathNode("mrow", expression);
              }
              const annotation = new mathMLTree.MathNode("annotation", [new mathMLTree.TextNode(texExpression)]);
              annotation.setAttribute("encoding", "application/x-tex");
              const semantics = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
              const math2 = new mathMLTree.MathNode("math", [semantics]);
              math2.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");
              if (isDisplayMode) {
                math2.setAttribute("display", "block");
              }
              const wrapperClass = forMathmlOnly ? "katex" : "katex-mathml";
              return buildCommon.makeSpan([wrapperClass], [math2]);
            }
            ;
            const optionsFromSettings = function(settings) {
              return new src_Options({
                style: settings.displayMode ? src_Style.DISPLAY : src_Style.TEXT,
                maxSize: settings.maxSize,
                minRuleThickness: settings.minRuleThickness
              });
            };
            const displayWrap = function(node, settings) {
              if (settings.displayMode) {
                const classes = ["katex-display"];
                if (settings.leqno) {
                  classes.push("leqno");
                }
                if (settings.fleqn) {
                  classes.push("fleqn");
                }
                node = buildCommon.makeSpan(classes, [node]);
              }
              return node;
            };
            const buildTree2 = function(tree, expression, settings) {
              const options = optionsFromSettings(settings);
              let katexNode;
              if (settings.output === "mathml") {
                return buildMathML(tree, expression, options, settings.displayMode, true);
              } else if (settings.output === "html") {
                const htmlNode = buildHTML(tree, options);
                katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
              } else {
                const mathMLNode = buildMathML(tree, expression, options, settings.displayMode, false);
                const htmlNode = buildHTML(tree, options);
                katexNode = buildCommon.makeSpan(["katex"], [mathMLNode, htmlNode]);
              }
              return displayWrap(katexNode, settings);
            };
            const buildHTMLTree = function(tree, expression, settings) {
              const options = optionsFromSettings(settings);
              const htmlNode = buildHTML(tree, options);
              const katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
              return displayWrap(katexNode, settings);
            };
            var src_buildTree = (
              /* unused pure expression or super */
              null
            );
            ;
            const stretchyCodePoint = {
              widehat: "^",
              widecheck: "\u02C7",
              widetilde: "~",
              utilde: "~",
              overleftarrow: "\u2190",
              underleftarrow: "\u2190",
              xleftarrow: "\u2190",
              overrightarrow: "\u2192",
              underrightarrow: "\u2192",
              xrightarrow: "\u2192",
              underbrace: "\u23DF",
              overbrace: "\u23DE",
              overgroup: "\u23E0",
              undergroup: "\u23E1",
              overleftrightarrow: "\u2194",
              underleftrightarrow: "\u2194",
              xleftrightarrow: "\u2194",
              Overrightarrow: "\u21D2",
              xRightarrow: "\u21D2",
              overleftharpoon: "\u21BC",
              xleftharpoonup: "\u21BC",
              overrightharpoon: "\u21C0",
              xrightharpoonup: "\u21C0",
              xLeftarrow: "\u21D0",
              xLeftrightarrow: "\u21D4",
              xhookleftarrow: "\u21A9",
              xhookrightarrow: "\u21AA",
              xmapsto: "\u21A6",
              xrightharpoondown: "\u21C1",
              xleftharpoondown: "\u21BD",
              xrightleftharpoons: "\u21CC",
              xleftrightharpoons: "\u21CB",
              xtwoheadleftarrow: "\u219E",
              xtwoheadrightarrow: "\u21A0",
              xlongequal: "=",
              xtofrom: "\u21C4",
              xrightleftarrows: "\u21C4",
              xrightequilibrium: "\u21CC",
              // Not a perfect match.
              xleftequilibrium: "\u21CB",
              // None better available.
              "\\cdrightarrow": "\u2192",
              "\\cdleftarrow": "\u2190",
              "\\cdlongequal": "="
            };
            const mathMLnode = function(label) {
              const node = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[label.replace(/^\\/, "")])]);
              node.setAttribute("stretchy", "true");
              return node;
            };
            const katexImagesData = {
              //   path(s), minWidth, height, align
              overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
              overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
              underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
              underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
              xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
              "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
              // CD minwwidth2.5pc
              xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
              "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
              Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
              xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
              xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
              overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
              xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
              xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
              overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
              xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
              xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
              xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
              "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
              xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
              xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
              overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
              overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
              underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
              underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
              xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
              xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
              xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
              xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
              xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
              xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
              overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
              underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
              overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
              undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
              xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
              xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
              // The next three arrows are from the mhchem package.
              // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
              // document as \xrightarrow or \xrightleftharpoons. Those have
              // min-length = 1.75em, so we set min-length on these next three to match.
              xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
              xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
              xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
            };
            const groupLength = function(arg) {
              if (arg.type === "ordgroup") {
                return arg.body.length;
              } else {
                return 1;
              }
            };
            const svgSpan = function(group, options) {
              function buildSvgSpan_() {
                let viewBoxWidth = 4e5;
                const label = group.label.slice(1);
                if (["widehat", "widecheck", "widetilde", "utilde"].includes(label)) {
                  const grp = group;
                  const numChars = groupLength(grp.base);
                  let viewBoxHeight;
                  let pathName;
                  let height2;
                  if (numChars > 5) {
                    if (label === "widehat" || label === "widecheck") {
                      viewBoxHeight = 420;
                      viewBoxWidth = 2364;
                      height2 = 0.42;
                      pathName = label + "4";
                    } else {
                      viewBoxHeight = 312;
                      viewBoxWidth = 2340;
                      height2 = 0.34;
                      pathName = "tilde4";
                    }
                  } else {
                    const imgIndex = [1, 1, 2, 2, 3, 3][numChars];
                    if (label === "widehat" || label === "widecheck") {
                      viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];
                      viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];
                      height2 = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];
                      pathName = label + imgIndex;
                    } else {
                      viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];
                      viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];
                      height2 = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];
                      pathName = "tilde" + imgIndex;
                    }
                  }
                  const path3 = new PathNode(pathName);
                  const svgNode2 = new SvgNode([path3], {
                    "width": "100%",
                    "height": makeEm(height2),
                    "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
                    "preserveAspectRatio": "none"
                  });
                  return {
                    span: buildCommon.makeSvgSpan([], [svgNode2], options),
                    minWidth: 0,
                    height: height2
                  };
                } else {
                  const spans = [];
                  const data2 = katexImagesData[label];
                  const [paths, minWidth2, viewBoxHeight] = data2;
                  const height2 = viewBoxHeight / 1e3;
                  const numSvgChildren = paths.length;
                  let widthClasses;
                  let aligns;
                  if (numSvgChildren === 1) {
                    const align1 = data2[3];
                    widthClasses = ["hide-tail"];
                    aligns = [align1];
                  } else if (numSvgChildren === 2) {
                    widthClasses = ["halfarrow-left", "halfarrow-right"];
                    aligns = ["xMinYMin", "xMaxYMin"];
                  } else if (numSvgChildren === 3) {
                    widthClasses = ["brace-left", "brace-center", "brace-right"];
                    aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
                  } else {
                    throw new Error("Correct katexImagesData or update code here to support\n                    " + numSvgChildren + " children.");
                  }
                  for (let i = 0; i < numSvgChildren; i++) {
                    const path3 = new PathNode(paths[i]);
                    const svgNode2 = new SvgNode([path3], {
                      "width": "400em",
                      "height": makeEm(height2),
                      "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
                      "preserveAspectRatio": aligns[i] + " slice"
                    });
                    const span2 = buildCommon.makeSvgSpan([widthClasses[i]], [svgNode2], options);
                    if (numSvgChildren === 1) {
                      return {
                        span: span2,
                        minWidth: minWidth2,
                        height: height2
                      };
                    } else {
                      span2.style.height = makeEm(height2);
                      spans.push(span2);
                    }
                  }
                  return {
                    span: buildCommon.makeSpan(["stretchy"], spans, options),
                    minWidth: minWidth2,
                    height: height2
                  };
                }
              }
              const {
                span,
                minWidth,
                height
              } = buildSvgSpan_();
              span.height = height;
              span.style.height = makeEm(height);
              if (minWidth > 0) {
                span.style.minWidth = makeEm(minWidth);
              }
              return span;
            };
            const encloseSpan = function(inner2, label, topPad, bottomPad, options) {
              let img;
              const totalHeight = inner2.height + inner2.depth + topPad + bottomPad;
              if (/fbox|color|angl/.test(label)) {
                img = buildCommon.makeSpan(["stretchy", label], [], options);
                if (label === "fbox") {
                  const color2 = options.color && options.getColor();
                  if (color2) {
                    img.style.borderColor = color2;
                  }
                }
              } else {
                const lines = [];
                if (/^[bx]cancel$/.test(label)) {
                  lines.push(new LineNode({
                    "x1": "0",
                    "y1": "0",
                    "x2": "100%",
                    "y2": "100%",
                    "stroke-width": "0.046em"
                  }));
                }
                if (/^x?cancel$/.test(label)) {
                  lines.push(new LineNode({
                    "x1": "0",
                    "y1": "100%",
                    "x2": "100%",
                    "y2": "0",
                    "stroke-width": "0.046em"
                  }));
                }
                const svgNode2 = new SvgNode(lines, {
                  "width": "100%",
                  "height": makeEm(totalHeight)
                });
                img = buildCommon.makeSvgSpan([], [svgNode2], options);
              }
              img.height = totalHeight;
              img.style.height = makeEm(totalHeight);
              return img;
            };
            var stretchy = {
              encloseSpan,
              mathMLnode,
              svgSpan
            };
            ;
            function assertNodeType(node, type2) {
              if (!node || node.type !== type2) {
                throw new Error("Expected node of type " + type2 + ", but got " + (node ? "node of type " + node.type : String(node)));
              }
              return node;
            }
            function assertSymbolNodeType(node) {
              const typedNode = checkSymbolNodeType(node);
              if (!typedNode) {
                throw new Error("Expected node of symbol group type, but got " + (node ? "node of type " + node.type : String(node)));
              }
              return typedNode;
            }
            function checkSymbolNodeType(node) {
              if (node && (node.type === "atom" || NON_ATOMS.hasOwnProperty(node.type))) {
                return node;
              }
              return null;
            }
            ;
            const htmlBuilder = (grp, options) => {
              let base2;
              let group;
              let supSubGroup;
              if (grp && grp.type === "supsub") {
                group = assertNodeType(grp.base, "accent");
                base2 = group.base;
                grp.base = base2;
                supSubGroup = assertSpan(buildGroup(grp, options));
                grp.base = group;
              } else {
                group = assertNodeType(grp, "accent");
                base2 = group.base;
              }
              const body = buildGroup(base2, options.havingCrampedStyle());
              const mustShift = group.isShifty && utils.isCharacterBox(base2);
              let skew2 = 0;
              if (mustShift) {
                const baseChar = utils.getBaseElem(base2);
                const baseGroup = buildGroup(baseChar, options.havingCrampedStyle());
                skew2 = assertSymbolDomNode(baseGroup).skew;
              }
              const accentBelow = group.label === "\\c";
              let clearance = accentBelow ? body.height + body.depth : Math.min(body.height, options.fontMetrics().xHeight);
              let accentBody;
              if (!group.isStretchy) {
                let accent2;
                let width;
                if (group.label === "\\vec") {
                  accent2 = buildCommon.staticSvg("vec", options);
                  width = buildCommon.svgData.vec[1];
                } else {
                  accent2 = buildCommon.makeOrd({
                    mode: group.mode,
                    text: group.label
                  }, options, "textord");
                  accent2 = assertSymbolDomNode(accent2);
                  accent2.italic = 0;
                  width = accent2.width;
                  if (accentBelow) {
                    clearance += accent2.depth;
                  }
                }
                accentBody = buildCommon.makeSpan(["accent-body"], [accent2]);
                const accentFull = group.label === "\\textcircled";
                if (accentFull) {
                  accentBody.classes.push("accent-full");
                  clearance = body.height;
                }
                let left = skew2;
                if (!accentFull) {
                  left -= width / 2;
                }
                accentBody.style.left = makeEm(left);
                if (group.label === "\\textcircled") {
                  accentBody.style.top = ".2em";
                }
                accentBody = buildCommon.makeVList({
                  positionType: "firstBaseline",
                  children: [{
                    type: "elem",
                    elem: body
                  }, {
                    type: "kern",
                    size: -clearance
                  }, {
                    type: "elem",
                    elem: accentBody
                  }]
                }, options);
              } else {
                accentBody = stretchy.svgSpan(group, options);
                accentBody = buildCommon.makeVList({
                  positionType: "firstBaseline",
                  children: [{
                    type: "elem",
                    elem: body
                  }, {
                    type: "elem",
                    elem: accentBody,
                    wrapperClasses: ["svg-align"],
                    wrapperStyle: skew2 > 0 ? {
                      width: "calc(100% - " + makeEm(2 * skew2) + ")",
                      marginLeft: makeEm(2 * skew2)
                    } : void 0
                  }]
                }, options);
              }
              const accentWrap = buildCommon.makeSpan(["mord", "accent"], [accentBody], options);
              if (supSubGroup) {
                supSubGroup.children[0] = accentWrap;
                supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height);
                supSubGroup.classes[0] = "mord";
                return supSubGroup;
              } else {
                return accentWrap;
              }
            };
            const mathmlBuilder = (group, options) => {
              const accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode("mo", [makeText(group.label, group.mode)]);
              const node = new mathMLTree.MathNode("mover", [buildMathML_buildGroup(group.base, options), accentNode]);
              node.setAttribute("accent", "true");
              return node;
            };
            const NON_STRETCHY_ACCENT_REGEX = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((accent2) => "\\" + accent2).join("|"));
            defineFunction({
              type: "accent",
              names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
              props: {
                numArgs: 1
              },
              handler: (context, args) => {
                const base2 = normalizeArgument(args[0]);
                const isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);
                const isShifty = !isStretchy || context.funcName === "\\widehat" || context.funcName === "\\widetilde" || context.funcName === "\\widecheck";
                return {
                  type: "accent",
                  mode: context.parser.mode,
                  label: context.funcName,
                  isStretchy,
                  isShifty,
                  base: base2
                };
              },
              htmlBuilder,
              mathmlBuilder
            });
            defineFunction({
              type: "accent",
              names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
              props: {
                numArgs: 1,
                allowedInText: true,
                allowedInMath: true,
                // unless in strict mode
                argTypes: ["primitive"]
              },
              handler: (context, args) => {
                const base2 = args[0];
                let mode = context.parser.mode;
                if (mode === "math") {
                  context.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + context.funcName + " works only in text mode");
                  mode = "text";
                }
                return {
                  type: "accent",
                  mode,
                  label: context.funcName,
                  isStretchy: false,
                  isShifty: true,
                  base: base2
                };
              },
              htmlBuilder,
              mathmlBuilder
            });
            ;
            defineFunction({
              type: "accentUnder",
              names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
              props: {
                numArgs: 1
              },
              handler: (_ref, args) => {
                let {
                  parser,
                  funcName
                } = _ref;
                const base2 = args[0];
                return {
                  type: "accentUnder",
                  mode: parser.mode,
                  label: funcName,
                  base: base2
                };
              },
              htmlBuilder: (group, options) => {
                const innerGroup = buildGroup(group.base, options);
                const accentBody = stretchy.svgSpan(group, options);
                const kern = group.label === "\\utilde" ? 0.12 : 0;
                const vlist = buildCommon.makeVList({
                  positionType: "top",
                  positionData: innerGroup.height,
                  children: [{
                    type: "elem",
                    elem: accentBody,
                    wrapperClasses: ["svg-align"]
                  }, {
                    type: "kern",
                    size: kern
                  }, {
                    type: "elem",
                    elem: innerGroup
                  }]
                }, options);
                return buildCommon.makeSpan(["mord", "accentunder"], [vlist], options);
              },
              mathmlBuilder: (group, options) => {
                const accentNode = stretchy.mathMLnode(group.label);
                const node = new mathMLTree.MathNode("munder", [buildMathML_buildGroup(group.base, options), accentNode]);
                node.setAttribute("accentunder", "true");
                return node;
              }
            });
            ;
            const paddedNode = (group) => {
              const node = new mathMLTree.MathNode("mpadded", group ? [group] : []);
              node.setAttribute("width", "+0.6em");
              node.setAttribute("lspace", "0.3em");
              return node;
            };
            defineFunction({
              type: "xArrow",
              names: [
                "\\xleftarrow",
                "\\xrightarrow",
                "\\xLeftarrow",
                "\\xRightarrow",
                "\\xleftrightarrow",
                "\\xLeftrightarrow",
                "\\xhookleftarrow",
                "\\xhookrightarrow",
                "\\xmapsto",
                "\\xrightharpoondown",
                "\\xrightharpoonup",
                "\\xleftharpoondown",
                "\\xleftharpoonup",
                "\\xrightleftharpoons",
                "\\xleftrightharpoons",
                "\\xlongequal",
                "\\xtwoheadrightarrow",
                "\\xtwoheadleftarrow",
                "\\xtofrom",
                // The next 3 functions are here to support the mhchem extension.
                // Direct use of these functions is discouraged and may break someday.
                "\\xrightleftarrows",
                "\\xrightequilibrium",
                "\\xleftequilibrium",
                // The next 3 functions are here only to support the {CD} environment.
                "\\\\cdrightarrow",
                "\\\\cdleftarrow",
                "\\\\cdlongequal"
              ],
              props: {
                numArgs: 1,
                numOptionalArgs: 1
              },
              handler(_ref, args, optArgs) {
                let {
                  parser,
                  funcName
                } = _ref;
                return {
                  type: "xArrow",
                  mode: parser.mode,
                  label: funcName,
                  body: args[0],
                  below: optArgs[0]
                };
              },
              // Flow is unable to correctly infer the type of `group`, even though it's
              // unambiguously determined from the passed-in `type` above.
              htmlBuilder(group, options) {
                const style = options.style;
                let newOptions = options.havingStyle(style.sup());
                const upperGroup = buildCommon.wrapFragment(buildGroup(group.body, newOptions, options), options);
                const arrowPrefix = group.label.slice(0, 2) === "\\x" ? "x" : "cd";
                upperGroup.classes.push(arrowPrefix + "-arrow-pad");
                let lowerGroup;
                if (group.below) {
                  newOptions = options.havingStyle(style.sub());
                  lowerGroup = buildCommon.wrapFragment(buildGroup(group.below, newOptions, options), options);
                  lowerGroup.classes.push(arrowPrefix + "-arrow-pad");
                }
                const arrowBody = stretchy.svgSpan(group, options);
                const arrowShift = -options.fontMetrics().axisHeight + 0.5 * arrowBody.height;
                let upperShift = -options.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111;
                if (upperGroup.depth > 0.25 || group.label === "\\xleftequilibrium") {
                  upperShift -= upperGroup.depth;
                }
                let vlist;
                if (lowerGroup) {
                  const lowerShift = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;
                  vlist = buildCommon.makeVList({
                    positionType: "individualShift",
                    children: [{
                      type: "elem",
                      elem: upperGroup,
                      shift: upperShift
                    }, {
                      type: "elem",
                      elem: arrowBody,
                      shift: arrowShift
                    }, {
                      type: "elem",
                      elem: lowerGroup,
                      shift: lowerShift
                    }]
                  }, options);
                } else {
                  vlist = buildCommon.makeVList({
                    positionType: "individualShift",
                    children: [{
                      type: "elem",
                      elem: upperGroup,
                      shift: upperShift
                    }, {
                      type: "elem",
                      elem: arrowBody,
                      shift: arrowShift
                    }]
                  }, options);
                }
                vlist.children[0].children[0].children[1].classes.push("svg-align");
                return buildCommon.makeSpan(["mrel", "x-arrow"], [vlist], options);
              },
              mathmlBuilder(group, options) {
                const arrowNode = stretchy.mathMLnode(group.label);
                arrowNode.setAttribute("minsize", group.label.charAt(0) === "x" ? "1.75em" : "3.0em");
                let node;
                if (group.body) {
                  const upperNode = paddedNode(buildMathML_buildGroup(group.body, options));
                  if (group.below) {
                    const lowerNode = paddedNode(buildMathML_buildGroup(group.below, options));
                    node = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
                  } else {
                    node = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
                  }
                } else if (group.below) {
                  const lowerNode = paddedNode(buildMathML_buildGroup(group.below, options));
                  node = new mathMLTree.MathNode("munder", [arrowNode, lowerNode]);
                } else {
                  node = paddedNode();
                  node = new mathMLTree.MathNode("mover", [arrowNode, node]);
                }
                return node;
              }
            });
            ;
            const mclass_makeSpan = buildCommon.makeSpan;
            function mclass_htmlBuilder(group, options) {
              const elements = buildExpression(group.body, options, true);
              return mclass_makeSpan([group.mclass], elements, options);
            }
            function mclass_mathmlBuilder(group, options) {
              let node;
              const inner2 = buildMathML_buildExpression(group.body, options);
              if (group.mclass === "minner") {
                node = new mathMLTree.MathNode("mpadded", inner2);
              } else if (group.mclass === "mord") {
                if (group.isCharacterBox) {
                  node = inner2[0];
                  node.type = "mi";
                } else {
                  node = new mathMLTree.MathNode("mi", inner2);
                }
              } else {
                if (group.isCharacterBox) {
                  node = inner2[0];
                  node.type = "mo";
                } else {
                  node = new mathMLTree.MathNode("mo", inner2);
                }
                if (group.mclass === "mbin") {
                  node.attributes.lspace = "0.22em";
                  node.attributes.rspace = "0.22em";
                } else if (group.mclass === "mpunct") {
                  node.attributes.lspace = "0em";
                  node.attributes.rspace = "0.17em";
                } else if (group.mclass === "mopen" || group.mclass === "mclose") {
                  node.attributes.lspace = "0em";
                  node.attributes.rspace = "0em";
                } else if (group.mclass === "minner") {
                  node.attributes.lspace = "0.0556em";
                  node.attributes.width = "+0.1111em";
                }
              }
              return node;
            }
            defineFunction({
              type: "mclass",
              names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
              props: {
                numArgs: 1,
                primitive: true
              },
              handler(_ref, args) {
                let {
                  parser,
                  funcName
                } = _ref;
                const body = args[0];
                return {
                  type: "mclass",
                  mode: parser.mode,
                  mclass: "m" + funcName.slice(5),
                  // TODO(kevinb): don't prefix with 'm'
                  body: ordargument(body),
                  isCharacterBox: utils.isCharacterBox(body)
                };
              },
              htmlBuilder: mclass_htmlBuilder,
              mathmlBuilder: mclass_mathmlBuilder
            });
            const binrelClass = (arg) => {
              const atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;
              if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
                return "m" + atom.family;
              } else {
                return "mord";
              }
            };
            defineFunction({
              type: "mclass",
              names: ["\\@binrel"],
              props: {
                numArgs: 2
              },
              handler(_ref2, args) {
                let {
                  parser
                } = _ref2;
                return {
                  type: "mclass",
                  mode: parser.mode,
                  mclass: binrelClass(args[0]),
                  body: ordargument(args[1]),
                  isCharacterBox: utils.isCharacterBox(args[1])
                };
              }
            });
            defineFunction({
              type: "mclass",
              names: ["\\stackrel", "\\overset", "\\underset"],
              props: {
                numArgs: 2
              },
              handler(_ref3, args) {
                let {
                  parser,
                  funcName
                } = _ref3;
                const baseArg = args[1];
                const shiftedArg = args[0];
                let mclass;
                if (funcName !== "\\stackrel") {
                  mclass = binrelClass(baseArg);
                } else {
                  mclass = "mrel";
                }
                const baseOp = {
                  type: "op",
                  mode: baseArg.mode,
                  limits: true,
                  alwaysHandleSupSub: true,
                  parentIsSupSub: false,
                  symbol: false,
                  suppressBaseShift: funcName !== "\\stackrel",
                  body: ordargument(baseArg)
                };
                const supsub = {
                  type: "supsub",
                  mode: shiftedArg.mode,
                  base: baseOp,
                  sup: funcName === "\\underset" ? null : shiftedArg,
                  sub: funcName === "\\underset" ? shiftedArg : null
                };
                return {
                  type: "mclass",
                  mode: parser.mode,
                  mclass,
                  body: [supsub],
                  isCharacterBox: utils.isCharacterBox(supsub)
                };
              },
              htmlBuilder: mclass_htmlBuilder,
              mathmlBuilder: mclass_mathmlBuilder
            });
            ;
            defineFunction({
              type: "pmb",
              names: ["\\pmb"],
              props: {
                numArgs: 1,
                allowedInText: true
              },
              handler(_ref, args) {
                let {
                  parser
                } = _ref;
                return {
                  type: "pmb",
                  mode: parser.mode,
                  mclass: binrelClass(args[0]),
                  body: ordargument(args[0])
                };
              },
              htmlBuilder(group, options) {
                const elements = buildExpression(group.body, options, true);
                const node = buildCommon.makeSpan([group.mclass], elements, options);
                node.style.textShadow = "0.02em 0.01em 0.04px";
                return node;
              },
              mathmlBuilder(group, style) {
                const inner2 = buildMathML_buildExpression(group.body, style);
                const node = new mathMLTree.MathNode("mstyle", inner2);
                node.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px");
                return node;
              }
            });
            ;
            const cdArrowFunctionName = {
              ">": "\\\\cdrightarrow",
              "<": "\\\\cdleftarrow",
              "=": "\\\\cdlongequal",
              "A": "\\uparrow",
              "V": "\\downarrow",
              "|": "\\Vert",
              ".": "no arrow"
            };
            const newCell = () => {
              return {
                type: "styling",
                body: [],
                mode: "math",
                style: "display"
              };
            };
            const isStartOfArrow = (node) => {
              return node.type === "textord" && node.text === "@";
            };
            const isLabelEnd = (node, endChar) => {
              return (node.type === "mathord" || node.type === "atom") && node.text === endChar;
            };
            function cdArrow(arrowChar, labels, parser) {
              const funcName = cdArrowFunctionName[arrowChar];
              switch (funcName) {
                case "\\\\cdrightarrow":
                case "\\\\cdleftarrow":
                  return parser.callFunction(funcName, [labels[0]], [labels[1]]);
                case "\\uparrow":
                case "\\downarrow": {
                  const leftLabel = parser.callFunction("\\\\cdleft", [labels[0]], []);
                  const bareArrow = {
                    type: "atom",
                    text: funcName,
                    mode: "math",
                    family: "rel"
                  };
                  const sizedArrow = parser.callFunction("\\Big", [bareArrow], []);
                  const rightLabel = parser.callFunction("\\\\cdright", [labels[1]], []);
                  const arrowGroup = {
                    type: "ordgroup",
                    mode: "math",
                    body: [leftLabel, sizedArrow, rightLabel]
                  };
                  return parser.callFunction("\\\\cdparent", [arrowGroup], []);
                }
                case "\\\\cdlongequal":
                  return parser.callFunction("\\\\cdlongequal", [], []);
                case "\\Vert": {
                  const arrow = {
                    type: "textord",
                    text: "\\Vert",
                    mode: "math"
                  };
                  return parser.callFunction("\\Big", [arrow], []);
                }
                default:
                  return {
                    type: "textord",
                    text: " ",
                    mode: "math"
                  };
              }
            }
            function parseCD(parser) {
              const parsedRows = [];
              parser.gullet.beginGroup();
              parser.gullet.macros.set("\\cr", "\\\\\\relax");
              parser.gullet.beginGroup();
              while (true) {
                parsedRows.push(parser.parseExpression(false, "\\\\"));
                parser.gullet.endGroup();
                parser.gullet.beginGroup();
                const next2 = parser.fetch().text;
                if (next2 === "&" || next2 === "\\\\") {
                  parser.consume();
                } else if (next2 === "\\end") {
                  if (parsedRows[parsedRows.length - 1].length === 0) {
                    parsedRows.pop();
                  }
                  break;
                } else {
                  throw new src_ParseError("Expected \\\\ or \\cr or \\end", parser.nextToken);
                }
              }
              let row = [];
              const body = [row];
              for (let i = 0; i < parsedRows.length; i++) {
                const rowNodes = parsedRows[i];
                let cell = newCell();
                for (let j2 = 0; j2 < rowNodes.length; j2++) {
                  if (!isStartOfArrow(rowNodes[j2])) {
                    cell.body.push(rowNodes[j2]);
                  } else {
                    row.push(cell);
                    j2 += 1;
                    const arrowChar = assertSymbolNodeType(rowNodes[j2]).text;
                    const labels = new Array(2);
                    labels[0] = {
                      type: "ordgroup",
                      mode: "math",
                      body: []
                    };
                    labels[1] = {
                      type: "ordgroup",
                      mode: "math",
                      body: []
                    };
                    if ("=|.".indexOf(arrowChar) > -1) {
                    } else if ("<>AV".indexOf(arrowChar) > -1) {
                      for (let labelNum = 0; labelNum < 2; labelNum++) {
                        let inLabel = true;
                        for (let k = j2 + 1; k < rowNodes.length; k++) {
                          if (isLabelEnd(rowNodes[k], arrowChar)) {
                            inLabel = false;
                            j2 = k;
                            break;
                          }
                          if (isStartOfArrow(rowNodes[k])) {
                            throw new src_ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[k]);
                          }
                          labels[labelNum].body.push(rowNodes[k]);
                        }
                        if (inLabel) {
                          throw new src_ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[j2]);
                        }
                      }
                    } else {
                      throw new src_ParseError('Expected one of "<>AV=|." after @', rowNodes[j2]);
                    }
                    const arrow = cdArrow(arrowChar, labels, parser);
                    const wrappedArrow = {
                      type: "styling",
                      body: [arrow],
                      mode: "math",
                      style: "display"
                      // CD is always displaystyle.
                    };
                    row.push(wrappedArrow);
                    cell = newCell();
                  }
                }
                if (i % 2 === 0) {
                  row.push(cell);
                } else {
                  row.shift();
                }
                row = [];
                body.push(row);
              }
              parser.gullet.endGroup();
              parser.gullet.endGroup();
              const cols = new Array(body[0].length).fill({
                type: "align",
                align: "c",
                pregap: 0.25,
                // CD package sets \enskip between columns.
                postgap: 0.25
                // So pre and post each get half an \enskip, i.e. 0.25em.
              });
              return {
                type: "array",
                mode: "math",
                body,
                arraystretch: 1,
                addJot: true,
                rowGaps: [null],
                cols,
                colSeparationType: "CD",
                hLinesBeforeRow: new Array(body.length + 1).fill([])
              };
            }
            defineFunction({
              type: "cdlabel",
              names: ["\\\\cdleft", "\\\\cdright"],
              props: {
                numArgs: 1
              },
              handler(_ref, args) {
                let {
                  parser,
                  funcName
                } = _ref;
                return {
                  type: "cdlabel",
                  mode: parser.mode,
                  side: funcName.slice(4),
                  label: args[0]
                };
              },
              htmlBuilder(group, options) {
                const newOptions = options.havingStyle(options.style.sup());
                const label = buildCommon.wrapFragment(buildGroup(group.label, newOptions, options), options);
                label.classes.push("cd-label-" + group.side);
                label.style.bottom = makeEm(0.8 - label.depth);
                label.height = 0;
                label.depth = 0;
                return label;
              },
              mathmlBuilder(group, options) {
                let label = new mathMLTree.MathNode("mrow", [buildMathML_buildGroup(group.label, options)]);
                label = new mathMLTree.MathNode("mpadded", [label]);
                label.setAttribute("width", "0");
                if (group.side === "left") {
                  label.setAttribute("lspace", "-1width");
                }
                label.setAttribute("voffset", "0.7em");
                label = new mathMLTree.MathNode("mstyle", [label]);
                label.setAttribute("displaystyle", "false");
                label.setAttribute("scriptlevel", "1");
                return label;
              }
            });
            defineFunction({
              type: "cdlabelparent",
              names: ["\\\\cdparent"],
              props: {
                numArgs: 1
              },
              handler(_ref2, args) {
                let {
                  parser
                } = _ref2;
                return {
                  type: "cdlabelparent",
                  mode: parser.mode,
                  fragment: args[0]
                };
              },
              htmlBuilder(group, options) {
                const parent2 = buildCommon.wrapFragment(buildGroup(group.fragment, options), options);
                parent2.classes.push("cd-vert-arrow");
                return parent2;
              },
              mathmlBuilder(group, options) {
                return new mathMLTree.MathNode("mrow", [buildMathML_buildGroup(group.fragment, options)]);
              }
            });
            ;
            defineFunction({
              type: "textord",
              names: ["\\@char"],
              props: {
                numArgs: 1,
                allowedInText: true
              },
              handler(_ref, args) {
                let {
                  parser
                } = _ref;
                const arg = assertNodeType(args[0], "ordgroup");
                const group = arg.body;
                let number = "";
                for (let i = 0; i < group.length; i++) {
                  const node = assertNodeType(group[i], "textord");
                  number += node.text;
                }
                let code2 = parseInt(number);
                let text3;
                if (isNaN(code2)) {
                  throw new src_ParseError("\\@char has non-numeric argument " + number);
                } else if (code2 < 0 || code2 >= 1114111) {
                  throw new src_ParseError("\\@char with invalid code point " + number);
                } else if (code2 <= 65535) {
                  text3 = String.fromCharCode(code2);
                } else {
                  code2 -= 65536;
                  text3 = String.fromCharCode((code2 >> 10) + 55296, (code2 & 1023) + 56320);
                }
                return {
                  type: "textord",
                  mode: parser.mode,
                  text: text3
                };
              }
            });
            ;
            const color_htmlBuilder = (group, options) => {
              const elements = buildExpression(group.body, options.withColor(group.color), false);
              return buildCommon.makeFragment(elements);
            };
            const color_mathmlBuilder = (group, options) => {
              const inner2 = buildMathML_buildExpression(group.body, options.withColor(group.color));
              const node = new mathMLTree.MathNode("mstyle", inner2);
              node.setAttribute("mathcolor", group.color);
              return node;
            };
            defineFunction({
              type: "color",
              names: ["\\textcolor"],
              props: {
                numArgs: 2,
                allowedInText: true,
                argTypes: ["color", "original"]
              },
              handler(_ref, args) {
                let {
                  parser
                } = _ref;
                const color2 = assertNodeType(args[0], "color-token").color;
                const body = args[1];
                return {
                  type: "color",
                  mode: parser.mode,
                  color: color2,
                  body: ordargument(body)
                };
              },
              htmlBuilder: color_htmlBuilder,
              mathmlBuilder: color_mathmlBuilder
            });
            defineFunction({
              type: "color",
              names: ["\\color"],
              props: {
                numArgs: 1,
                allowedInText: true,
                argTypes: ["color"]
              },
              handler(_ref2, args) {
                let {
                  parser,
                  breakOnTokenText
                } = _ref2;
                const color2 = assertNodeType(args[0], "color-token").color;
                parser.gullet.macros.set("\\current@color", color2);
                const body = parser.parseExpression(true, breakOnTokenText);
                return {
                  type: "color",
                  mode: parser.mode,
                  color: color2,
                  body
                };
              },
              htmlBuilder: color_htmlBuilder,
              mathmlBuilder: color_mathmlBuilder
            });
            ;
            defineFunction({
              type: "cr",
              names: ["\\\\"],
              props: {
                numArgs: 0,
                numOptionalArgs: 0,
                allowedInText: true
              },
              handler(_ref, args, optArgs) {
                let {
                  parser
                } = _ref;
                const size = parser.gullet.future().text === "[" ? parser.parseSizeGroup(true) : null;
                const newLine = !parser.settings.displayMode || !parser.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
                return {
                  type: "cr",
                  mode: parser.mode,
                  newLine,
                  size: size && assertNodeType(size, "size").value
                };
              },
              // The following builders are called only at the top level,
              // not within tabular/array environments.
              htmlBuilder(group, options) {
                const span = buildCommon.makeSpan(["mspace"], [], options);
                if (group.newLine) {
                  span.classes.push("newline");
                  if (group.size) {
                    span.style.marginTop = makeEm(calculateSize(group.size, options));
                  }
                }
                return span;
              },
              mathmlBuilder(group, options) {
                const node = new mathMLTree.MathNode("mspace");
                if (group.newLine) {
                  node.setAttribute("linebreak", "newline");
                  if (group.size) {
                    node.setAttribute("height", makeEm(calculateSize(group.size, options)));
                  }
                }
                return node;
              }
            });
            ;
            const globalMap = {
              "\\global": "\\global",
              "\\long": "\\\\globallong",
              "\\\\globallong": "\\\\globallong",
              "\\def": "\\gdef",
              "\\gdef": "\\gdef",
              "\\edef": "\\xdef",
              "\\xdef": "\\xdef",
              "\\let": "\\\\globallet",
              "\\futurelet": "\\\\globalfuture"
            };
            const checkControlSequence = (tok) => {
              const name2 = tok.text;
              if (/^(?:[\\{}$&#^_]|EOF)$/.test(name2)) {
                throw new src_ParseError("Expected a control sequence", tok);
              }
              return name2;
            };
            const getRHS = (parser) => {
              let tok = parser.gullet.popToken();
              if (tok.text === "=") {
                tok = parser.gullet.popToken();
                if (tok.text === " ") {
                  tok = parser.gullet.popToken();
                }
              }
              return tok;
            };
            const letCommand = (parser, name2, tok, global) => {
              let macro = parser.gullet.macros.get(tok.text);
              if (macro == null) {
                tok.noexpand = true;
                macro = {
                  tokens: [tok],
                  numArgs: 0,
                  // reproduce the same behavior in expansion
                  unexpandable: !parser.gullet.isExpandable(tok.text)
                };
              }
              parser.gullet.macros.set(name2, macro, global);
            };
            defineFunction({
              type: "internal",
              names: [
                "\\global",
                "\\long",
                "\\\\globallong"
                // can’t be entered directly
              ],
              props: {
                numArgs: 0,
                allowedInText: true
              },
              handler(_ref) {
                let {
                  parser,
                  funcName
                } = _ref;
                parser.consumeSpaces();
                const token = parser.fetch();
                if (globalMap[token.text]) {
                  if (funcName === "\\global" || funcName === "\\\\globallong") {
                    token.text = globalMap[token.text];
                  }
                  return assertNodeType(parser.parseFunction(), "internal");
                }
                throw new src_ParseError("Invalid token after macro prefix", token);
              }
            });
            defineFunction({
              type: "internal",
              names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
              props: {
                numArgs: 0,
                allowedInText: true,
                primitive: true
              },
              handler(_ref2) {
                let {
                  parser,
                  funcName
                } = _ref2;
                let tok = parser.gullet.popToken();
                const name2 = tok.text;
                if (/^(?:[\\{}$&#^_]|EOF)$/.test(name2)) {
                  throw new src_ParseError("Expected a control sequence", tok);
                }
                let numArgs = 0;
                let insert;
                const delimiters2 = [[]];
                while (parser.gullet.future().text !== "{") {
                  tok = parser.gullet.popToken();
                  if (tok.text === "#") {
                    if (parser.gullet.future().text === "{") {
                      insert = parser.gullet.future();
                      delimiters2[numArgs].push("{");
                      break;
                    }
                    tok = parser.gullet.popToken();
                    if (!/^[1-9]$/.test(tok.text)) {
                      throw new src_ParseError('Invalid argument number "' + tok.text + '"');
                    }
                    if (parseInt(tok.text) !== numArgs + 1) {
                      throw new src_ParseError('Argument number "' + tok.text + '" out of order');
                    }
                    numArgs++;
                    delimiters2.push([]);
                  } else if (tok.text === "EOF") {
                    throw new src_ParseError("Expected a macro definition");
                  } else {
                    delimiters2[numArgs].push(tok.text);
                  }
                }
                let {
                  tokens
                } = parser.gullet.consumeArg();
                if (insert) {
                  tokens.unshift(insert);
                }
                if (funcName === "\\edef" || funcName === "\\xdef") {
                  tokens = parser.gullet.expandTokens(tokens);
                  tokens.reverse();
                }
                parser.gullet.macros.set(name2, {
                  tokens,
                  numArgs,
                  delimiters: delimiters2
                }, funcName === globalMap[funcName]);
                return {
                  type: "internal",
                  mode: parser.mode
                };
              }
            });
            defineFunction({
              type: "internal",
              names: [
                "\\let",
                "\\\\globallet"
                // can’t be entered directly
              ],
              props: {
                numArgs: 0,
                allowedInText: true,
                primitive: true
              },
              handler(_ref3) {
                let {
                  parser,
                  funcName
                } = _ref3;
                const name2 = checkControlSequence(parser.gullet.popToken());
                parser.gullet.consumeSpaces();
                const tok = getRHS(parser);
                letCommand(parser, name2, tok, funcName === "\\\\globallet");
                return {
                  type: "internal",
                  mode: parser.mode
                };
              }
            });
            defineFunction({
              type: "internal",
              names: [
                "\\futurelet",
                "\\\\globalfuture"
                // can’t be entered directly
              ],
              props: {
                numArgs: 0,
                allowedInText: true,
                primitive: true
              },
              handler(_ref4) {
                let {
                  parser,
                  funcName
                } = _ref4;
                const name2 = checkControlSequence(parser.gullet.popToken());
                const middle = parser.gullet.popToken();
                const tok = parser.gullet.popToken();
                letCommand(parser, name2, tok, funcName === "\\\\globalfuture");
                parser.gullet.pushToken(tok);
                parser.gullet.pushToken(middle);
                return {
                  type: "internal",
                  mode: parser.mode
                };
              }
            });
            ;
            const getMetrics = function(symbol, font, mode) {
              const replace2 = src_symbols.math[symbol] && src_symbols.math[symbol].replace;
              const metrics = getCharacterMetrics(replace2 || symbol, font, mode);
              if (!metrics) {
                throw new Error("Unsupported symbol " + symbol + " and font size " + font + ".");
              }
              return metrics;
            };
            const styleWrap = function(delim, toStyle, options, classes) {
              const newOptions = options.havingBaseStyle(toStyle);
              const span = buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options)), [delim], options);
              const delimSizeMultiplier = newOptions.sizeMultiplier / options.sizeMultiplier;
              span.height *= delimSizeMultiplier;
              span.depth *= delimSizeMultiplier;
              span.maxFontSize = newOptions.sizeMultiplier;
              return span;
            };
            const centerSpan = function(span, options, style) {
              const newOptions = options.havingBaseStyle(style);
              const shift = (1 - options.sizeMultiplier / newOptions.sizeMultiplier) * options.fontMetrics().axisHeight;
              span.classes.push("delimcenter");
              span.style.top = makeEm(shift);
              span.height -= shift;
              span.depth += shift;
            };
            const makeSmallDelim = function(delim, style, center, options, mode, classes) {
              const text3 = buildCommon.makeSymbol(delim, "Main-Regular", mode, options);
              const span = styleWrap(text3, style, options, classes);
              if (center) {
                centerSpan(span, options, style);
              }
              return span;
            };
            const mathrmSize = function(value, size, mode, options) {
              return buildCommon.makeSymbol(value, "Size" + size + "-Regular", mode, options);
            };
            const makeLargeDelim = function(delim, size, center, options, mode, classes) {
              const inner2 = mathrmSize(delim, size, mode, options);
              const span = styleWrap(buildCommon.makeSpan(["delimsizing", "size" + size], [inner2], options), src_Style.TEXT, options, classes);
              if (center) {
                centerSpan(span, options, src_Style.TEXT);
              }
              return span;
            };
            const makeGlyphSpan = function(symbol, font, mode) {
              let sizeClass;
              if (font === "Size1-Regular") {
                sizeClass = "delim-size1";
              } else {
                sizeClass = "delim-size4";
              }
              const corner = buildCommon.makeSpan(["delimsizinginner", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]);
              return {
                type: "elem",
                elem: corner
              };
            };
            const makeInner = function(ch, height, options) {
              const width = fontMetricsData["Size4-Regular"][ch.charCodeAt(0)] ? fontMetricsData["Size4-Regular"][ch.charCodeAt(0)][4] : fontMetricsData["Size1-Regular"][ch.charCodeAt(0)][4];
              const path3 = new PathNode("inner", innerPath(ch, Math.round(1e3 * height)));
              const svgNode2 = new SvgNode([path3], {
                "width": makeEm(width),
                "height": makeEm(height),
                // Override CSS rule `.katex svg { width: 100% }`
                "style": "width:" + makeEm(width),
                "viewBox": "0 0 " + 1e3 * width + " " + Math.round(1e3 * height),
                "preserveAspectRatio": "xMinYMin"
              });
              const span = buildCommon.makeSvgSpan([], [svgNode2], options);
              span.height = height;
              span.style.height = makeEm(height);
              span.style.width = makeEm(width);
              return {
                type: "elem",
                elem: span
              };
            };
            const lapInEms = 8e-3;
            const lap = {
              type: "kern",
              size: -1 * lapInEms
            };
            const verts = ["|", "\\lvert", "\\rvert", "\\vert"];
            const doubleVerts = ["\\|", "\\lVert", "\\rVert", "\\Vert"];
            const makeStackedDelim = function(delim, heightTotal, center, options, mode, classes) {
              let top;
              let middle;
              let repeat;
              let bottom;
              let svgLabel = "";
              let viewBoxWidth = 0;
              top = repeat = bottom = delim;
              middle = null;
              let font = "Size1-Regular";
              if (delim === "\\uparrow") {
                repeat = bottom = "\u23D0";
              } else if (delim === "\\Uparrow") {
                repeat = bottom = "\u2016";
              } else if (delim === "\\downarrow") {
                top = repeat = "\u23D0";
              } else if (delim === "\\Downarrow") {
                top = repeat = "\u2016";
              } else if (delim === "\\updownarrow") {
                top = "\\uparrow";
                repeat = "\u23D0";
                bottom = "\\downarrow";
              } else if (delim === "\\Updownarrow") {
                top = "\\Uparrow";
                repeat = "\u2016";
                bottom = "\\Downarrow";
              } else if (verts.includes(delim)) {
                repeat = "\u2223";
                svgLabel = "vert";
                viewBoxWidth = 333;
              } else if (doubleVerts.includes(delim)) {
                repeat = "\u2225";
                svgLabel = "doublevert";
                viewBoxWidth = 556;
              } else if (delim === "[" || delim === "\\lbrack") {
                top = "\u23A1";
                repeat = "\u23A2";
                bottom = "\u23A3";
                font = "Size4-Regular";
                svgLabel = "lbrack";
                viewBoxWidth = 667;
              } else if (delim === "]" || delim === "\\rbrack") {
                top = "\u23A4";
                repeat = "\u23A5";
                bottom = "\u23A6";
                font = "Size4-Regular";
                svgLabel = "rbrack";
                viewBoxWidth = 667;
              } else if (delim === "\\lfloor" || delim === "\u230A") {
                repeat = top = "\u23A2";
                bottom = "\u23A3";
                font = "Size4-Regular";
                svgLabel = "lfloor";
                viewBoxWidth = 667;
              } else if (delim === "\\lceil" || delim === "\u2308") {
                top = "\u23A1";
                repeat = bottom = "\u23A2";
                font = "Size4-Regular";
                svgLabel = "lceil";
                viewBoxWidth = 667;
              } else if (delim === "\\rfloor" || delim === "\u230B") {
                repeat = top = "\u23A5";
                bottom = "\u23A6";
                font = "Size4-Regular";
                svgLabel = "rfloor";
                viewBoxWidth = 667;
              } else if (delim === "\\rceil" || delim === "\u2309") {
                top = "\u23A4";
                repeat = bottom = "\u23A5";
                font = "Size4-Regular";
                svgLabel = "rceil";
                viewBoxWidth = 667;
              } else if (delim === "(" || delim === "\\lparen") {
                top = "\u239B";
                repeat = "\u239C";
                bottom = "\u239D";
                font = "Size4-Regular";
                svgLabel = "lparen";
                viewBoxWidth = 875;
              } else if (delim === ")" || delim === "\\rparen") {
                top = "\u239E";
                repeat = "\u239F";
                bottom = "\u23A0";
                font = "Size4-Regular";
                svgLabel = "rparen";
                viewBoxWidth = 875;
              } else if (delim === "\\{" || delim === "\\lbrace") {
                top = "\u23A7";
                middle = "\u23A8";
                bottom = "\u23A9";
                repeat = "\u23AA";
                font = "Size4-Regular";
              } else if (delim === "\\}" || delim === "\\rbrace") {
                top = "\u23AB";
                middle = "\u23AC";
                bottom = "\u23AD";
                repeat = "\u23AA";
                font = "Size4-Regular";
              } else if (delim === "\\lgroup" || delim === "\u27EE") {
                top = "\u23A7";
                bottom = "\u23A9";
                repeat = "\u23AA";
                font = "Size4-Regular";
              } else if (delim === "\\rgroup" || delim === "\u27EF") {
                top = "\u23AB";
                bottom = "\u23AD";
                repeat = "\u23AA";
                font = "Size4-Regular";
              } else if (delim === "\\lmoustache" || delim === "\u23B0") {
                top = "\u23A7";
                bottom = "\u23AD";
                repeat = "\u23AA";
                font = "Size4-Regular";
              } else if (delim === "\\rmoustache" || delim === "\u23B1") {
                top = "\u23AB";
                bottom = "\u23A9";
                repeat = "\u23AA";
                font = "Size4-Regular";
              }
              const topMetrics = getMetrics(top, font, mode);
              const topHeightTotal = topMetrics.height + topMetrics.depth;
              const repeatMetrics = getMetrics(repeat, font, mode);
              const repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
              const bottomMetrics = getMetrics(bottom, font, mode);
              const bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
              let middleHeightTotal = 0;
              let middleFactor = 1;
              if (middle !== null) {
                const middleMetrics = getMetrics(middle, font, mode);
                middleHeightTotal = middleMetrics.height + middleMetrics.depth;
                middleFactor = 2;
              }
              const minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;
              const repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal)));
              const realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal;
              let axisHeight = options.fontMetrics().axisHeight;
              if (center) {
                axisHeight *= options.sizeMultiplier;
              }
              const depth = realHeightTotal / 2 - axisHeight;
              const stack = [];
              if (svgLabel.length > 0) {
                const midHeight = realHeightTotal - topHeightTotal - bottomHeightTotal;
                const viewBoxHeight = Math.round(realHeightTotal * 1e3);
                const pathStr = tallDelim(svgLabel, Math.round(midHeight * 1e3));
                const path3 = new PathNode(svgLabel, pathStr);
                const width = (viewBoxWidth / 1e3).toFixed(3) + "em";
                const height = (viewBoxHeight / 1e3).toFixed(3) + "em";
                const svg = new SvgNode([path3], {
                  "width": width,
                  "height": height,
                  "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight
                });
                const wrapper = buildCommon.makeSvgSpan([], [svg], options);
                wrapper.height = viewBoxHeight / 1e3;
                wrapper.style.width = width;
                wrapper.style.height = height;
                stack.push({
                  type: "elem",
                  elem: wrapper
                });
              } else {
                stack.push(makeGlyphSpan(bottom, font, mode));
                stack.push(lap);
                if (middle === null) {
                  const innerHeight = realHeightTotal - topHeightTotal - bottomHeightTotal + 2 * lapInEms;
                  stack.push(makeInner(repeat, innerHeight, options));
                } else {
                  const innerHeight = (realHeightTotal - topHeightTotal - bottomHeightTotal - middleHeightTotal) / 2 + 2 * lapInEms;
                  stack.push(makeInner(repeat, innerHeight, options));
                  stack.push(lap);
                  stack.push(makeGlyphSpan(middle, font, mode));
                  stack.push(lap);
                  stack.push(makeInner(repeat, innerHeight, options));
                }
                stack.push(lap);
                stack.push(makeGlyphSpan(top, font, mode));
              }
              const newOptions = options.havingBaseStyle(src_Style.TEXT);
              const inner2 = buildCommon.makeVList({
                positionType: "bottom",
                positionData: depth,
                children: stack
              }, newOptions);
              return styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [inner2], newOptions), src_Style.TEXT, options, classes);
            };
            const vbPad = 80;
            const emPad = 0.08;
            const sqrtSvg = function(sqrtName, height, viewBoxHeight, extraVinculum, options) {
              const path3 = sqrtPath(sqrtName, extraVinculum, viewBoxHeight);
              const pathNode = new PathNode(sqrtName, path3);
              const svg = new SvgNode([pathNode], {
                // Note: 1000:1 ratio of viewBox to document em width.
                "width": "400em",
                "height": makeEm(height),
                "viewBox": "0 0 400000 " + viewBoxHeight,
                "preserveAspectRatio": "xMinYMin slice"
              });
              return buildCommon.makeSvgSpan(["hide-tail"], [svg], options);
            };
            const makeSqrtImage = function(height, options) {
              const newOptions = options.havingBaseSizing();
              const delim = traverseSequence("\\surd", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);
              let sizeMultiplier = newOptions.sizeMultiplier;
              const extraVinculum = Math.max(0, options.minRuleThickness - options.fontMetrics().sqrtRuleThickness);
              let span;
              let spanHeight = 0;
              let texHeight = 0;
              let viewBoxHeight = 0;
              let advanceWidth;
              if (delim.type === "small") {
                viewBoxHeight = 1e3 + 1e3 * extraVinculum + vbPad;
                if (height < 1) {
                  sizeMultiplier = 1;
                } else if (height < 1.4) {
                  sizeMultiplier = 0.7;
                }
                spanHeight = (1 + extraVinculum + emPad) / sizeMultiplier;
                texHeight = (1 + extraVinculum) / sizeMultiplier;
                span = sqrtSvg("sqrtMain", spanHeight, viewBoxHeight, extraVinculum, options);
                span.style.minWidth = "0.853em";
                advanceWidth = 0.833 / sizeMultiplier;
              } else if (delim.type === "large") {
                viewBoxHeight = (1e3 + vbPad) * sizeToMaxHeight[delim.size];
                texHeight = (sizeToMaxHeight[delim.size] + extraVinculum) / sizeMultiplier;
                spanHeight = (sizeToMaxHeight[delim.size] + extraVinculum + emPad) / sizeMultiplier;
                span = sqrtSvg("sqrtSize" + delim.size, spanHeight, viewBoxHeight, extraVinculum, options);
                span.style.minWidth = "1.02em";
                advanceWidth = 1 / sizeMultiplier;
              } else {
                spanHeight = height + extraVinculum + emPad;
                texHeight = height + extraVinculum;
                viewBoxHeight = Math.floor(1e3 * height + extraVinculum) + vbPad;
                span = sqrtSvg("sqrtTall", spanHeight, viewBoxHeight, extraVinculum, options);
                span.style.minWidth = "0.742em";
                advanceWidth = 1.056;
              }
              span.height = texHeight;
              span.style.height = makeEm(spanHeight);
              return {
                span,
                advanceWidth,
                // Calculate the actual line width.
                // This actually should depend on the chosen font -- e.g. \boldmath
                // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
                // have thicker rules.
                ruleWidth: (options.fontMetrics().sqrtRuleThickness + extraVinculum) * sizeMultiplier
              };
            };
            const stackLargeDelimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "\\surd"];
            const stackAlwaysDelimiters = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1"];
            const stackNeverDelimiters = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"];
            const sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3];
            const makeSizedDelim = function(delim, size, options, mode, classes) {
              if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
                delim = "\\langle";
              } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
                delim = "\\rangle";
              }
              if (stackLargeDelimiters.includes(delim) || stackNeverDelimiters.includes(delim)) {
                return makeLargeDelim(delim, size, false, options, mode, classes);
              } else if (stackAlwaysDelimiters.includes(delim)) {
                return makeStackedDelim(delim, sizeToMaxHeight[size], false, options, mode, classes);
              } else {
                throw new src_ParseError("Illegal delimiter: '" + delim + "'");
              }
            };
            const stackNeverDelimiterSequence = [{
              type: "small",
              style: src_Style.SCRIPTSCRIPT
            }, {
              type: "small",
              style: src_Style.SCRIPT
            }, {
              type: "small",
              style: src_Style.TEXT
            }, {
              type: "large",
              size: 1
            }, {
              type: "large",
              size: 2
            }, {
              type: "large",
              size: 3
            }, {
              type: "large",
              size: 4
            }];
            const stackAlwaysDelimiterSequence = [{
              type: "small",
              style: src_Style.SCRIPTSCRIPT
            }, {
              type: "small",
              style: src_Style.SCRIPT
            }, {
              type: "small",
              style: src_Style.TEXT
            }, {
              type: "stack"
            }];
            const stackLargeDelimiterSequence = [{
              type: "small",
              style: src_Style.SCRIPTSCRIPT
            }, {
              type: "small",
              style: src_Style.SCRIPT
            }, {
              type: "small",
              style: src_Style.TEXT
            }, {
              type: "large",
              size: 1
            }, {
              type: "large",
              size: 2
            }, {
              type: "large",
              size: 3
            }, {
              type: "large",
              size: 4
            }, {
              type: "stack"
            }];
            const delimTypeToFont = function(type2) {
              if (type2.type === "small") {
                return "Main-Regular";
              } else if (type2.type === "large") {
                return "Size" + type2.size + "-Regular";
              } else if (type2.type === "stack") {
                return "Size4-Regular";
              } else {
                throw new Error("Add support for delim type '" + type2.type + "' here.");
              }
            };
            const traverseSequence = function(delim, height, sequence, options) {
              const start2 = Math.min(2, 3 - options.style.size);
              for (let i = start2; i < sequence.length; i++) {
                if (sequence[i].type === "stack") {
                  break;
                }
                const metrics = getMetrics(delim, delimTypeToFont(sequence[i]), "math");
                let heightDepth = metrics.height + metrics.depth;
                if (sequence[i].type === "small") {
                  const newOptions = options.havingBaseStyle(sequence[i].style);
                  heightDepth *= newOptions.sizeMultiplier;
                }
                if (heightDepth > height) {
                  return sequence[i];
                }
              }
              return sequence[sequence.length - 1];
            };
            const makeCustomSizedDelim = function(delim, height, center, options, mode, classes) {
              if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
                delim = "\\langle";
              } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
                delim = "\\rangle";
              }
              let sequence;
              if (stackNeverDelimiters.includes(delim)) {
                sequence = stackNeverDelimiterSequence;
              } else if (stackLargeDelimiters.includes(delim)) {
                sequence = stackLargeDelimiterSequence;
              } else {
                sequence = stackAlwaysDelimiterSequence;
              }
              const delimType = traverseSequence(delim, height, sequence, options);
              if (delimType.type === "small") {
                return makeSmallDelim(delim, delimType.style, center, options, mode, classes);
              } else if (delimType.type === "large") {
                return makeLargeDelim(delim, delimType.size, center, options, mode, classes);
              } else {
                return makeStackedDelim(delim, height, center, options, mode, classes);
              }
            };
            const makeLeftRightDelim = function(delim, height, depth, options, mode, classes) {
              const axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier;
              const delimiterFactor = 901;
              const delimiterExtend = 5 / options.fontMetrics().ptPerEm;
              const maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
              const totalHeight = Math.max(
                // In real TeX, calculations are done using integral values which are
                // 65536 per pt, or 655360 per em. So, the division here truncates in
                // TeX but doesn't here, producing different results. If we wanted to
                // exactly match TeX's calculation, we could do
                //   Math.floor(655360 * maxDistFromAxis / 500) *
                //    delimiterFactor / 655360
                // (To see the difference, compare
                //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
                // in TeX and KaTeX)
                maxDistFromAxis / 500 * delimiterFactor,
                2 * maxDistFromAxis - delimiterExtend
              );
              return makeCustomSizedDelim(delim, totalHeight, true, options, mode, classes);
            };
            var delimiter2 = {
              sqrtImage: makeSqrtImage,
              sizedDelim: makeSizedDelim,
              sizeToMaxHeight,
              customSizedDelim: makeCustomSizedDelim,
              leftRightDelim: makeLeftRightDelim
            };
            ;
            const delimiterSizes = {
              "\\bigl": {
                mclass: "mopen",
                size: 1
              },
              "\\Bigl": {
                mclass: "mopen",
                size: 2
              },
              "\\biggl": {
                mclass: "mopen",
                size: 3
              },
              "\\Biggl": {
                mclass: "mopen",
                size: 4
              },
              "\\bigr": {
                mclass: "mclose",
                size: 1
              },
              "\\Bigr": {
                mclass: "mclose",
                size: 2
              },
              "\\biggr": {
                mclass: "mclose",
                size: 3
              },
              "\\Biggr": {
                mclass: "mclose",
                size: 4
              },
              "\\bigm": {
                mclass: "mrel",
                size: 1
              },
              "\\Bigm": {
                mclass: "mrel",
                size: 2
              },
              "\\biggm": {
                mclass: "mrel",
                size: 3
              },
              "\\Biggm": {
                mclass: "mrel",
                size: 4
              },
              "\\big": {
                mclass: "mord",
                size: 1
              },
              "\\Big": {
                mclass: "mord",
                size: 2
              },
              "\\bigg": {
                mclass: "mord",
                size: 3
              },
              "\\Bigg": {
                mclass: "mord",
                size: 4
              }
            };
            const delimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "<", ">", "\\langle", "\u27E8", "\\rangle", "\u27E9", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
            function checkDelimiter(delim, context) {
              const symDelim = checkSymbolNodeType(delim);
              if (symDelim && delimiters.includes(symDelim.text)) {
                return symDelim;
              } else if (symDelim) {
                throw new src_ParseError("Invalid delimiter '" + symDelim.text + "' after '" + context.funcName + "'", delim);
              } else {
                throw new src_ParseError("Invalid delimiter type '" + delim.type + "'", delim);
              }
            }
            defineFunction({
              type: "delimsizing",
              names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
              props: {
                numArgs: 1,
                argTypes: ["primitive"]
              },
              handler: (context, args) => {
                const delim = checkDelimiter(args[0], context);
                return {
                  type: "delimsizing",
                  mode: context.parser.mode,
                  size: delimiterSizes[context.funcName].size,
                  mclass: delimiterSizes[context.funcName].mclass,
                  delim: delim.text
                };
              },
              htmlBuilder: (group, options) => {
                if (group.delim === ".") {
                  return buildCommon.makeSpan([group.mclass]);
                }
                return delimiter2.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]);
              },
              mathmlBuilder: (group) => {
                const children3 = [];
                if (group.delim !== ".") {
                  children3.push(makeText(group.delim, group.mode));
                }
                const node = new mathMLTree.MathNode("mo", children3);
                if (group.mclass === "mopen" || group.mclass === "mclose") {
                  node.setAttribute("fence", "true");
                } else {
                  node.setAttribute("fence", "false");
                }
                node.setAttribute("stretchy", "true");
                const size = makeEm(delimiter2.sizeToMaxHeight[group.size]);
                node.setAttribute("minsize", size);
                node.setAttribute("maxsize", size);
                return node;
              }
            });
            function assertParsed(group) {
              if (!group.body) {
                throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
              }
            }
            defineFunction({
              type: "leftright-right",
              names: ["\\right"],
              props: {
                numArgs: 1,
                primitive: true
              },
              handler: (context, args) => {
                const color2 = context.parser.gullet.macros.get("\\current@color");
                if (color2 && typeof color2 !== "string") {
                  throw new src_ParseError("\\current@color set to non-string in \\right");
                }
                return {
                  type: "leftright-right",
                  mode: context.parser.mode,
                  delim: checkDelimiter(args[0], context).text,
                  color: color2
                  // undefined if not set via \color
                };
              }
            });
            defineFunction({
              type: "leftright",
              names: ["\\left"],
              props: {
                numArgs: 1,
                primitive: true
              },
              handler: (context, args) => {
                const delim = checkDelimiter(args[0], context);
                const parser = context.parser;
                ++parser.leftrightDepth;
                const body = parser.parseExpression(false);
                --parser.leftrightDepth;
                parser.expect("\\right", false);
                const right = assertNodeType(parser.parseFunction(), "leftright-right");
                return {
                  type: "leftright",
                  mode: parser.mode,
                  body,
                  left: delim.text,
                  right: right.delim,
                  rightColor: right.color
                };
              },
              htmlBuilder: (group, options) => {
                assertParsed(group);
                const inner2 = buildExpression(group.body, options, true, ["mopen", "mclose"]);
                let innerHeight = 0;
                let innerDepth = 0;
                let hadMiddle = false;
                for (let i = 0; i < inner2.length; i++) {
                  if (inner2[i].isMiddle) {
                    hadMiddle = true;
                  } else {
                    innerHeight = Math.max(inner2[i].height, innerHeight);
                    innerDepth = Math.max(inner2[i].depth, innerDepth);
                  }
                }
                innerHeight *= options.sizeMultiplier;
                innerDepth *= options.sizeMultiplier;
                let leftDelim;
                if (group.left === ".") {
                  leftDelim = makeNullDelimiter(options, ["mopen"]);
                } else {
                  leftDelim = delimiter2.leftRightDelim(group.left, innerHeight, innerDepth, options, group.mode, ["mopen"]);
                }
                inner2.unshift(leftDelim);
                if (hadMiddle) {
                  for (let i = 1; i < inner2.length; i++) {
                    const middleDelim = inner2[i];
                    const isMiddle = middleDelim.isMiddle;
                    if (isMiddle) {
                      inner2[i] = delimiter2.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);
                    }
                  }
                }
                let rightDelim;
                if (group.right === ".") {
                  rightDelim = makeNullDelimiter(options, ["mclose"]);
                } else {
                  const colorOptions = group.rightColor ? options.withColor(group.rightColor) : options;
                  rightDelim = delimiter2.leftRightDelim(group.right, innerHeight, innerDepth, colorOptions, group.mode, ["mclose"]);
                }
                inner2.push(rightDelim);
                return buildCommon.makeSpan(["minner"], inner2, options);
              },
              mathmlBuilder: (group, options) => {
                assertParsed(group);
                const inner2 = buildMathML_buildExpression(group.body, options);
                if (group.left !== ".") {
                  const leftNode = new mathMLTree.MathNode("mo", [makeText(group.left, group.mode)]);
                  leftNode.setAttribute("fence", "true");
                  inner2.unshift(leftNode);
                }
                if (group.right !== ".") {
                  const rightNode = new mathMLTree.MathNode("mo", [makeText(group.right, group.mode)]);
                  rightNode.setAttribute("fence", "true");
                  if (group.rightColor) {
                    rightNode.setAttribute("mathcolor", group.rightColor);
                  }
                  inner2.push(rightNode);
                }
                return makeRow(inner2);
              }
            });
            defineFunction({
              type: "middle",
              names: ["\\middle"],
              props: {
                numArgs: 1,
                primitive: true
              },
              handler: (context, args) => {
                const delim = checkDelimiter(args[0], context);
                if (!context.parser.leftrightDepth) {
                  throw new src_ParseError("\\middle without preceding \\left", delim);
                }
                return {
                  type: "middle",
                  mode: context.parser.mode,
                  delim: delim.text
                };
              },
              htmlBuilder: (group, options) => {
                let middleDelim;
                if (group.delim === ".") {
                  middleDelim = makeNullDelimiter(options, []);
                } else {
                  middleDelim = delimiter2.sizedDelim(group.delim, 1, options, group.mode, []);
                  const isMiddle = {
                    delim: group.delim,
                    options
                  };
                  middleDelim.isMiddle = isMiddle;
                }
                return middleDelim;
              },
              mathmlBuilder: (group, options) => {
                const textNode = group.delim === "\\vert" || group.delim === "|" ? makeText("|", "text") : makeText(group.delim, group.mode);
                const middleNode = new mathMLTree.MathNode("mo", [textNode]);
                middleNode.setAttribute("fence", "true");
                middleNode.setAttribute("lspace", "0.05em");
                middleNode.setAttribute("rspace", "0.05em");
                return middleNode;
              }
            });
            ;
            const enclose_htmlBuilder = (group, options) => {
              const inner2 = buildCommon.wrapFragment(buildGroup(group.body, options), options);
              const label = group.label.slice(1);
              let scale = options.sizeMultiplier;
              let img;
              let imgShift = 0;
              const isSingleChar = utils.isCharacterBox(group.body);
              if (label === "sout") {
                img = buildCommon.makeSpan(["stretchy", "sout"]);
                img.height = options.fontMetrics().defaultRuleThickness / scale;
                imgShift = -0.5 * options.fontMetrics().xHeight;
              } else if (label === "phase") {
                const lineWeight = calculateSize({
                  number: 0.6,
                  unit: "pt"
                }, options);
                const clearance = calculateSize({
                  number: 0.35,
                  unit: "ex"
                }, options);
                const newOptions = options.havingBaseSizing();
                scale = scale / newOptions.sizeMultiplier;
                const angleHeight = inner2.height + inner2.depth + lineWeight + clearance;
                inner2.style.paddingLeft = makeEm(angleHeight / 2 + lineWeight);
                const viewBoxHeight = Math.floor(1e3 * angleHeight * scale);
                const path3 = phasePath(viewBoxHeight);
                const svgNode2 = new SvgNode([new PathNode("phase", path3)], {
                  "width": "400em",
                  "height": makeEm(viewBoxHeight / 1e3),
                  "viewBox": "0 0 400000 " + viewBoxHeight,
                  "preserveAspectRatio": "xMinYMin slice"
                });
                img = buildCommon.makeSvgSpan(["hide-tail"], [svgNode2], options);
                img.style.height = makeEm(angleHeight);
                imgShift = inner2.depth + lineWeight + clearance;
              } else {
                if (/cancel/.test(label)) {
                  if (!isSingleChar) {
                    inner2.classes.push("cancel-pad");
                  }
                } else if (label === "angl") {
                  inner2.classes.push("anglpad");
                } else {
                  inner2.classes.push("boxpad");
                }
                let topPad = 0;
                let bottomPad = 0;
                let ruleThickness = 0;
                if (/box/.test(label)) {
                  ruleThickness = Math.max(
                    options.fontMetrics().fboxrule,
                    // default
                    options.minRuleThickness
                    // User override.
                  );
                  topPad = options.fontMetrics().fboxsep + (label === "colorbox" ? 0 : ruleThickness);
                  bottomPad = topPad;
                } else if (label === "angl") {
                  ruleThickness = Math.max(options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
                  topPad = 4 * ruleThickness;
                  bottomPad = Math.max(0, 0.25 - inner2.depth);
                } else {
                  topPad = isSingleChar ? 0.2 : 0;
                  bottomPad = topPad;
                }
                img = stretchy.encloseSpan(inner2, label, topPad, bottomPad, options);
                if (/fbox|boxed|fcolorbox/.test(label)) {
                  img.style.borderStyle = "solid";
                  img.style.borderWidth = makeEm(ruleThickness);
                } else if (label === "angl" && ruleThickness !== 0.049) {
                  img.style.borderTopWidth = makeEm(ruleThickness);
                  img.style.borderRightWidth = makeEm(ruleThickness);
                }
                imgShift = inner2.depth + bottomPad;
                if (group.backgroundColor) {
                  img.style.backgroundColor = group.backgroundColor;
                  if (group.borderColor) {
                    img.style.borderColor = group.borderColor;
                  }
                }
              }
              let vlist;
              if (group.backgroundColor) {
                vlist = buildCommon.makeVList({
                  positionType: "individualShift",
                  children: [
                    // Put the color background behind inner;
                    {
                      type: "elem",
                      elem: img,
                      shift: imgShift
                    },
                    {
                      type: "elem",
                      elem: inner2,
                      shift: 0
                    }
                  ]
                }, options);
              } else {
                const classes = /cancel|phase/.test(label) ? ["svg-align"] : [];
                vlist = buildCommon.makeVList({
                  positionType: "individualShift",
                  children: [
                    // Write the \cancel stroke on top of inner.
                    {
                      type: "elem",
                      elem: inner2,
                      shift: 0
                    },
                    {
                      type: "elem",
                      elem: img,
                      shift: imgShift,
                      wrapperClasses: classes
                    }
                  ]
                }, options);
              }
              if (/cancel/.test(label)) {
                vlist.height = inner2.height;
                vlist.depth = inner2.depth;
              }
              if (/cancel/.test(label) && !isSingleChar) {
                return buildCommon.makeSpan(["mord", "cancel-lap"], [vlist], options);
              } else {
                return buildCommon.makeSpan(["mord"], [vlist], options);
              }
            };
            const enclose_mathmlBuilder = (group, options) => {
              let fboxsep = 0;
              const node = new mathMLTree.MathNode(group.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildMathML_buildGroup(group.body, options)]);
              switch (group.label) {
                case "\\cancel":
                  node.setAttribute("notation", "updiagonalstrike");
                  break;
                case "\\bcancel":
                  node.setAttribute("notation", "downdiagonalstrike");
                  break;
                case "\\phase":
                  node.setAttribute("notation", "phasorangle");
                  break;
                case "\\sout":
                  node.setAttribute("notation", "horizontalstrike");
                  break;
                case "\\fbox":
                  node.setAttribute("notation", "box");
                  break;
                case "\\angl":
                  node.setAttribute("notation", "actuarial");
                  break;
                case "\\fcolorbox":
                case "\\colorbox":
                  fboxsep = options.fontMetrics().fboxsep * options.fontMetrics().ptPerEm;
                  node.setAttribute("width", "+" + 2 * fboxsep + "pt");
                  node.setAttribute("height", "+" + 2 * fboxsep + "pt");
                  node.setAttribute("lspace", fboxsep + "pt");
                  node.setAttribute("voffset", fboxsep + "pt");
                  if (group.label === "\\fcolorbox") {
                    const thk = Math.max(
                      options.fontMetrics().fboxrule,
                      // default
                      options.minRuleThickness
                      // user override
                    );
                    node.setAttribute("style", "border: " + thk + "em solid " + String(group.borderColor));
                  }
                  break;
                case "\\xcancel":
                  node.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
                  break;
              }
              if (group.backgroundColor) {
                node.setAttribute("mathbackground", group.backgroundColor);
              }
              return node;
            };
            defineFunction({
              type: "enclose",
              names: ["\\colorbox"],
              props: {
                numArgs: 2,
                allowedInText: true,
                argTypes: ["color", "text"]
              },
              handler(_ref, args, optArgs) {
                let {
                  parser,
                  funcName
                } = _ref;
                const color2 = assertNodeType(args[0], "color-token").color;
                const body = args[1];
                return {
                  type: "enclose",
                  mode: parser.mode,
                  label: funcName,
                  backgroundColor: color2,
                  body
                };
              },
              htmlBuilder: enclose_htmlBuilder,
              mathmlBuilder: enclose_mathmlBuilder
            });
            defineFunction({
              type: "enclose",
              names: ["\\fcolorbox"],
              props: {
                numArgs: 3,
                allowedInText: true,
                argTypes: ["color", "color", "text"]
              },
              handler(_ref2, args, optArgs) {
                let {
                  parser,
                  funcName
                } = _ref2;
                const borderColor = assertNodeType(args[0], "color-token").color;
                const backgroundColor = assertNodeType(args[1], "color-token").color;
                const body = args[2];
                return {
                  type: "enclose",
                  mode: parser.mode,
                  label: funcName,
                  backgroundColor,
                  borderColor,
                  body
                };
              },
              htmlBuilder: enclose_htmlBuilder,
              mathmlBuilder: enclose_mathmlBuilder
            });
            defineFunction({
              type: "enclose",
              names: ["\\fbox"],
              props: {
                numArgs: 1,
                argTypes: ["hbox"],
                allowedInText: true
              },
              handler(_ref3, args) {
                let {
                  parser
                } = _ref3;
                return {
                  type: "enclose",
                  mode: parser.mode,
                  label: "\\fbox",
                  body: args[0]
                };
              }
            });
            defineFunction({
              type: "enclose",
              names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
              props: {
                numArgs: 1
              },
              handler(_ref4, args) {
                let {
                  parser,
                  funcName
                } = _ref4;
                const body = args[0];
                return {
                  type: "enclose",
                  mode: parser.mode,
                  label: funcName,
                  body
                };
              },
              htmlBuilder: enclose_htmlBuilder,
              mathmlBuilder: enclose_mathmlBuilder
            });
            defineFunction({
              type: "enclose",
              names: ["\\angl"],
              props: {
                numArgs: 1,
                argTypes: ["hbox"],
                allowedInText: false
              },
              handler(_ref5, args) {
                let {
                  parser
                } = _ref5;
                return {
                  type: "enclose",
                  mode: parser.mode,
                  label: "\\angl",
                  body: args[0]
                };
              }
            });
            ;
            const _environments = {};
            function defineEnvironment(_ref) {
              let {
                type: type2,
                names,
                props,
                handler,
                htmlBuilder: htmlBuilder2,
                mathmlBuilder: mathmlBuilder2
              } = _ref;
              const data2 = {
                type: type2,
                numArgs: props.numArgs || 0,
                allowedInText: false,
                numOptionalArgs: 0,
                handler
              };
              for (let i = 0; i < names.length; ++i) {
                _environments[names[i]] = data2;
              }
              if (htmlBuilder2) {
                _htmlGroupBuilders[type2] = htmlBuilder2;
              }
              if (mathmlBuilder2) {
                _mathmlGroupBuilders[type2] = mathmlBuilder2;
              }
            }
            ;
            const _macros = {};
            function defineMacro(name2, body) {
              _macros[name2] = body;
            }
            ;
            class SourceLocation {
              // The + prefix indicates that these fields aren't writeable
              // Lexer holding the input string.
              // Start offset, zero-based inclusive.
              // End offset, zero-based exclusive.
              constructor(lexer, start2, end2) {
                this.lexer = void 0;
                this.start = void 0;
                this.end = void 0;
                this.lexer = lexer;
                this.start = start2;
                this.end = end2;
              }
              /**
               * Merges two `SourceLocation`s from location providers, given they are
               * provided in order of appearance.
               * - Returns the first one's location if only the first is provided.
               * - Returns a merged range of the first and the last if both are provided
               *   and their lexers match.
               * - Otherwise, returns null.
               */
              static range(first2, second) {
                if (!second) {
                  return first2 && first2.loc;
                } else if (!first2 || !first2.loc || !second.loc || first2.loc.lexer !== second.loc.lexer) {
                  return null;
                } else {
                  return new SourceLocation(first2.loc.lexer, first2.loc.start, second.loc.end);
                }
              }
            }
            ;
            class Token2 {
              // don't expand the token
              // used in \noexpand
              constructor(text3, loc) {
                this.text = void 0;
                this.loc = void 0;
                this.noexpand = void 0;
                this.treatAsRelax = void 0;
                this.text = text3;
                this.loc = loc;
              }
              /**
               * Given a pair of tokens (this and endToken), compute a `Token` encompassing
               * the whole input range enclosed by these two.
               */
              range(endToken, text3) {
                return new Token2(text3, SourceLocation.range(this, endToken));
              }
            }
            ;
            function getHLines(parser) {
              const hlineInfo = [];
              parser.consumeSpaces();
              let nxt = parser.fetch().text;
              if (nxt === "\\relax") {
                parser.consume();
                parser.consumeSpaces();
                nxt = parser.fetch().text;
              }
              while (nxt === "\\hline" || nxt === "\\hdashline") {
                parser.consume();
                hlineInfo.push(nxt === "\\hdashline");
                parser.consumeSpaces();
                nxt = parser.fetch().text;
              }
              return hlineInfo;
            }
            const validateAmsEnvironmentContext = (context) => {
              const settings = context.parser.settings;
              if (!settings.displayMode) {
                throw new src_ParseError("{" + context.envName + "} can be used only in display mode.");
              }
            };
            function getAutoTag(name2) {
              if (name2.indexOf("ed") === -1) {
                return name2.indexOf("*") === -1;
              }
            }
            function parseArray(parser, _ref, style) {
              let {
                hskipBeforeAndAfter,
                addJot,
                cols,
                arraystretch,
                colSeparationType,
                autoTag,
                singleRow,
                emptySingleRow,
                maxNumCols,
                leqno
              } = _ref;
              parser.gullet.beginGroup();
              if (!singleRow) {
                parser.gullet.macros.set("\\cr", "\\\\\\relax");
              }
              if (!arraystretch) {
                const stretch = parser.gullet.expandMacroAsText("\\arraystretch");
                if (stretch == null) {
                  arraystretch = 1;
                } else {
                  arraystretch = parseFloat(stretch);
                  if (!arraystretch || arraystretch < 0) {
                    throw new src_ParseError("Invalid \\arraystretch: " + stretch);
                  }
                }
              }
              parser.gullet.beginGroup();
              let row = [];
              const body = [row];
              const rowGaps = [];
              const hLinesBeforeRow = [];
              const tags = autoTag != null ? [] : void 0;
              function beginRow() {
                if (autoTag) {
                  parser.gullet.macros.set("\\@eqnsw", "1", true);
                }
              }
              function endRow() {
                if (tags) {
                  if (parser.gullet.macros.get("\\df@tag")) {
                    tags.push(parser.subparse([new Token2("\\df@tag")]));
                    parser.gullet.macros.set("\\df@tag", void 0, true);
                  } else {
                    tags.push(Boolean(autoTag) && parser.gullet.macros.get("\\@eqnsw") === "1");
                  }
                }
              }
              beginRow();
              hLinesBeforeRow.push(getHLines(parser));
              while (true) {
                let cell = parser.parseExpression(false, singleRow ? "\\end" : "\\\\");
                parser.gullet.endGroup();
                parser.gullet.beginGroup();
                cell = {
                  type: "ordgroup",
                  mode: parser.mode,
                  body: cell
                };
                if (style) {
                  cell = {
                    type: "styling",
                    mode: parser.mode,
                    style,
                    body: [cell]
                  };
                }
                row.push(cell);
                const next2 = parser.fetch().text;
                if (next2 === "&") {
                  if (maxNumCols && row.length === maxNumCols) {
                    if (singleRow || colSeparationType) {
                      throw new src_ParseError("Too many tab characters: &", parser.nextToken);
                    } else {
                      parser.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
                    }
                  }
                  parser.consume();
                } else if (next2 === "\\end") {
                  endRow();
                  if (row.length === 1 && cell.type === "styling" && cell.body[0].body.length === 0 && (body.length > 1 || !emptySingleRow)) {
                    body.pop();
                  }
                  if (hLinesBeforeRow.length < body.length + 1) {
                    hLinesBeforeRow.push([]);
                  }
                  break;
                } else if (next2 === "\\\\") {
                  parser.consume();
                  let size;
                  if (parser.gullet.future().text !== " ") {
                    size = parser.parseSizeGroup(true);
                  }
                  rowGaps.push(size ? size.value : null);
                  endRow();
                  hLinesBeforeRow.push(getHLines(parser));
                  row = [];
                  body.push(row);
                  beginRow();
                } else {
                  throw new src_ParseError("Expected & or \\\\ or \\cr or \\end", parser.nextToken);
                }
              }
              parser.gullet.endGroup();
              parser.gullet.endGroup();
              return {
                type: "array",
                mode: parser.mode,
                addJot,
                arraystretch,
                body,
                cols,
                rowGaps,
                hskipBeforeAndAfter,
                hLinesBeforeRow,
                colSeparationType,
                tags,
                leqno
              };
            }
            function dCellStyle(envName) {
              if (envName.slice(0, 1) === "d") {
                return "display";
              } else {
                return "text";
              }
            }
            const array_htmlBuilder = function(group, options) {
              let r;
              let c;
              const nr = group.body.length;
              const hLinesBeforeRow = group.hLinesBeforeRow;
              let nc = 0;
              let body = new Array(nr);
              const hlines = [];
              const ruleThickness = Math.max(
                // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
                options.fontMetrics().arrayRuleWidth,
                options.minRuleThickness
                // User override.
              );
              const pt = 1 / options.fontMetrics().ptPerEm;
              let arraycolsep = 5 * pt;
              if (group.colSeparationType && group.colSeparationType === "small") {
                const localMultiplier = options.havingStyle(src_Style.SCRIPT).sizeMultiplier;
                arraycolsep = 0.2778 * (localMultiplier / options.sizeMultiplier);
              }
              const baselineskip = group.colSeparationType === "CD" ? calculateSize({
                number: 3,
                unit: "ex"
              }, options) : 12 * pt;
              const jot = 3 * pt;
              const arrayskip = group.arraystretch * baselineskip;
              const arstrutHeight = 0.7 * arrayskip;
              const arstrutDepth = 0.3 * arrayskip;
              let totalHeight = 0;
              function setHLinePos(hlinesInGap) {
                for (let i = 0; i < hlinesInGap.length; ++i) {
                  if (i > 0) {
                    totalHeight += 0.25;
                  }
                  hlines.push({
                    pos: totalHeight,
                    isDashed: hlinesInGap[i]
                  });
                }
              }
              setHLinePos(hLinesBeforeRow[0]);
              for (r = 0; r < group.body.length; ++r) {
                const inrow = group.body[r];
                let height = arstrutHeight;
                let depth = arstrutDepth;
                if (nc < inrow.length) {
                  nc = inrow.length;
                }
                const outrow = new Array(inrow.length);
                for (c = 0; c < inrow.length; ++c) {
                  const elt = buildGroup(inrow[c], options);
                  if (depth < elt.depth) {
                    depth = elt.depth;
                  }
                  if (height < elt.height) {
                    height = elt.height;
                  }
                  outrow[c] = elt;
                }
                const rowGap = group.rowGaps[r];
                let gap = 0;
                if (rowGap) {
                  gap = calculateSize(rowGap, options);
                  if (gap > 0) {
                    gap += arstrutDepth;
                    if (depth < gap) {
                      depth = gap;
                    }
                    gap = 0;
                  }
                }
                if (group.addJot) {
                  depth += jot;
                }
                outrow.height = height;
                outrow.depth = depth;
                totalHeight += height;
                outrow.pos = totalHeight;
                totalHeight += depth + gap;
                body[r] = outrow;
                setHLinePos(hLinesBeforeRow[r + 1]);
              }
              const offset = totalHeight / 2 + options.fontMetrics().axisHeight;
              const colDescriptions = group.cols || [];
              const cols = [];
              let colSep;
              let colDescrNum;
              const tagSpans = [];
              if (group.tags && group.tags.some((tag) => tag)) {
                for (r = 0; r < nr; ++r) {
                  const rw = body[r];
                  const shift = rw.pos - offset;
                  const tag = group.tags[r];
                  let tagSpan;
                  if (tag === true) {
                    tagSpan = buildCommon.makeSpan(["eqn-num"], [], options);
                  } else if (tag === false) {
                    tagSpan = buildCommon.makeSpan([], [], options);
                  } else {
                    tagSpan = buildCommon.makeSpan([], buildExpression(tag, options, true), options);
                  }
                  tagSpan.depth = rw.depth;
                  tagSpan.height = rw.height;
                  tagSpans.push({
                    type: "elem",
                    elem: tagSpan,
                    shift
                  });
                }
              }
              for (
                c = 0, colDescrNum = 0;
                // Continue while either there are more columns or more column
                // descriptions, so trailing separators don't get lost.
                c < nc || colDescrNum < colDescriptions.length;
                ++c, ++colDescrNum
              ) {
                let colDescr = colDescriptions[colDescrNum] || {};
                let firstSeparator = true;
                while (colDescr.type === "separator") {
                  if (!firstSeparator) {
                    colSep = buildCommon.makeSpan(["arraycolsep"], []);
                    colSep.style.width = makeEm(options.fontMetrics().doubleRuleSep);
                    cols.push(colSep);
                  }
                  if (colDescr.separator === "|" || colDescr.separator === ":") {
                    const lineType = colDescr.separator === "|" ? "solid" : "dashed";
                    const separator = buildCommon.makeSpan(["vertical-separator"], [], options);
                    separator.style.height = makeEm(totalHeight);
                    separator.style.borderRightWidth = makeEm(ruleThickness);
                    separator.style.borderRightStyle = lineType;
                    separator.style.margin = "0 " + makeEm(-ruleThickness / 2);
                    const shift = totalHeight - offset;
                    if (shift) {
                      separator.style.verticalAlign = makeEm(-shift);
                    }
                    cols.push(separator);
                  } else {
                    throw new src_ParseError("Invalid separator type: " + colDescr.separator);
                  }
                  colDescrNum++;
                  colDescr = colDescriptions[colDescrNum] || {};
                  firstSeparator = false;
                }
                if (c >= nc) {
                  continue;
                }
                let sepwidth;
                if (c > 0 || group.hskipBeforeAndAfter) {
                  sepwidth = utils.deflt(colDescr.pregap, arraycolsep);
                  if (sepwidth !== 0) {
                    colSep = buildCommon.makeSpan(["arraycolsep"], []);
                    colSep.style.width = makeEm(sepwidth);
                    cols.push(colSep);
                  }
                }
                let col = [];
                for (r = 0; r < nr; ++r) {
                  const row = body[r];
                  const elem = row[c];
                  if (!elem) {
                    continue;
                  }
                  const shift = row.pos - offset;
                  elem.depth = row.depth;
                  elem.height = row.height;
                  col.push({
                    type: "elem",
                    elem,
                    shift
                  });
                }
                col = buildCommon.makeVList({
                  positionType: "individualShift",
                  children: col
                }, options);
                col = buildCommon.makeSpan(["col-align-" + (colDescr.align || "c")], [col]);
                cols.push(col);
                if (c < nc - 1 || group.hskipBeforeAndAfter) {
                  sepwidth = utils.deflt(colDescr.postgap, arraycolsep);
                  if (sepwidth !== 0) {
                    colSep = buildCommon.makeSpan(["arraycolsep"], []);
                    colSep.style.width = makeEm(sepwidth);
                    cols.push(colSep);
                  }
                }
              }
              body = buildCommon.makeSpan(["mtable"], cols);
              if (hlines.length > 0) {
                const line = buildCommon.makeLineSpan("hline", options, ruleThickness);
                const dashes = buildCommon.makeLineSpan("hdashline", options, ruleThickness);
                const vListElems = [{
                  type: "elem",
                  elem: body,
                  shift: 0
                }];
                while (hlines.length > 0) {
                  const hline = hlines.pop();
                  const lineShift = hline.pos - offset;
                  if (hline.isDashed) {
                    vListElems.push({
                      type: "elem",
                      elem: dashes,
                      shift: lineShift
                    });
                  } else {
                    vListElems.push({
                      type: "elem",
                      elem: line,
                      shift: lineShift
                    });
                  }
                }
                body = buildCommon.makeVList({
                  positionType: "individualShift",
                  children: vListElems
                }, options);
              }
              if (tagSpans.length === 0) {
                return buildCommon.makeSpan(["mord"], [body], options);
              } else {
                let eqnNumCol = buildCommon.makeVList({
                  positionType: "individualShift",
                  children: tagSpans
                }, options);
                eqnNumCol = buildCommon.makeSpan(["tag"], [eqnNumCol], options);
                return buildCommon.makeFragment([body, eqnNumCol]);
              }
            };
            const alignMap = {
              c: "center ",
              l: "left ",
              r: "right "
            };
            const array_mathmlBuilder = function(group, options) {
              const tbl = [];
              const glue = new mathMLTree.MathNode("mtd", [], ["mtr-glue"]);
              const tag = new mathMLTree.MathNode("mtd", [], ["mml-eqn-num"]);
              for (let i = 0; i < group.body.length; i++) {
                const rw = group.body[i];
                const row = [];
                for (let j2 = 0; j2 < rw.length; j2++) {
                  row.push(new mathMLTree.MathNode("mtd", [buildMathML_buildGroup(rw[j2], options)]));
                }
                if (group.tags && group.tags[i]) {
                  row.unshift(glue);
                  row.push(glue);
                  if (group.leqno) {
                    row.unshift(tag);
                  } else {
                    row.push(tag);
                  }
                }
                tbl.push(new mathMLTree.MathNode("mtr", row));
              }
              let table2 = new mathMLTree.MathNode("mtable", tbl);
              const gap = group.arraystretch === 0.5 ? 0.1 : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);
              table2.setAttribute("rowspacing", makeEm(gap));
              let menclose = "";
              let align = "";
              if (group.cols && group.cols.length > 0) {
                const cols = group.cols;
                let columnLines = "";
                let prevTypeWasAlign = false;
                let iStart = 0;
                let iEnd = cols.length;
                if (cols[0].type === "separator") {
                  menclose += "top ";
                  iStart = 1;
                }
                if (cols[cols.length - 1].type === "separator") {
                  menclose += "bottom ";
                  iEnd -= 1;
                }
                for (let i = iStart; i < iEnd; i++) {
                  if (cols[i].type === "align") {
                    align += alignMap[cols[i].align];
                    if (prevTypeWasAlign) {
                      columnLines += "none ";
                    }
                    prevTypeWasAlign = true;
                  } else if (cols[i].type === "separator") {
                    if (prevTypeWasAlign) {
                      columnLines += cols[i].separator === "|" ? "solid " : "dashed ";
                      prevTypeWasAlign = false;
                    }
                  }
                }
                table2.setAttribute("columnalign", align.trim());
                if (/[sd]/.test(columnLines)) {
                  table2.setAttribute("columnlines", columnLines.trim());
                }
              }
              if (group.colSeparationType === "align") {
                const cols = group.cols || [];
                let spacing2 = "";
                for (let i = 1; i < cols.length; i++) {
                  spacing2 += i % 2 ? "0em " : "1em ";
                }
                table2.setAttribute("columnspacing", spacing2.trim());
              } else if (group.colSeparationType === "alignat" || group.colSeparationType === "gather") {
                table2.setAttribute("columnspacing", "0em");
              } else if (group.colSeparationType === "small") {
                table2.setAttribute("columnspacing", "0.2778em");
              } else if (group.colSeparationType === "CD") {
                table2.setAttribute("columnspacing", "0.5em");
              } else {
                table2.setAttribute("columnspacing", "1em");
              }
              let rowLines = "";
              const hlines = group.hLinesBeforeRow;
              menclose += hlines[0].length > 0 ? "left " : "";
              menclose += hlines[hlines.length - 1].length > 0 ? "right " : "";
              for (let i = 1; i < hlines.length - 1; i++) {
                rowLines += hlines[i].length === 0 ? "none " : hlines[i][0] ? "dashed " : "solid ";
              }
              if (/[sd]/.test(rowLines)) {
                table2.setAttribute("rowlines", rowLines.trim());
              }
              if (menclose !== "") {
                table2 = new mathMLTree.MathNode("menclose", [table2]);
                table2.setAttribute("notation", menclose.trim());
              }
              if (group.arraystretch && group.arraystretch < 1) {
                table2 = new mathMLTree.MathNode("mstyle", [table2]);
                table2.setAttribute("scriptlevel", "1");
              }
              return table2;
            };
            const alignedHandler = function(context, args) {
              if (context.envName.indexOf("ed") === -1) {
                validateAmsEnvironmentContext(context);
              }
              const cols = [];
              const separationType = context.envName.indexOf("at") > -1 ? "alignat" : "align";
              const isSplit = context.envName === "split";
              const res = parseArray(context.parser, {
                cols,
                addJot: true,
                autoTag: isSplit ? void 0 : getAutoTag(context.envName),
                emptySingleRow: true,
                colSeparationType: separationType,
                maxNumCols: isSplit ? 2 : void 0,
                leqno: context.parser.settings.leqno
              }, "display");
              let numMaths;
              let numCols = 0;
              const emptyGroup = {
                type: "ordgroup",
                mode: context.mode,
                body: []
              };
              if (args[0] && args[0].type === "ordgroup") {
                let arg0 = "";
                for (let i = 0; i < args[0].body.length; i++) {
                  const textord2 = assertNodeType(args[0].body[i], "textord");
                  arg0 += textord2.text;
                }
                numMaths = Number(arg0);
                numCols = numMaths * 2;
              }
              const isAligned = !numCols;
              res.body.forEach(function(row) {
                for (let i = 1; i < row.length; i += 2) {
                  const styling = assertNodeType(row[i], "styling");
                  const ordgroup = assertNodeType(styling.body[0], "ordgroup");
                  ordgroup.body.unshift(emptyGroup);
                }
                if (!isAligned) {
                  const curMaths = row.length / 2;
                  if (numMaths < curMaths) {
                    throw new src_ParseError("Too many math in a row: " + ("expected " + numMaths + ", but got " + curMaths), row[0]);
                  }
                } else if (numCols < row.length) {
                  numCols = row.length;
                }
              });
              for (let i = 0; i < numCols; ++i) {
                let align = "r";
                let pregap = 0;
                if (i % 2 === 1) {
                  align = "l";
                } else if (i > 0 && isAligned) {
                  pregap = 1;
                }
                cols[i] = {
                  type: "align",
                  align,
                  pregap,
                  postgap: 0
                };
              }
              res.colSeparationType = isAligned ? "align" : "alignat";
              return res;
            };
            defineEnvironment({
              type: "array",
              names: ["array", "darray"],
              props: {
                numArgs: 1
              },
              handler(context, args) {
                const symNode = checkSymbolNodeType(args[0]);
                const colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
                const cols = colalign.map(function(nde) {
                  const node = assertSymbolNodeType(nde);
                  const ca = node.text;
                  if ("lcr".indexOf(ca) !== -1) {
                    return {
                      type: "align",
                      align: ca
                    };
                  } else if (ca === "|") {
                    return {
                      type: "separator",
                      separator: "|"
                    };
                  } else if (ca === ":") {
                    return {
                      type: "separator",
                      separator: ":"
                    };
                  }
                  throw new src_ParseError("Unknown column alignment: " + ca, nde);
                });
                const res = {
                  cols,
                  hskipBeforeAndAfter: true,
                  // \@preamble in lttab.dtx
                  maxNumCols: cols.length
                };
                return parseArray(context.parser, res, dCellStyle(context.envName));
              },
              htmlBuilder: array_htmlBuilder,
              mathmlBuilder: array_mathmlBuilder
            });
            defineEnvironment({
              type: "array",
              names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
              props: {
                numArgs: 0
              },
              handler(context) {
                const delimiters2 = {
                  "matrix": null,
                  "pmatrix": ["(", ")"],
                  "bmatrix": ["[", "]"],
                  "Bmatrix": ["\\{", "\\}"],
                  "vmatrix": ["|", "|"],
                  "Vmatrix": ["\\Vert", "\\Vert"]
                }[context.envName.replace("*", "")];
                let colAlign = "c";
                const payload = {
                  hskipBeforeAndAfter: false,
                  cols: [{
                    type: "align",
                    align: colAlign
                  }]
                };
                if (context.envName.charAt(context.envName.length - 1) === "*") {
                  const parser = context.parser;
                  parser.consumeSpaces();
                  if (parser.fetch().text === "[") {
                    parser.consume();
                    parser.consumeSpaces();
                    colAlign = parser.fetch().text;
                    if ("lcr".indexOf(colAlign) === -1) {
                      throw new src_ParseError("Expected l or c or r", parser.nextToken);
                    }
                    parser.consume();
                    parser.consumeSpaces();
                    parser.expect("]");
                    parser.consume();
                    payload.cols = [{
                      type: "align",
                      align: colAlign
                    }];
                  }
                }
                const res = parseArray(context.parser, payload, dCellStyle(context.envName));
                const numCols = Math.max(0, ...res.body.map((row) => row.length));
                res.cols = new Array(numCols).fill({
                  type: "align",
                  align: colAlign
                });
                return delimiters2 ? {
                  type: "leftright",
                  mode: context.mode,
                  body: [res],
                  left: delimiters2[0],
                  right: delimiters2[1],
                  rightColor: void 0
                  // \right uninfluenced by \color in array
                } : res;
              },
              htmlBuilder: array_htmlBuilder,
              mathmlBuilder: array_mathmlBuilder
            });
            defineEnvironment({
              type: "array",
              names: ["smallmatrix"],
              props: {
                numArgs: 0
              },
              handler(context) {
                const payload = {
                  arraystretch: 0.5
                };
                const res = parseArray(context.parser, payload, "script");
                res.colSeparationType = "small";
                return res;
              },
              htmlBuilder: array_htmlBuilder,
              mathmlBuilder: array_mathmlBuilder
            });
            defineEnvironment({
              type: "array",
              names: ["subarray"],
              props: {
                numArgs: 1
              },
              handler(context, args) {
                const symNode = checkSymbolNodeType(args[0]);
                const colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
                const cols = colalign.map(function(nde) {
                  const node = assertSymbolNodeType(nde);
                  const ca = node.text;
                  if ("lc".indexOf(ca) !== -1) {
                    return {
                      type: "align",
                      align: ca
                    };
                  }
                  throw new src_ParseError("Unknown column alignment: " + ca, nde);
                });
                if (cols.length > 1) {
                  throw new src_ParseError("{subarray} can contain only one column");
                }
                let res = {
                  cols,
                  hskipBeforeAndAfter: false,
                  arraystretch: 0.5
                };
                res = parseArray(context.parser, res, "script");
                if (res.body.length > 0 && res.body[0].length > 1) {
                  throw new src_ParseError("{subarray} can contain only one column");
                }
                return res;
              },
              htmlBuilder: array_htmlBuilder,
              mathmlBuilder: array_mathmlBuilder
            });
            defineEnvironment({
              type: "array",
              names: ["cases", "dcases", "rcases", "drcases"],
              props: {
                numArgs: 0
              },
              handler(context) {
                const payload = {
                  arraystretch: 1.2,
                  cols: [{
                    type: "align",
                    align: "l",
                    pregap: 0,
                    // TODO(kevinb) get the current style.
                    // For now we use the metrics for TEXT style which is what we were
                    // doing before.  Before attempting to get the current style we
                    // should look at TeX's behavior especially for \over and matrices.
                    postgap: 1
                    /* 1em quad */
                  }, {
                    type: "align",
                    align: "l",
                    pregap: 0,
                    postgap: 0
                  }]
                };
                const res = parseArray(context.parser, payload, dCellStyle(context.envName));
                return {
                  type: "leftright",
                  mode: context.mode,
                  body: [res],
                  left: context.envName.indexOf("r") > -1 ? "." : "\\{",
                  right: context.envName.indexOf("r") > -1 ? "\\}" : ".",
                  rightColor: void 0
                };
              },
              htmlBuilder: array_htmlBuilder,
              mathmlBuilder: array_mathmlBuilder
            });
            defineEnvironment({
              type: "array",
              names: ["align", "align*", "aligned", "split"],
              props: {
                numArgs: 0
              },
              handler: alignedHandler,
              htmlBuilder: array_htmlBuilder,
              mathmlBuilder: array_mathmlBuilder
            });
            defineEnvironment({
              type: "array",
              names: ["gathered", "gather", "gather*"],
              props: {
                numArgs: 0
              },
              handler(context) {
                if (["gather", "gather*"].includes(context.envName)) {
                  validateAmsEnvironmentContext(context);
                }
                const res = {
                  cols: [{
                    type: "align",
                    align: "c"
                  }],
                  addJot: true,
                  colSeparationType: "gather",
                  autoTag: getAutoTag(context.envName),
                  emptySingleRow: true,
                  leqno: context.parser.settings.leqno
                };
                return parseArray(context.parser, res, "display");
              },
              htmlBuilder: array_htmlBuilder,
              mathmlBuilder: array_mathmlBuilder
            });
            defineEnvironment({
              type: "array",
              names: ["alignat", "alignat*", "alignedat"],
              props: {
                numArgs: 1
              },
              handler: alignedHandler,
              htmlBuilder: array_htmlBuilder,
              mathmlBuilder: array_mathmlBuilder
            });
            defineEnvironment({
              type: "array",
              names: ["equation", "equation*"],
              props: {
                numArgs: 0
              },
              handler(context) {
                validateAmsEnvironmentContext(context);
                const res = {
                  autoTag: getAutoTag(context.envName),
                  emptySingleRow: true,
                  singleRow: true,
                  maxNumCols: 1,
                  leqno: context.parser.settings.leqno
                };
                return parseArray(context.parser, res, "display");
              },
              htmlBuilder: array_htmlBuilder,
              mathmlBuilder: array_mathmlBuilder
            });
            defineEnvironment({
              type: "array",
              names: ["CD"],
              props: {
                numArgs: 0
              },
              handler(context) {
                validateAmsEnvironmentContext(context);
                return parseCD(context.parser);
              },
              htmlBuilder: array_htmlBuilder,
              mathmlBuilder: array_mathmlBuilder
            });
            defineMacro("\\nonumber", "\\gdef\\@eqnsw{0}");
            defineMacro("\\notag", "\\nonumber");
            defineFunction({
              type: "text",
              // Doesn't matter what this is.
              names: ["\\hline", "\\hdashline"],
              props: {
                numArgs: 0,
                allowedInText: true,
                allowedInMath: true
              },
              handler(context, args) {
                throw new src_ParseError(context.funcName + " valid only within array environment");
              }
            });
            ;
            const environments = _environments;
            var src_environments = environments;
            ;
            defineFunction({
              type: "environment",
              names: ["\\begin", "\\end"],
              props: {
                numArgs: 1,
                argTypes: ["text"]
              },
              handler(_ref, args) {
                let {
                  parser,
                  funcName
                } = _ref;
                const nameGroup = args[0];
                if (nameGroup.type !== "ordgroup") {
                  throw new src_ParseError("Invalid environment name", nameGroup);
                }
                let envName = "";
                for (let i = 0; i < nameGroup.body.length; ++i) {
                  envName += assertNodeType(nameGroup.body[i], "textord").text;
                }
                if (funcName === "\\begin") {
                  if (!src_environments.hasOwnProperty(envName)) {
                    throw new src_ParseError("No such environment: " + envName, nameGroup);
                  }
                  const env = src_environments[envName];
                  const {
                    args: args2,
                    optArgs
                  } = parser.parseArguments("\\begin{" + envName + "}", env);
                  const context = {
                    mode: parser.mode,
                    envName,
                    parser
                  };
                  const result = env.handler(context, args2, optArgs);
                  parser.expect("\\end", false);
                  const endNameToken = parser.nextToken;
                  const end2 = assertNodeType(parser.parseFunction(), "environment");
                  if (end2.name !== envName) {
                    throw new src_ParseError("Mismatch: \\begin{" + envName + "} matched by \\end{" + end2.name + "}", endNameToken);
                  }
                  return result;
                }
                return {
                  type: "environment",
                  mode: parser.mode,
                  name: envName,
                  nameGroup
                };
              }
            });
            ;
            const font_htmlBuilder = (group, options) => {
              const font = group.font;
              const newOptions = options.withFont(font);
              return buildGroup(group.body, newOptions);
            };
            const font_mathmlBuilder = (group, options) => {
              const font = group.font;
              const newOptions = options.withFont(font);
              return buildMathML_buildGroup(group.body, newOptions);
            };
            const fontAliases = {
              "\\Bbb": "\\mathbb",
              "\\bold": "\\mathbf",
              "\\frak": "\\mathfrak",
              "\\bm": "\\boldsymbol"
            };
            defineFunction({
              type: "font",
              names: [
                // styles, except \boldsymbol defined below
                "\\mathrm",
                "\\mathit",
                "\\mathbf",
                "\\mathnormal",
                "\\mathsfit",
                // families
                "\\mathbb",
                "\\mathcal",
                "\\mathfrak",
                "\\mathscr",
                "\\mathsf",
                "\\mathtt",
                // aliases, except \bm defined below
                "\\Bbb",
                "\\bold",
                "\\frak"
              ],
              props: {
                numArgs: 1,
                allowedInArgument: true
              },
              handler: (_ref, args) => {
                let {
                  parser,
                  funcName
                } = _ref;
                const body = normalizeArgument(args[0]);
                let func = funcName;
                if (func in fontAliases) {
                  func = fontAliases[func];
                }
                return {
                  type: "font",
                  mode: parser.mode,
                  font: func.slice(1),
                  body
                };
              },
              htmlBuilder: font_htmlBuilder,
              mathmlBuilder: font_mathmlBuilder
            });
            defineFunction({
              type: "mclass",
              names: ["\\boldsymbol", "\\bm"],
              props: {
                numArgs: 1
              },
              handler: (_ref2, args) => {
                let {
                  parser
                } = _ref2;
                const body = args[0];
                const isCharacterBox2 = utils.isCharacterBox(body);
                return {
                  type: "mclass",
                  mode: parser.mode,
                  mclass: binrelClass(body),
                  body: [{
                    type: "font",
                    mode: parser.mode,
                    font: "boldsymbol",
                    body
                  }],
                  isCharacterBox: isCharacterBox2
                };
              }
            });
            defineFunction({
              type: "font",
              names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
              props: {
                numArgs: 0,
                allowedInText: true
              },
              handler: (_ref3, args) => {
                let {
                  parser,
                  funcName,
                  breakOnTokenText
                } = _ref3;
                const {
                  mode
                } = parser;
                const body = parser.parseExpression(true, breakOnTokenText);
                const style = "math" + funcName.slice(1);
                return {
                  type: "font",
                  mode,
                  font: style,
                  body: {
                    type: "ordgroup",
                    mode: parser.mode,
                    body
                  }
                };
              },
              htmlBuilder: font_htmlBuilder,
              mathmlBuilder: font_mathmlBuilder
            });
            ;
            const adjustStyle = (size, originalStyle) => {
              let style = originalStyle;
              if (size === "display") {
                style = style.id >= src_Style.SCRIPT.id ? style.text() : src_Style.DISPLAY;
              } else if (size === "text" && style.size === src_Style.DISPLAY.size) {
                style = src_Style.TEXT;
              } else if (size === "script") {
                style = src_Style.SCRIPT;
              } else if (size === "scriptscript") {
                style = src_Style.SCRIPTSCRIPT;
              }
              return style;
            };
            const genfrac_htmlBuilder = (group, options) => {
              const style = adjustStyle(group.size, options.style);
              const nstyle = style.fracNum();
              const dstyle = style.fracDen();
              let newOptions;
              newOptions = options.havingStyle(nstyle);
              const numerm = buildGroup(group.numer, newOptions, options);
              if (group.continued) {
                const hStrut = 8.5 / options.fontMetrics().ptPerEm;
                const dStrut = 3.5 / options.fontMetrics().ptPerEm;
                numerm.height = numerm.height < hStrut ? hStrut : numerm.height;
                numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;
              }
              newOptions = options.havingStyle(dstyle);
              const denomm = buildGroup(group.denom, newOptions, options);
              let rule;
              let ruleWidth;
              let ruleSpacing;
              if (group.hasBarLine) {
                if (group.barSize) {
                  ruleWidth = calculateSize(group.barSize, options);
                  rule = buildCommon.makeLineSpan("frac-line", options, ruleWidth);
                } else {
                  rule = buildCommon.makeLineSpan("frac-line", options);
                }
                ruleWidth = rule.height;
                ruleSpacing = rule.height;
              } else {
                rule = null;
                ruleWidth = 0;
                ruleSpacing = options.fontMetrics().defaultRuleThickness;
              }
              let numShift;
              let clearance;
              let denomShift;
              if (style.size === src_Style.DISPLAY.size || group.size === "display") {
                numShift = options.fontMetrics().num1;
                if (ruleWidth > 0) {
                  clearance = 3 * ruleSpacing;
                } else {
                  clearance = 7 * ruleSpacing;
                }
                denomShift = options.fontMetrics().denom1;
              } else {
                if (ruleWidth > 0) {
                  numShift = options.fontMetrics().num2;
                  clearance = ruleSpacing;
                } else {
                  numShift = options.fontMetrics().num3;
                  clearance = 3 * ruleSpacing;
                }
                denomShift = options.fontMetrics().denom2;
              }
              let frac;
              if (!rule) {
                const candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);
                if (candidateClearance < clearance) {
                  numShift += 0.5 * (clearance - candidateClearance);
                  denomShift += 0.5 * (clearance - candidateClearance);
                }
                frac = buildCommon.makeVList({
                  positionType: "individualShift",
                  children: [{
                    type: "elem",
                    elem: denomm,
                    shift: denomShift
                  }, {
                    type: "elem",
                    elem: numerm,
                    shift: -numShift
                  }]
                }, options);
              } else {
                const axisHeight = options.fontMetrics().axisHeight;
                if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
                  numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));
                }
                if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {
                  denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));
                }
                const midShift = -(axisHeight - 0.5 * ruleWidth);
                frac = buildCommon.makeVList({
                  positionType: "individualShift",
                  children: [{
                    type: "elem",
                    elem: denomm,
                    shift: denomShift
                  }, {
                    type: "elem",
                    elem: rule,
                    shift: midShift
                  }, {
                    type: "elem",
                    elem: numerm,
                    shift: -numShift
                  }]
                }, options);
              }
              newOptions = options.havingStyle(style);
              frac.height *= newOptions.sizeMultiplier / options.sizeMultiplier;
              frac.depth *= newOptions.sizeMultiplier / options.sizeMultiplier;
              let delimSize;
              if (style.size === src_Style.DISPLAY.size) {
                delimSize = options.fontMetrics().delim1;
              } else if (style.size === src_Style.SCRIPTSCRIPT.size) {
                delimSize = options.havingStyle(src_Style.SCRIPT).fontMetrics().delim2;
              } else {
                delimSize = options.fontMetrics().delim2;
              }
              let leftDelim;
              let rightDelim;
              if (group.leftDelim == null) {
                leftDelim = makeNullDelimiter(options, ["mopen"]);
              } else {
                leftDelim = delimiter2.customSizedDelim(group.leftDelim, delimSize, true, options.havingStyle(style), group.mode, ["mopen"]);
              }
              if (group.continued) {
                rightDelim = buildCommon.makeSpan([]);
              } else if (group.rightDelim == null) {
                rightDelim = makeNullDelimiter(options, ["mclose"]);
              } else {
                rightDelim = delimiter2.customSizedDelim(group.rightDelim, delimSize, true, options.havingStyle(style), group.mode, ["mclose"]);
              }
              return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options)), [leftDelim, buildCommon.makeSpan(["mfrac"], [frac]), rightDelim], options);
            };
            const genfrac_mathmlBuilder = (group, options) => {
              let node = new mathMLTree.MathNode("mfrac", [buildMathML_buildGroup(group.numer, options), buildMathML_buildGroup(group.denom, options)]);
              if (!group.hasBarLine) {
                node.setAttribute("linethickness", "0px");
              } else if (group.barSize) {
                const ruleWidth = calculateSize(group.barSize, options);
                node.setAttribute("linethickness", makeEm(ruleWidth));
              }
              const style = adjustStyle(group.size, options.style);
              if (style.size !== options.style.size) {
                node = new mathMLTree.MathNode("mstyle", [node]);
                const isDisplay = style.size === src_Style.DISPLAY.size ? "true" : "false";
                node.setAttribute("displaystyle", isDisplay);
                node.setAttribute("scriptlevel", "0");
              }
              if (group.leftDelim != null || group.rightDelim != null) {
                const withDelims = [];
                if (group.leftDelim != null) {
                  const leftOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))]);
                  leftOp.setAttribute("fence", "true");
                  withDelims.push(leftOp);
                }
                withDelims.push(node);
                if (group.rightDelim != null) {
                  const rightOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))]);
                  rightOp.setAttribute("fence", "true");
                  withDelims.push(rightOp);
                }
                return makeRow(withDelims);
              }
              return node;
            };
            defineFunction({
              type: "genfrac",
              names: [
                "\\dfrac",
                "\\frac",
                "\\tfrac",
                "\\dbinom",
                "\\binom",
                "\\tbinom",
                "\\\\atopfrac",
                // can’t be entered directly
                "\\\\bracefrac",
                "\\\\brackfrac"
                // ditto
              ],
              props: {
                numArgs: 2,
                allowedInArgument: true
              },
              handler: (_ref, args) => {
                let {
                  parser,
                  funcName
                } = _ref;
                const numer = args[0];
                const denom = args[1];
                let hasBarLine;
                let leftDelim = null;
                let rightDelim = null;
                let size = "auto";
                switch (funcName) {
                  case "\\dfrac":
                  case "\\frac":
                  case "\\tfrac":
                    hasBarLine = true;
                    break;
                  case "\\\\atopfrac":
                    hasBarLine = false;
                    break;
                  case "\\dbinom":
                  case "\\binom":
                  case "\\tbinom":
                    hasBarLine = false;
                    leftDelim = "(";
                    rightDelim = ")";
                    break;
                  case "\\\\bracefrac":
                    hasBarLine = false;
                    leftDelim = "\\{";
                    rightDelim = "\\}";
                    break;
                  case "\\\\brackfrac":
                    hasBarLine = false;
                    leftDelim = "[";
                    rightDelim = "]";
                    break;
                  default:
                    throw new Error("Unrecognized genfrac command");
                }
                switch (funcName) {
                  case "\\dfrac":
                  case "\\dbinom":
                    size = "display";
                    break;
                  case "\\tfrac":
                  case "\\tbinom":
                    size = "text";
                    break;
                }
                return {
                  type: "genfrac",
                  mode: parser.mode,
                  continued: false,
                  numer,
                  denom,
                  hasBarLine,
                  leftDelim,
                  rightDelim,
                  size,
                  barSize: null
                };
              },
              htmlBuilder: genfrac_htmlBuilder,
              mathmlBuilder: genfrac_mathmlBuilder
            });
            defineFunction({
              type: "genfrac",
              names: ["\\cfrac"],
              props: {
                numArgs: 2
              },
              handler: (_ref2, args) => {
                let {
                  parser,
                  funcName
                } = _ref2;
                const numer = args[0];
                const denom = args[1];
                return {
                  type: "genfrac",
                  mode: parser.mode,
                  continued: true,
                  numer,
                  denom,
                  hasBarLine: true,
                  leftDelim: null,
                  rightDelim: null,
                  size: "display",
                  barSize: null
                };
              }
            });
            defineFunction({
              type: "infix",
              names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
              props: {
                numArgs: 0,
                infix: true
              },
              handler(_ref3) {
                let {
                  parser,
                  funcName,
                  token
                } = _ref3;
                let replaceWith2;
                switch (funcName) {
                  case "\\over":
                    replaceWith2 = "\\frac";
                    break;
                  case "\\choose":
                    replaceWith2 = "\\binom";
                    break;
                  case "\\atop":
                    replaceWith2 = "\\\\atopfrac";
                    break;
                  case "\\brace":
                    replaceWith2 = "\\\\bracefrac";
                    break;
                  case "\\brack":
                    replaceWith2 = "\\\\brackfrac";
                    break;
                  default:
                    throw new Error("Unrecognized infix genfrac command");
                }
                return {
                  type: "infix",
                  mode: parser.mode,
                  replaceWith: replaceWith2,
                  token
                };
              }
            });
            const stylArray = ["display", "text", "script", "scriptscript"];
            const delimFromValue = function(delimString) {
              let delim = null;
              if (delimString.length > 0) {
                delim = delimString;
                delim = delim === "." ? null : delim;
              }
              return delim;
            };
            defineFunction({
              type: "genfrac",
              names: ["\\genfrac"],
              props: {
                numArgs: 6,
                allowedInArgument: true,
                argTypes: ["math", "math", "size", "text", "math", "math"]
              },
              handler(_ref4, args) {
                let {
                  parser
                } = _ref4;
                const numer = args[4];
                const denom = args[5];
                const leftNode = normalizeArgument(args[0]);
                const leftDelim = leftNode.type === "atom" && leftNode.family === "open" ? delimFromValue(leftNode.text) : null;
                const rightNode = normalizeArgument(args[1]);
                const rightDelim = rightNode.type === "atom" && rightNode.family === "close" ? delimFromValue(rightNode.text) : null;
                const barNode = assertNodeType(args[2], "size");
                let hasBarLine;
                let barSize = null;
                if (barNode.isBlank) {
                  hasBarLine = true;
                } else {
                  barSize = barNode.value;
                  hasBarLine = barSize.number > 0;
                }
                let size = "auto";
                let styl = args[3];
                if (styl.type === "ordgroup") {
                  if (styl.body.length > 0) {
                    const textOrd = assertNodeType(styl.body[0], "textord");
                    size = stylArray[Number(textOrd.text)];
                  }
                } else {
                  styl = assertNodeType(styl, "textord");
                  size = stylArray[Number(styl.text)];
                }
                return {
                  type: "genfrac",
                  mode: parser.mode,
                  numer,
                  denom,
                  continued: false,
                  hasBarLine,
                  barSize,
                  leftDelim,
                  rightDelim,
                  size
                };
              },
              htmlBuilder: genfrac_htmlBuilder,
              mathmlBuilder: genfrac_mathmlBuilder
            });
            defineFunction({
              type: "infix",
              names: ["\\above"],
              props: {
                numArgs: 1,
                argTypes: ["size"],
                infix: true
              },
              handler(_ref5, args) {
                let {
                  parser,
                  funcName,
                  token
                } = _ref5;
                return {
                  type: "infix",
                  mode: parser.mode,
                  replaceWith: "\\\\abovefrac",
                  size: assertNodeType(args[0], "size").value,
                  token
                };
              }
            });
            defineFunction({
              type: "genfrac",
              names: ["\\\\abovefrac"],
              props: {
                numArgs: 3,
                argTypes: ["math", "size", "math"]
              },
              handler: (_ref6, args) => {
                let {
                  parser,
                  funcName
                } = _ref6;
                const numer = args[0];
                const barSize = assert(assertNodeType(args[1], "infix").size);
                const denom = args[2];
                const hasBarLine = barSize.number > 0;
                return {
                  type: "genfrac",
                  mode: parser.mode,
                  numer,
                  denom,
                  continued: false,
                  hasBarLine,
                  barSize,
                  leftDelim: null,
                  rightDelim: null,
                  size: "auto"
                };
              },
              htmlBuilder: genfrac_htmlBuilder,
              mathmlBuilder: genfrac_mathmlBuilder
            });
            ;
            const horizBrace_htmlBuilder = (grp, options) => {
              const style = options.style;
              let supSubGroup;
              let group;
              if (grp.type === "supsub") {
                supSubGroup = grp.sup ? buildGroup(grp.sup, options.havingStyle(style.sup()), options) : buildGroup(grp.sub, options.havingStyle(style.sub()), options);
                group = assertNodeType(grp.base, "horizBrace");
              } else {
                group = assertNodeType(grp, "horizBrace");
              }
              const body = buildGroup(group.base, options.havingBaseStyle(src_Style.DISPLAY));
              const braceBody = stretchy.svgSpan(group, options);
              let vlist;
              if (group.isOver) {
                vlist = buildCommon.makeVList({
                  positionType: "firstBaseline",
                  children: [{
                    type: "elem",
                    elem: body
                  }, {
                    type: "kern",
                    size: 0.1
                  }, {
                    type: "elem",
                    elem: braceBody
                  }]
                }, options);
                vlist.children[0].children[0].children[1].classes.push("svg-align");
              } else {
                vlist = buildCommon.makeVList({
                  positionType: "bottom",
                  positionData: body.depth + 0.1 + braceBody.height,
                  children: [{
                    type: "elem",
                    elem: braceBody
                  }, {
                    type: "kern",
                    size: 0.1
                  }, {
                    type: "elem",
                    elem: body
                  }]
                }, options);
                vlist.children[0].children[0].children[0].classes.push("svg-align");
              }
              if (supSubGroup) {
                const vSpan = buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
                if (group.isOver) {
                  vlist = buildCommon.makeVList({
                    positionType: "firstBaseline",
                    children: [{
                      type: "elem",
                      elem: vSpan
                    }, {
                      type: "kern",
                      size: 0.2
                    }, {
                      type: "elem",
                      elem: supSubGroup
                    }]
                  }, options);
                } else {
                  vlist = buildCommon.makeVList({
                    positionType: "bottom",
                    positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,
                    children: [{
                      type: "elem",
                      elem: supSubGroup
                    }, {
                      type: "kern",
                      size: 0.2
                    }, {
                      type: "elem",
                      elem: vSpan
                    }]
                  }, options);
                }
              }
              return buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
            };
            const horizBrace_mathmlBuilder = (group, options) => {
              const accentNode = stretchy.mathMLnode(group.label);
              return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [buildMathML_buildGroup(group.base, options), accentNode]);
            };
            defineFunction({
              type: "horizBrace",
              names: ["\\overbrace", "\\underbrace"],
              props: {
                numArgs: 1
              },
              handler(_ref, args) {
                let {
                  parser,
                  funcName
                } = _ref;
                return {
                  type: "horizBrace",
                  mode: parser.mode,
                  label: funcName,
                  isOver: /^\\over/.test(funcName),
                  base: args[0]
                };
              },
              htmlBuilder: horizBrace_htmlBuilder,
              mathmlBuilder: horizBrace_mathmlBuilder
            });
            ;
            defineFunction({
              type: "href",
              names: ["\\href"],
              props: {
                numArgs: 2,
                argTypes: ["url", "original"],
                allowedInText: true
              },
              handler: (_ref, args) => {
                let {
                  parser
                } = _ref;
                const body = args[1];
                const href = assertNodeType(args[0], "url").url;
                if (!parser.settings.isTrusted({
                  command: "\\href",
                  url: href
                })) {
                  return parser.formatUnsupportedCmd("\\href");
                }
                return {
                  type: "href",
                  mode: parser.mode,
                  href,
                  body: ordargument(body)
                };
              },
              htmlBuilder: (group, options) => {
                const elements = buildExpression(group.body, options, false);
                return buildCommon.makeAnchor(group.href, [], elements, options);
              },
              mathmlBuilder: (group, options) => {
                let math2 = buildExpressionRow(group.body, options);
                if (!(math2 instanceof MathNode)) {
                  math2 = new MathNode("mrow", [math2]);
                }
                math2.setAttribute("href", group.href);
                return math2;
              }
            });
            defineFunction({
              type: "href",
              names: ["\\url"],
              props: {
                numArgs: 1,
                argTypes: ["url"],
                allowedInText: true
              },
              handler: (_ref2, args) => {
                let {
                  parser
                } = _ref2;
                const href = assertNodeType(args[0], "url").url;
                if (!parser.settings.isTrusted({
                  command: "\\url",
                  url: href
                })) {
                  return parser.formatUnsupportedCmd("\\url");
                }
                const chars = [];
                for (let i = 0; i < href.length; i++) {
                  let c = href[i];
                  if (c === "~") {
                    c = "\\textasciitilde";
                  }
                  chars.push({
                    type: "textord",
                    mode: "text",
                    text: c
                  });
                }
                const body = {
                  type: "text",
                  mode: parser.mode,
                  font: "\\texttt",
                  body: chars
                };
                return {
                  type: "href",
                  mode: parser.mode,
                  href,
                  body: ordargument(body)
                };
              }
            });
            ;
            defineFunction({
              type: "hbox",
              names: ["\\hbox"],
              props: {
                numArgs: 1,
                argTypes: ["text"],
                allowedInText: true,
                primitive: true
              },
              handler(_ref, args) {
                let {
                  parser
                } = _ref;
                return {
                  type: "hbox",
                  mode: parser.mode,
                  body: ordargument(args[0])
                };
              },
              htmlBuilder(group, options) {
                const elements = buildExpression(group.body, options, false);
                return buildCommon.makeFragment(elements);
              },
              mathmlBuilder(group, options) {
                return new mathMLTree.MathNode("mrow", buildMathML_buildExpression(group.body, options));
              }
            });
            ;
            defineFunction({
              type: "html",
              names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
              props: {
                numArgs: 2,
                argTypes: ["raw", "original"],
                allowedInText: true
              },
              handler: (_ref, args) => {
                let {
                  parser,
                  funcName,
                  token
                } = _ref;
                const value = assertNodeType(args[0], "raw").string;
                const body = args[1];
                if (parser.settings.strict) {
                  parser.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
                }
                let trustContext;
                const attributes2 = {};
                switch (funcName) {
                  case "\\htmlClass":
                    attributes2.class = value;
                    trustContext = {
                      command: "\\htmlClass",
                      class: value
                    };
                    break;
                  case "\\htmlId":
                    attributes2.id = value;
                    trustContext = {
                      command: "\\htmlId",
                      id: value
                    };
                    break;
                  case "\\htmlStyle":
                    attributes2.style = value;
                    trustContext = {
                      command: "\\htmlStyle",
                      style: value
                    };
                    break;
                  case "\\htmlData": {
                    const data2 = value.split(",");
                    for (let i = 0; i < data2.length; i++) {
                      const item = data2[i];
                      const firstEquals = item.indexOf("=");
                      if (firstEquals < 0) {
                        throw new src_ParseError("\\htmlData key/value '" + item + "' missing equals sign");
                      }
                      const key = item.slice(0, firstEquals);
                      const value2 = item.slice(firstEquals + 1);
                      attributes2["data-" + key.trim()] = value2;
                    }
                    trustContext = {
                      command: "\\htmlData",
                      attributes: attributes2
                    };
                    break;
                  }
                  default:
                    throw new Error("Unrecognized html command");
                }
                if (!parser.settings.isTrusted(trustContext)) {
                  return parser.formatUnsupportedCmd(funcName);
                }
                return {
                  type: "html",
                  mode: parser.mode,
                  attributes: attributes2,
                  body: ordargument(body)
                };
              },
              htmlBuilder: (group, options) => {
                const elements = buildExpression(group.body, options, false);
                const classes = ["enclosing"];
                if (group.attributes.class) {
                  classes.push(...group.attributes.class.trim().split(/\s+/));
                }
                const span = buildCommon.makeSpan(classes, elements, options);
                for (const attr2 in group.attributes) {
                  if (attr2 !== "class" && group.attributes.hasOwnProperty(attr2)) {
                    span.setAttribute(attr2, group.attributes[attr2]);
                  }
                }
                return span;
              },
              mathmlBuilder: (group, options) => {
                return buildExpressionRow(group.body, options);
              }
            });
            ;
            defineFunction({
              type: "htmlmathml",
              names: ["\\html@mathml"],
              props: {
                numArgs: 2,
                allowedInText: true
              },
              handler: (_ref, args) => {
                let {
                  parser
                } = _ref;
                return {
                  type: "htmlmathml",
                  mode: parser.mode,
                  html: ordargument(args[0]),
                  mathml: ordargument(args[1])
                };
              },
              htmlBuilder: (group, options) => {
                const elements = buildExpression(group.html, options, false);
                return buildCommon.makeFragment(elements);
              },
              mathmlBuilder: (group, options) => {
                return buildExpressionRow(group.mathml, options);
              }
            });
            ;
            const sizeData = function(str) {
              if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str)) {
                return {
                  number: +str,
                  unit: "bp"
                };
              } else {
                const match2 = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str);
                if (!match2) {
                  throw new src_ParseError("Invalid size: '" + str + "' in \\includegraphics");
                }
                const data2 = {
                  number: +(match2[1] + match2[2]),
                  // sign + magnitude, cast to number
                  unit: match2[3]
                };
                if (!validUnit(data2)) {
                  throw new src_ParseError("Invalid unit: '" + data2.unit + "' in \\includegraphics.");
                }
                return data2;
              }
            };
            defineFunction({
              type: "includegraphics",
              names: ["\\includegraphics"],
              props: {
                numArgs: 1,
                numOptionalArgs: 1,
                argTypes: ["raw", "url"],
                allowedInText: false
              },
              handler: (_ref, args, optArgs) => {
                let {
                  parser
                } = _ref;
                let width = {
                  number: 0,
                  unit: "em"
                };
                let height = {
                  number: 0.9,
                  unit: "em"
                };
                let totalheight = {
                  number: 0,
                  unit: "em"
                };
                let alt = "";
                if (optArgs[0]) {
                  const attributeStr = assertNodeType(optArgs[0], "raw").string;
                  const attributes2 = attributeStr.split(",");
                  for (let i = 0; i < attributes2.length; i++) {
                    const keyVal = attributes2[i].split("=");
                    if (keyVal.length === 2) {
                      const str = keyVal[1].trim();
                      switch (keyVal[0].trim()) {
                        case "alt":
                          alt = str;
                          break;
                        case "width":
                          width = sizeData(str);
                          break;
                        case "height":
                          height = sizeData(str);
                          break;
                        case "totalheight":
                          totalheight = sizeData(str);
                          break;
                        default:
                          throw new src_ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.");
                      }
                    }
                  }
                }
                const src = assertNodeType(args[0], "url").url;
                if (alt === "") {
                  alt = src;
                  alt = alt.replace(/^.*[\\/]/, "");
                  alt = alt.substring(0, alt.lastIndexOf("."));
                }
                if (!parser.settings.isTrusted({
                  command: "\\includegraphics",
                  url: src
                })) {
                  return parser.formatUnsupportedCmd("\\includegraphics");
                }
                return {
                  type: "includegraphics",
                  mode: parser.mode,
                  alt,
                  width,
                  height,
                  totalheight,
                  src
                };
              },
              htmlBuilder: (group, options) => {
                const height = calculateSize(group.height, options);
                let depth = 0;
                if (group.totalheight.number > 0) {
                  depth = calculateSize(group.totalheight, options) - height;
                }
                let width = 0;
                if (group.width.number > 0) {
                  width = calculateSize(group.width, options);
                }
                const style = {
                  height: makeEm(height + depth)
                };
                if (width > 0) {
                  style.width = makeEm(width);
                }
                if (depth > 0) {
                  style.verticalAlign = makeEm(-depth);
                }
                const node = new Img(group.src, group.alt, style);
                node.height = height;
                node.depth = depth;
                return node;
              },
              mathmlBuilder: (group, options) => {
                const node = new mathMLTree.MathNode("mglyph", []);
                node.setAttribute("alt", group.alt);
                const height = calculateSize(group.height, options);
                let depth = 0;
                if (group.totalheight.number > 0) {
                  depth = calculateSize(group.totalheight, options) - height;
                  node.setAttribute("valign", makeEm(-depth));
                }
                node.setAttribute("height", makeEm(height + depth));
                if (group.width.number > 0) {
                  const width = calculateSize(group.width, options);
                  node.setAttribute("width", makeEm(width));
                }
                node.setAttribute("src", group.src);
                return node;
              }
            });
            ;
            defineFunction({
              type: "kern",
              names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
              props: {
                numArgs: 1,
                argTypes: ["size"],
                primitive: true,
                allowedInText: true
              },
              handler(_ref, args) {
                let {
                  parser,
                  funcName
                } = _ref;
                const size = assertNodeType(args[0], "size");
                if (parser.settings.strict) {
                  const mathFunction = funcName[1] === "m";
                  const muUnit = size.value.unit === "mu";
                  if (mathFunction) {
                    if (!muUnit) {
                      parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " supports only mu units, " + ("not " + size.value.unit + " units"));
                    }
                    if (parser.mode !== "math") {
                      parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " works only in math mode");
                    }
                  } else {
                    if (muUnit) {
                      parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " doesn't support mu units");
                    }
                  }
                }
                return {
                  type: "kern",
                  mode: parser.mode,
                  dimension: size.value
                };
              },
              htmlBuilder(group, options) {
                return buildCommon.makeGlue(group.dimension, options);
              },
              mathmlBuilder(group, options) {
                const dimension = calculateSize(group.dimension, options);
                return new mathMLTree.SpaceNode(dimension);
              }
            });
            ;
            defineFunction({
              type: "lap",
              names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
              props: {
                numArgs: 1,
                allowedInText: true
              },
              handler: (_ref, args) => {
                let {
                  parser,
                  funcName
                } = _ref;
                const body = args[0];
                return {
                  type: "lap",
                  mode: parser.mode,
                  alignment: funcName.slice(5),
                  body
                };
              },
              htmlBuilder: (group, options) => {
                let inner2;
                if (group.alignment === "clap") {
                  inner2 = buildCommon.makeSpan([], [buildGroup(group.body, options)]);
                  inner2 = buildCommon.makeSpan(["inner"], [inner2], options);
                } else {
                  inner2 = buildCommon.makeSpan(["inner"], [buildGroup(group.body, options)]);
                }
                const fix = buildCommon.makeSpan(["fix"], []);
                let node = buildCommon.makeSpan([group.alignment], [inner2, fix], options);
                const strut = buildCommon.makeSpan(["strut"]);
                strut.style.height = makeEm(node.height + node.depth);
                if (node.depth) {
                  strut.style.verticalAlign = makeEm(-node.depth);
                }
                node.children.unshift(strut);
                node = buildCommon.makeSpan(["thinbox"], [node], options);
                return buildCommon.makeSpan(["mord", "vbox"], [node], options);
              },
              mathmlBuilder: (group, options) => {
                const node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
                if (group.alignment !== "rlap") {
                  const offset = group.alignment === "llap" ? "-1" : "-0.5";
                  node.setAttribute("lspace", offset + "width");
                }
                node.setAttribute("width", "0px");
                return node;
              }
            });
            ;
            defineFunction({
              type: "styling",
              names: ["\\(", "$"],
              props: {
                numArgs: 0,
                allowedInText: true,
                allowedInMath: false
              },
              handler(_ref, args) {
                let {
                  funcName,
                  parser
                } = _ref;
                const outerMode = parser.mode;
                parser.switchMode("math");
                const close = funcName === "\\(" ? "\\)" : "$";
                const body = parser.parseExpression(false, close);
                parser.expect(close);
                parser.switchMode(outerMode);
                return {
                  type: "styling",
                  mode: parser.mode,
                  style: "text",
                  body
                };
              }
            });
            defineFunction({
              type: "text",
              // Doesn't matter what this is.
              names: ["\\)", "\\]"],
              props: {
                numArgs: 0,
                allowedInText: true,
                allowedInMath: false
              },
              handler(context, args) {
                throw new src_ParseError("Mismatched " + context.funcName);
              }
            });
            ;
            const chooseMathStyle = (group, options) => {
              switch (options.style.size) {
                case src_Style.DISPLAY.size:
                  return group.display;
                case src_Style.TEXT.size:
                  return group.text;
                case src_Style.SCRIPT.size:
                  return group.script;
                case src_Style.SCRIPTSCRIPT.size:
                  return group.scriptscript;
                default:
                  return group.text;
              }
            };
            defineFunction({
              type: "mathchoice",
              names: ["\\mathchoice"],
              props: {
                numArgs: 4,
                primitive: true
              },
              handler: (_ref, args) => {
                let {
                  parser
                } = _ref;
                return {
                  type: "mathchoice",
                  mode: parser.mode,
                  display: ordargument(args[0]),
                  text: ordargument(args[1]),
                  script: ordargument(args[2]),
                  scriptscript: ordargument(args[3])
                };
              },
              htmlBuilder: (group, options) => {
                const body = chooseMathStyle(group, options);
                const elements = buildExpression(body, options, false);
                return buildCommon.makeFragment(elements);
              },
              mathmlBuilder: (group, options) => {
                const body = chooseMathStyle(group, options);
                return buildExpressionRow(body, options);
              }
            });
            ;
            const assembleSupSub = (base2, supGroup, subGroup, options, style, slant, baseShift) => {
              base2 = buildCommon.makeSpan([], [base2]);
              const subIsSingleCharacter = subGroup && utils.isCharacterBox(subGroup);
              let sub2;
              let sup2;
              if (supGroup) {
                const elem = buildGroup(supGroup, options.havingStyle(style.sup()), options);
                sup2 = {
                  elem,
                  kern: Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - elem.depth)
                };
              }
              if (subGroup) {
                const elem = buildGroup(subGroup, options.havingStyle(style.sub()), options);
                sub2 = {
                  elem,
                  kern: Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - elem.height)
                };
              }
              let finalGroup;
              if (sup2 && sub2) {
                const bottom = options.fontMetrics().bigOpSpacing5 + sub2.elem.height + sub2.elem.depth + sub2.kern + base2.depth + baseShift;
                finalGroup = buildCommon.makeVList({
                  positionType: "bottom",
                  positionData: bottom,
                  children: [{
                    type: "kern",
                    size: options.fontMetrics().bigOpSpacing5
                  }, {
                    type: "elem",
                    elem: sub2.elem,
                    marginLeft: makeEm(-slant)
                  }, {
                    type: "kern",
                    size: sub2.kern
                  }, {
                    type: "elem",
                    elem: base2
                  }, {
                    type: "kern",
                    size: sup2.kern
                  }, {
                    type: "elem",
                    elem: sup2.elem,
                    marginLeft: makeEm(slant)
                  }, {
                    type: "kern",
                    size: options.fontMetrics().bigOpSpacing5
                  }]
                }, options);
              } else if (sub2) {
                const top = base2.height - baseShift;
                finalGroup = buildCommon.makeVList({
                  positionType: "top",
                  positionData: top,
                  children: [{
                    type: "kern",
                    size: options.fontMetrics().bigOpSpacing5
                  }, {
                    type: "elem",
                    elem: sub2.elem,
                    marginLeft: makeEm(-slant)
                  }, {
                    type: "kern",
                    size: sub2.kern
                  }, {
                    type: "elem",
                    elem: base2
                  }]
                }, options);
              } else if (sup2) {
                const bottom = base2.depth + baseShift;
                finalGroup = buildCommon.makeVList({
                  positionType: "bottom",
                  positionData: bottom,
                  children: [{
                    type: "elem",
                    elem: base2
                  }, {
                    type: "kern",
                    size: sup2.kern
                  }, {
                    type: "elem",
                    elem: sup2.elem,
                    marginLeft: makeEm(slant)
                  }, {
                    type: "kern",
                    size: options.fontMetrics().bigOpSpacing5
                  }]
                }, options);
              } else {
                return base2;
              }
              const parts = [finalGroup];
              if (sub2 && slant !== 0 && !subIsSingleCharacter) {
                const spacer = buildCommon.makeSpan(["mspace"], [], options);
                spacer.style.marginRight = makeEm(slant);
                parts.unshift(spacer);
              }
              return buildCommon.makeSpan(["mop", "op-limits"], parts, options);
            };
            ;
            const noSuccessor = ["\\smallint"];
            const op_htmlBuilder = (grp, options) => {
              let supGroup;
              let subGroup;
              let hasLimits = false;
              let group;
              if (grp.type === "supsub") {
                supGroup = grp.sup;
                subGroup = grp.sub;
                group = assertNodeType(grp.base, "op");
                hasLimits = true;
              } else {
                group = assertNodeType(grp, "op");
              }
              const style = options.style;
              let large = false;
              if (style.size === src_Style.DISPLAY.size && group.symbol && !noSuccessor.includes(group.name)) {
                large = true;
              }
              let base2;
              if (group.symbol) {
                const fontName = large ? "Size2-Regular" : "Size1-Regular";
                let stash = "";
                if (group.name === "\\oiint" || group.name === "\\oiiint") {
                  stash = group.name.slice(1);
                  group.name = stash === "oiint" ? "\\iint" : "\\iiint";
                }
                base2 = buildCommon.makeSymbol(group.name, fontName, "math", options, ["mop", "op-symbol", large ? "large-op" : "small-op"]);
                if (stash.length > 0) {
                  const italic = base2.italic;
                  const oval = buildCommon.staticSvg(stash + "Size" + (large ? "2" : "1"), options);
                  base2 = buildCommon.makeVList({
                    positionType: "individualShift",
                    children: [{
                      type: "elem",
                      elem: base2,
                      shift: 0
                    }, {
                      type: "elem",
                      elem: oval,
                      shift: large ? 0.08 : 0
                    }]
                  }, options);
                  group.name = "\\" + stash;
                  base2.classes.unshift("mop");
                  base2.italic = italic;
                }
              } else if (group.body) {
                const inner2 = buildExpression(group.body, options, true);
                if (inner2.length === 1 && inner2[0] instanceof SymbolNode) {
                  base2 = inner2[0];
                  base2.classes[0] = "mop";
                } else {
                  base2 = buildCommon.makeSpan(["mop"], inner2, options);
                }
              } else {
                const output = [];
                for (let i = 1; i < group.name.length; i++) {
                  output.push(buildCommon.mathsym(group.name[i], group.mode, options));
                }
                base2 = buildCommon.makeSpan(["mop"], output, options);
              }
              let baseShift = 0;
              let slant = 0;
              if ((base2 instanceof SymbolNode || group.name === "\\oiint" || group.name === "\\oiiint") && !group.suppressBaseShift) {
                baseShift = (base2.height - base2.depth) / 2 - options.fontMetrics().axisHeight;
                slant = base2.italic;
              }
              if (hasLimits) {
                return assembleSupSub(base2, supGroup, subGroup, options, style, slant, baseShift);
              } else {
                if (baseShift) {
                  base2.style.position = "relative";
                  base2.style.top = makeEm(baseShift);
                }
                return base2;
              }
            };
            const op_mathmlBuilder = (group, options) => {
              let node;
              if (group.symbol) {
                node = new MathNode("mo", [makeText(group.name, group.mode)]);
                if (noSuccessor.includes(group.name)) {
                  node.setAttribute("largeop", "false");
                }
              } else if (group.body) {
                node = new MathNode("mo", buildMathML_buildExpression(group.body, options));
              } else {
                node = new MathNode("mi", [new TextNode(group.name.slice(1))]);
                const operator = new MathNode("mo", [makeText("\u2061", "text")]);
                if (group.parentIsSupSub) {
                  node = new MathNode("mrow", [node, operator]);
                } else {
                  node = newDocumentFragment([node, operator]);
                }
              }
              return node;
            };
            const singleCharBigOps = {
              "\u220F": "\\prod",
              "\u2210": "\\coprod",
              "\u2211": "\\sum",
              "\u22C0": "\\bigwedge",
              "\u22C1": "\\bigvee",
              "\u22C2": "\\bigcap",
              "\u22C3": "\\bigcup",
              "\u2A00": "\\bigodot",
              "\u2A01": "\\bigoplus",
              "\u2A02": "\\bigotimes",
              "\u2A04": "\\biguplus",
              "\u2A06": "\\bigsqcup"
            };
            defineFunction({
              type: "op",
              names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "\u220F", "\u2210", "\u2211", "\u22C0", "\u22C1", "\u22C2", "\u22C3", "\u2A00", "\u2A01", "\u2A02", "\u2A04", "\u2A06"],
              props: {
                numArgs: 0
              },
              handler: (_ref, args) => {
                let {
                  parser,
                  funcName
                } = _ref;
                let fName = funcName;
                if (fName.length === 1) {
                  fName = singleCharBigOps[fName];
                }
                return {
                  type: "op",
                  mode: parser.mode,
                  limits: true,
                  parentIsSupSub: false,
                  symbol: true,
                  name: fName
                };
              },
              htmlBuilder: op_htmlBuilder,
              mathmlBuilder: op_mathmlBuilder
            });
            defineFunction({
              type: "op",
              names: ["\\mathop"],
              props: {
                numArgs: 1,
                primitive: true
              },
              handler: (_ref2, args) => {
                let {
                  parser
                } = _ref2;
                const body = args[0];
                return {
                  type: "op",
                  mode: parser.mode,
                  limits: false,
                  parentIsSupSub: false,
                  symbol: false,
                  body: ordargument(body)
                };
              },
              htmlBuilder: op_htmlBuilder,
              mathmlBuilder: op_mathmlBuilder
            });
            const singleCharIntegrals = {
              "\u222B": "\\int",
              "\u222C": "\\iint",
              "\u222D": "\\iiint",
              "\u222E": "\\oint",
              "\u222F": "\\oiint",
              "\u2230": "\\oiiint"
            };
            defineFunction({
              type: "op",
              names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
              props: {
                numArgs: 0
              },
              handler(_ref3) {
                let {
                  parser,
                  funcName
                } = _ref3;
                return {
                  type: "op",
                  mode: parser.mode,
                  limits: false,
                  parentIsSupSub: false,
                  symbol: false,
                  name: funcName
                };
              },
              htmlBuilder: op_htmlBuilder,
              mathmlBuilder: op_mathmlBuilder
            });
            defineFunction({
              type: "op",
              names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
              props: {
                numArgs: 0
              },
              handler(_ref4) {
                let {
                  parser,
                  funcName
                } = _ref4;
                return {
                  type: "op",
                  mode: parser.mode,
                  limits: true,
                  parentIsSupSub: false,
                  symbol: false,
                  name: funcName
                };
              },
              htmlBuilder: op_htmlBuilder,
              mathmlBuilder: op_mathmlBuilder
            });
            defineFunction({
              type: "op",
              names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "\u222B", "\u222C", "\u222D", "\u222E", "\u222F", "\u2230"],
              props: {
                numArgs: 0,
                allowedInArgument: true
              },
              handler(_ref5) {
                let {
                  parser,
                  funcName
                } = _ref5;
                let fName = funcName;
                if (fName.length === 1) {
                  fName = singleCharIntegrals[fName];
                }
                return {
                  type: "op",
                  mode: parser.mode,
                  limits: false,
                  parentIsSupSub: false,
                  symbol: true,
                  name: fName
                };
              },
              htmlBuilder: op_htmlBuilder,
              mathmlBuilder: op_mathmlBuilder
            });
            ;
            const operatorname_htmlBuilder = (grp, options) => {
              let supGroup;
              let subGroup;
              let hasLimits = false;
              let group;
              if (grp.type === "supsub") {
                supGroup = grp.sup;
                subGroup = grp.sub;
                group = assertNodeType(grp.base, "operatorname");
                hasLimits = true;
              } else {
                group = assertNodeType(grp, "operatorname");
              }
              let base2;
              if (group.body.length > 0) {
                const body = group.body.map((child) => {
                  const childText = child.text;
                  if (typeof childText === "string") {
                    return {
                      type: "textord",
                      mode: child.mode,
                      text: childText
                    };
                  } else {
                    return child;
                  }
                });
                const expression = buildExpression(body, options.withFont("mathrm"), true);
                for (let i = 0; i < expression.length; i++) {
                  const child = expression[i];
                  if (child instanceof SymbolNode) {
                    child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
                  }
                }
                base2 = buildCommon.makeSpan(["mop"], expression, options);
              } else {
                base2 = buildCommon.makeSpan(["mop"], [], options);
              }
              if (hasLimits) {
                return assembleSupSub(base2, supGroup, subGroup, options, options.style, 0, 0);
              } else {
                return base2;
              }
            };
            const operatorname_mathmlBuilder = (group, options) => {
              let expression = buildMathML_buildExpression(group.body, options.withFont("mathrm"));
              let isAllString = true;
              for (let i = 0; i < expression.length; i++) {
                const node = expression[i];
                if (node instanceof mathMLTree.SpaceNode) {
                } else if (node instanceof mathMLTree.MathNode) {
                  switch (node.type) {
                    case "mi":
                    case "mn":
                    case "ms":
                    case "mspace":
                    case "mtext":
                      break;
                    case "mo": {
                      const child = node.children[0];
                      if (node.children.length === 1 && child instanceof mathMLTree.TextNode) {
                        child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
                      } else {
                        isAllString = false;
                      }
                      break;
                    }
                    default:
                      isAllString = false;
                  }
                } else {
                  isAllString = false;
                }
              }
              if (isAllString) {
                const word = expression.map((node) => node.toText()).join("");
                expression = [new mathMLTree.TextNode(word)];
              }
              const identifier = new mathMLTree.MathNode("mi", expression);
              identifier.setAttribute("mathvariant", "normal");
              const operator = new mathMLTree.MathNode("mo", [makeText("\u2061", "text")]);
              if (group.parentIsSupSub) {
                return new mathMLTree.MathNode("mrow", [identifier, operator]);
              } else {
                return mathMLTree.newDocumentFragment([identifier, operator]);
              }
            };
            defineFunction({
              type: "operatorname",
              names: ["\\operatorname@", "\\operatornamewithlimits"],
              props: {
                numArgs: 1
              },
              handler: (_ref, args) => {
                let {
                  parser,
                  funcName
                } = _ref;
                const body = args[0];
                return {
                  type: "operatorname",
                  mode: parser.mode,
                  body: ordargument(body),
                  alwaysHandleSupSub: funcName === "\\operatornamewithlimits",
                  limits: false,
                  parentIsSupSub: false
                };
              },
              htmlBuilder: operatorname_htmlBuilder,
              mathmlBuilder: operatorname_mathmlBuilder
            });
            defineMacro("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
            ;
            defineFunctionBuilders({
              type: "ordgroup",
              htmlBuilder(group, options) {
                if (group.semisimple) {
                  return buildCommon.makeFragment(buildExpression(group.body, options, false));
                }
                return buildCommon.makeSpan(["mord"], buildExpression(group.body, options, true), options);
              },
              mathmlBuilder(group, options) {
                return buildExpressionRow(group.body, options, true);
              }
            });
            ;
            defineFunction({
              type: "overline",
              names: ["\\overline"],
              props: {
                numArgs: 1
              },
              handler(_ref, args) {
                let {
                  parser
                } = _ref;
                const body = args[0];
                return {
                  type: "overline",
                  mode: parser.mode,
                  body
                };
              },
              htmlBuilder(group, options) {
                const innerGroup = buildGroup(group.body, options.havingCrampedStyle());
                const line = buildCommon.makeLineSpan("overline-line", options);
                const defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
                const vlist = buildCommon.makeVList({
                  positionType: "firstBaseline",
                  children: [{
                    type: "elem",
                    elem: innerGroup
                  }, {
                    type: "kern",
                    size: 3 * defaultRuleThickness
                  }, {
                    type: "elem",
                    elem: line
                  }, {
                    type: "kern",
                    size: defaultRuleThickness
                  }]
                }, options);
                return buildCommon.makeSpan(["mord", "overline"], [vlist], options);
              },
              mathmlBuilder(group, options) {
                const operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203E")]);
                operator.setAttribute("stretchy", "true");
                const node = new mathMLTree.MathNode("mover", [buildMathML_buildGroup(group.body, options), operator]);
                node.setAttribute("accent", "true");
                return node;
              }
            });
            ;
            defineFunction({
              type: "phantom",
              names: ["\\phantom"],
              props: {
                numArgs: 1,
                allowedInText: true
              },
              handler: (_ref, args) => {
                let {
                  parser
                } = _ref;
                const body = args[0];
                return {
                  type: "phantom",
                  mode: parser.mode,
                  body: ordargument(body)
                };
              },
              htmlBuilder: (group, options) => {
                const elements = buildExpression(group.body, options.withPhantom(), false);
                return buildCommon.makeFragment(elements);
              },
              mathmlBuilder: (group, options) => {
                const inner2 = buildMathML_buildExpression(group.body, options);
                return new mathMLTree.MathNode("mphantom", inner2);
              }
            });
            defineFunction({
              type: "hphantom",
              names: ["\\hphantom"],
              props: {
                numArgs: 1,
                allowedInText: true
              },
              handler: (_ref2, args) => {
                let {
                  parser
                } = _ref2;
                const body = args[0];
                return {
                  type: "hphantom",
                  mode: parser.mode,
                  body
                };
              },
              htmlBuilder: (group, options) => {
                let node = buildCommon.makeSpan([], [buildGroup(group.body, options.withPhantom())]);
                node.height = 0;
                node.depth = 0;
                if (node.children) {
                  for (let i = 0; i < node.children.length; i++) {
                    node.children[i].height = 0;
                    node.children[i].depth = 0;
                  }
                }
                node = buildCommon.makeVList({
                  positionType: "firstBaseline",
                  children: [{
                    type: "elem",
                    elem: node
                  }]
                }, options);
                return buildCommon.makeSpan(["mord"], [node], options);
              },
              mathmlBuilder: (group, options) => {
                const inner2 = buildMathML_buildExpression(ordargument(group.body), options);
                const phantom = new mathMLTree.MathNode("mphantom", inner2);
                const node = new mathMLTree.MathNode("mpadded", [phantom]);
                node.setAttribute("height", "0px");
                node.setAttribute("depth", "0px");
                return node;
              }
            });
            defineFunction({
              type: "vphantom",
              names: ["\\vphantom"],
              props: {
                numArgs: 1,
                allowedInText: true
              },
              handler: (_ref3, args) => {
                let {
                  parser
                } = _ref3;
                const body = args[0];
                return {
                  type: "vphantom",
                  mode: parser.mode,
                  body
                };
              },
              htmlBuilder: (group, options) => {
                const inner2 = buildCommon.makeSpan(["inner"], [buildGroup(group.body, options.withPhantom())]);
                const fix = buildCommon.makeSpan(["fix"], []);
                return buildCommon.makeSpan(["mord", "rlap"], [inner2, fix], options);
              },
              mathmlBuilder: (group, options) => {
                const inner2 = buildMathML_buildExpression(ordargument(group.body), options);
                const phantom = new mathMLTree.MathNode("mphantom", inner2);
                const node = new mathMLTree.MathNode("mpadded", [phantom]);
                node.setAttribute("width", "0px");
                return node;
              }
            });
            ;
            defineFunction({
              type: "raisebox",
              names: ["\\raisebox"],
              props: {
                numArgs: 2,
                argTypes: ["size", "hbox"],
                allowedInText: true
              },
              handler(_ref, args) {
                let {
                  parser
                } = _ref;
                const amount = assertNodeType(args[0], "size").value;
                const body = args[1];
                return {
                  type: "raisebox",
                  mode: parser.mode,
                  dy: amount,
                  body
                };
              },
              htmlBuilder(group, options) {
                const body = buildGroup(group.body, options);
                const dy = calculateSize(group.dy, options);
                return buildCommon.makeVList({
                  positionType: "shift",
                  positionData: -dy,
                  children: [{
                    type: "elem",
                    elem: body
                  }]
                }, options);
              },
              mathmlBuilder(group, options) {
                const node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
                const dy = group.dy.number + group.dy.unit;
                node.setAttribute("voffset", dy);
                return node;
              }
            });
            ;
            defineFunction({
              type: "internal",
              names: ["\\relax"],
              props: {
                numArgs: 0,
                allowedInText: true,
                allowedInArgument: true
              },
              handler(_ref) {
                let {
                  parser
                } = _ref;
                return {
                  type: "internal",
                  mode: parser.mode
                };
              }
            });
            ;
            defineFunction({
              type: "rule",
              names: ["\\rule"],
              props: {
                numArgs: 2,
                numOptionalArgs: 1,
                allowedInText: true,
                allowedInMath: true,
                argTypes: ["size", "size", "size"]
              },
              handler(_ref, args, optArgs) {
                let {
                  parser
                } = _ref;
                const shift = optArgs[0];
                const width = assertNodeType(args[0], "size");
                const height = assertNodeType(args[1], "size");
                return {
                  type: "rule",
                  mode: parser.mode,
                  shift: shift && assertNodeType(shift, "size").value,
                  width: width.value,
                  height: height.value
                };
              },
              htmlBuilder(group, options) {
                const rule = buildCommon.makeSpan(["mord", "rule"], [], options);
                const width = calculateSize(group.width, options);
                const height = calculateSize(group.height, options);
                const shift = group.shift ? calculateSize(group.shift, options) : 0;
                rule.style.borderRightWidth = makeEm(width);
                rule.style.borderTopWidth = makeEm(height);
                rule.style.bottom = makeEm(shift);
                rule.width = width;
                rule.height = height + shift;
                rule.depth = -shift;
                rule.maxFontSize = height * 1.125 * options.sizeMultiplier;
                return rule;
              },
              mathmlBuilder(group, options) {
                const width = calculateSize(group.width, options);
                const height = calculateSize(group.height, options);
                const shift = group.shift ? calculateSize(group.shift, options) : 0;
                const color2 = options.color && options.getColor() || "black";
                const rule = new mathMLTree.MathNode("mspace");
                rule.setAttribute("mathbackground", color2);
                rule.setAttribute("width", makeEm(width));
                rule.setAttribute("height", makeEm(height));
                const wrapper = new mathMLTree.MathNode("mpadded", [rule]);
                if (shift >= 0) {
                  wrapper.setAttribute("height", makeEm(shift));
                } else {
                  wrapper.setAttribute("height", makeEm(shift));
                  wrapper.setAttribute("depth", makeEm(-shift));
                }
                wrapper.setAttribute("voffset", makeEm(shift));
                return wrapper;
              }
            });
            ;
            function sizingGroup(value, options, baseOptions) {
              const inner2 = buildExpression(value, options, false);
              const multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
              for (let i = 0; i < inner2.length; i++) {
                const pos = inner2[i].classes.indexOf("sizing");
                if (pos < 0) {
                  Array.prototype.push.apply(inner2[i].classes, options.sizingClasses(baseOptions));
                } else if (inner2[i].classes[pos + 1] === "reset-size" + options.size) {
                  inner2[i].classes[pos + 1] = "reset-size" + baseOptions.size;
                }
                inner2[i].height *= multiplier;
                inner2[i].depth *= multiplier;
              }
              return buildCommon.makeFragment(inner2);
            }
            const sizeFuncs = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
            const sizing_htmlBuilder = (group, options) => {
              const newOptions = options.havingSize(group.size);
              return sizingGroup(group.body, newOptions, options);
            };
            defineFunction({
              type: "sizing",
              names: sizeFuncs,
              props: {
                numArgs: 0,
                allowedInText: true
              },
              handler: (_ref, args) => {
                let {
                  breakOnTokenText,
                  funcName,
                  parser
                } = _ref;
                const body = parser.parseExpression(false, breakOnTokenText);
                return {
                  type: "sizing",
                  mode: parser.mode,
                  // Figure out what size to use based on the list of functions above
                  size: sizeFuncs.indexOf(funcName) + 1,
                  body
                };
              },
              htmlBuilder: sizing_htmlBuilder,
              mathmlBuilder: (group, options) => {
                const newOptions = options.havingSize(group.size);
                const inner2 = buildMathML_buildExpression(group.body, newOptions);
                const node = new mathMLTree.MathNode("mstyle", inner2);
                node.setAttribute("mathsize", makeEm(newOptions.sizeMultiplier));
                return node;
              }
            });
            ;
            defineFunction({
              type: "smash",
              names: ["\\smash"],
              props: {
                numArgs: 1,
                numOptionalArgs: 1,
                allowedInText: true
              },
              handler: (_ref, args, optArgs) => {
                let {
                  parser
                } = _ref;
                let smashHeight = false;
                let smashDepth = false;
                const tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");
                if (tbArg) {
                  let letter = "";
                  for (let i = 0; i < tbArg.body.length; ++i) {
                    const node = tbArg.body[i];
                    letter = node.text;
                    if (letter === "t") {
                      smashHeight = true;
                    } else if (letter === "b") {
                      smashDepth = true;
                    } else {
                      smashHeight = false;
                      smashDepth = false;
                      break;
                    }
                  }
                } else {
                  smashHeight = true;
                  smashDepth = true;
                }
                const body = args[0];
                return {
                  type: "smash",
                  mode: parser.mode,
                  body,
                  smashHeight,
                  smashDepth
                };
              },
              htmlBuilder: (group, options) => {
                const node = buildCommon.makeSpan([], [buildGroup(group.body, options)]);
                if (!group.smashHeight && !group.smashDepth) {
                  return node;
                }
                if (group.smashHeight) {
                  node.height = 0;
                  if (node.children) {
                    for (let i = 0; i < node.children.length; i++) {
                      node.children[i].height = 0;
                    }
                  }
                }
                if (group.smashDepth) {
                  node.depth = 0;
                  if (node.children) {
                    for (let i = 0; i < node.children.length; i++) {
                      node.children[i].depth = 0;
                    }
                  }
                }
                const smashedNode = buildCommon.makeVList({
                  positionType: "firstBaseline",
                  children: [{
                    type: "elem",
                    elem: node
                  }]
                }, options);
                return buildCommon.makeSpan(["mord"], [smashedNode], options);
              },
              mathmlBuilder: (group, options) => {
                const node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
                if (group.smashHeight) {
                  node.setAttribute("height", "0px");
                }
                if (group.smashDepth) {
                  node.setAttribute("depth", "0px");
                }
                return node;
              }
            });
            ;
            defineFunction({
              type: "sqrt",
              names: ["\\sqrt"],
              props: {
                numArgs: 1,
                numOptionalArgs: 1
              },
              handler(_ref, args, optArgs) {
                let {
                  parser
                } = _ref;
                const index2 = optArgs[0];
                const body = args[0];
                return {
                  type: "sqrt",
                  mode: parser.mode,
                  body,
                  index: index2
                };
              },
              htmlBuilder(group, options) {
                let inner2 = buildGroup(group.body, options.havingCrampedStyle());
                if (inner2.height === 0) {
                  inner2.height = options.fontMetrics().xHeight;
                }
                inner2 = buildCommon.wrapFragment(inner2, options);
                const metrics = options.fontMetrics();
                const theta = metrics.defaultRuleThickness;
                let phi = theta;
                if (options.style.id < src_Style.TEXT.id) {
                  phi = options.fontMetrics().xHeight;
                }
                let lineClearance = theta + phi / 4;
                const minDelimiterHeight = inner2.height + inner2.depth + lineClearance + theta;
                const {
                  span: img,
                  ruleWidth,
                  advanceWidth
                } = delimiter2.sqrtImage(minDelimiterHeight, options);
                const delimDepth = img.height - ruleWidth;
                if (delimDepth > inner2.height + inner2.depth + lineClearance) {
                  lineClearance = (lineClearance + delimDepth - inner2.height - inner2.depth) / 2;
                }
                const imgShift = img.height - inner2.height - lineClearance - ruleWidth;
                inner2.style.paddingLeft = makeEm(advanceWidth);
                const body = buildCommon.makeVList({
                  positionType: "firstBaseline",
                  children: [{
                    type: "elem",
                    elem: inner2,
                    wrapperClasses: ["svg-align"]
                  }, {
                    type: "kern",
                    size: -(inner2.height + imgShift)
                  }, {
                    type: "elem",
                    elem: img
                  }, {
                    type: "kern",
                    size: ruleWidth
                  }]
                }, options);
                if (!group.index) {
                  return buildCommon.makeSpan(["mord", "sqrt"], [body], options);
                } else {
                  const newOptions = options.havingStyle(src_Style.SCRIPTSCRIPT);
                  const rootm = buildGroup(group.index, newOptions, options);
                  const toShift = 0.6 * (body.height - body.depth);
                  const rootVList = buildCommon.makeVList({
                    positionType: "shift",
                    positionData: -toShift,
                    children: [{
                      type: "elem",
                      elem: rootm
                    }]
                  }, options);
                  const rootVListWrap = buildCommon.makeSpan(["root"], [rootVList]);
                  return buildCommon.makeSpan(["mord", "sqrt"], [rootVListWrap, body], options);
                }
              },
              mathmlBuilder(group, options) {
                const {
                  body,
                  index: index2
                } = group;
                return index2 ? new mathMLTree.MathNode("mroot", [buildMathML_buildGroup(body, options), buildMathML_buildGroup(index2, options)]) : new mathMLTree.MathNode("msqrt", [buildMathML_buildGroup(body, options)]);
              }
            });
            ;
            const styling_styleMap = {
              "display": src_Style.DISPLAY,
              "text": src_Style.TEXT,
              "script": src_Style.SCRIPT,
              "scriptscript": src_Style.SCRIPTSCRIPT
            };
            defineFunction({
              type: "styling",
              names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
              props: {
                numArgs: 0,
                allowedInText: true,
                primitive: true
              },
              handler(_ref, args) {
                let {
                  breakOnTokenText,
                  funcName,
                  parser
                } = _ref;
                const body = parser.parseExpression(true, breakOnTokenText);
                const style = funcName.slice(1, funcName.length - 5);
                return {
                  type: "styling",
                  mode: parser.mode,
                  // Figure out what style to use by pulling out the style from
                  // the function name
                  style,
                  body
                };
              },
              htmlBuilder(group, options) {
                const newStyle = styling_styleMap[group.style];
                const newOptions = options.havingStyle(newStyle).withFont("");
                return sizingGroup(group.body, newOptions, options);
              },
              mathmlBuilder(group, options) {
                const newStyle = styling_styleMap[group.style];
                const newOptions = options.havingStyle(newStyle);
                const inner2 = buildMathML_buildExpression(group.body, newOptions);
                const node = new mathMLTree.MathNode("mstyle", inner2);
                const styleAttributes = {
                  "display": ["0", "true"],
                  "text": ["0", "false"],
                  "script": ["1", "false"],
                  "scriptscript": ["2", "false"]
                };
                const attr2 = styleAttributes[group.style];
                node.setAttribute("scriptlevel", attr2[0]);
                node.setAttribute("displaystyle", attr2[1]);
                return node;
              }
            });
            ;
            const htmlBuilderDelegate = function(group, options) {
              const base2 = group.base;
              if (!base2) {
                return null;
              } else if (base2.type === "op") {
                const delegate = base2.limits && (options.style.size === src_Style.DISPLAY.size || base2.alwaysHandleSupSub);
                return delegate ? op_htmlBuilder : null;
              } else if (base2.type === "operatorname") {
                const delegate = base2.alwaysHandleSupSub && (options.style.size === src_Style.DISPLAY.size || base2.limits);
                return delegate ? operatorname_htmlBuilder : null;
              } else if (base2.type === "accent") {
                return utils.isCharacterBox(base2.base) ? htmlBuilder : null;
              } else if (base2.type === "horizBrace") {
                const isSup = !group.sub;
                return isSup === base2.isOver ? horizBrace_htmlBuilder : null;
              } else {
                return null;
              }
            };
            defineFunctionBuilders({
              type: "supsub",
              htmlBuilder(group, options) {
                const builderDelegate = htmlBuilderDelegate(group, options);
                if (builderDelegate) {
                  return builderDelegate(group, options);
                }
                const {
                  base: valueBase,
                  sup: valueSup,
                  sub: valueSub
                } = group;
                const base2 = buildGroup(valueBase, options);
                let supm;
                let subm;
                const metrics = options.fontMetrics();
                let supShift = 0;
                let subShift = 0;
                const isCharacterBox2 = valueBase && utils.isCharacterBox(valueBase);
                if (valueSup) {
                  const newOptions = options.havingStyle(options.style.sup());
                  supm = buildGroup(valueSup, newOptions, options);
                  if (!isCharacterBox2) {
                    supShift = base2.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
                  }
                }
                if (valueSub) {
                  const newOptions = options.havingStyle(options.style.sub());
                  subm = buildGroup(valueSub, newOptions, options);
                  if (!isCharacterBox2) {
                    subShift = base2.depth + newOptions.fontMetrics().subDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
                  }
                }
                let minSupShift;
                if (options.style === src_Style.DISPLAY) {
                  minSupShift = metrics.sup1;
                } else if (options.style.cramped) {
                  minSupShift = metrics.sup3;
                } else {
                  minSupShift = metrics.sup2;
                }
                const multiplier = options.sizeMultiplier;
                const marginRight = makeEm(0.5 / metrics.ptPerEm / multiplier);
                let marginLeft = null;
                if (subm) {
                  const isOiint = group.base && group.base.type === "op" && group.base.name && (group.base.name === "\\oiint" || group.base.name === "\\oiiint");
                  if (base2 instanceof SymbolNode || isOiint) {
                    marginLeft = makeEm(-base2.italic);
                  }
                }
                let supsub;
                if (supm && subm) {
                  supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
                  subShift = Math.max(subShift, metrics.sub2);
                  const ruleWidth = metrics.defaultRuleThickness;
                  const maxWidth = 4 * ruleWidth;
                  if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {
                    subShift = maxWidth - (supShift - supm.depth) + subm.height;
                    const psi = 0.8 * metrics.xHeight - (supShift - supm.depth);
                    if (psi > 0) {
                      supShift += psi;
                      subShift -= psi;
                    }
                  }
                  const vlistElem = [{
                    type: "elem",
                    elem: subm,
                    shift: subShift,
                    marginRight,
                    marginLeft
                  }, {
                    type: "elem",
                    elem: supm,
                    shift: -supShift,
                    marginRight
                  }];
                  supsub = buildCommon.makeVList({
                    positionType: "individualShift",
                    children: vlistElem
                  }, options);
                } else if (subm) {
                  subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);
                  const vlistElem = [{
                    type: "elem",
                    elem: subm,
                    marginLeft,
                    marginRight
                  }];
                  supsub = buildCommon.makeVList({
                    positionType: "shift",
                    positionData: subShift,
                    children: vlistElem
                  }, options);
                } else if (supm) {
                  supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
                  supsub = buildCommon.makeVList({
                    positionType: "shift",
                    positionData: -supShift,
                    children: [{
                      type: "elem",
                      elem: supm,
                      marginRight
                    }]
                  }, options);
                } else {
                  throw new Error("supsub must have either sup or sub.");
                }
                const mclass = getTypeOfDomTree(base2, "right") || "mord";
                return buildCommon.makeSpan([mclass], [base2, buildCommon.makeSpan(["msupsub"], [supsub])], options);
              },
              mathmlBuilder(group, options) {
                let isBrace = false;
                let isOver;
                let isSup;
                if (group.base && group.base.type === "horizBrace") {
                  isSup = !!group.sup;
                  if (isSup === group.base.isOver) {
                    isBrace = true;
                    isOver = group.base.isOver;
                  }
                }
                if (group.base && (group.base.type === "op" || group.base.type === "operatorname")) {
                  group.base.parentIsSupSub = true;
                }
                const children3 = [buildMathML_buildGroup(group.base, options)];
                if (group.sub) {
                  children3.push(buildMathML_buildGroup(group.sub, options));
                }
                if (group.sup) {
                  children3.push(buildMathML_buildGroup(group.sup, options));
                }
                let nodeType;
                if (isBrace) {
                  nodeType = isOver ? "mover" : "munder";
                } else if (!group.sub) {
                  const base2 = group.base;
                  if (base2 && base2.type === "op" && base2.limits && (options.style === src_Style.DISPLAY || base2.alwaysHandleSupSub)) {
                    nodeType = "mover";
                  } else if (base2 && base2.type === "operatorname" && base2.alwaysHandleSupSub && (base2.limits || options.style === src_Style.DISPLAY)) {
                    nodeType = "mover";
                  } else {
                    nodeType = "msup";
                  }
                } else if (!group.sup) {
                  const base2 = group.base;
                  if (base2 && base2.type === "op" && base2.limits && (options.style === src_Style.DISPLAY || base2.alwaysHandleSupSub)) {
                    nodeType = "munder";
                  } else if (base2 && base2.type === "operatorname" && base2.alwaysHandleSupSub && (base2.limits || options.style === src_Style.DISPLAY)) {
                    nodeType = "munder";
                  } else {
                    nodeType = "msub";
                  }
                } else {
                  const base2 = group.base;
                  if (base2 && base2.type === "op" && base2.limits && options.style === src_Style.DISPLAY) {
                    nodeType = "munderover";
                  } else if (base2 && base2.type === "operatorname" && base2.alwaysHandleSupSub && (options.style === src_Style.DISPLAY || base2.limits)) {
                    nodeType = "munderover";
                  } else {
                    nodeType = "msubsup";
                  }
                }
                return new mathMLTree.MathNode(nodeType, children3);
              }
            });
            ;
            defineFunctionBuilders({
              type: "atom",
              htmlBuilder(group, options) {
                return buildCommon.mathsym(group.text, group.mode, options, ["m" + group.family]);
              },
              mathmlBuilder(group, options) {
                const node = new mathMLTree.MathNode("mo", [makeText(group.text, group.mode)]);
                if (group.family === "bin") {
                  const variant = getVariant(group, options);
                  if (variant === "bold-italic") {
                    node.setAttribute("mathvariant", variant);
                  }
                } else if (group.family === "punct") {
                  node.setAttribute("separator", "true");
                } else if (group.family === "open" || group.family === "close") {
                  node.setAttribute("stretchy", "false");
                }
                return node;
              }
            });
            ;
            const defaultVariant = {
              "mi": "italic",
              "mn": "normal",
              "mtext": "normal"
            };
            defineFunctionBuilders({
              type: "mathord",
              htmlBuilder(group, options) {
                return buildCommon.makeOrd(group, options, "mathord");
              },
              mathmlBuilder(group, options) {
                const node = new mathMLTree.MathNode("mi", [makeText(group.text, group.mode, options)]);
                const variant = getVariant(group, options) || "italic";
                if (variant !== defaultVariant[node.type]) {
                  node.setAttribute("mathvariant", variant);
                }
                return node;
              }
            });
            defineFunctionBuilders({
              type: "textord",
              htmlBuilder(group, options) {
                return buildCommon.makeOrd(group, options, "textord");
              },
              mathmlBuilder(group, options) {
                const text3 = makeText(group.text, group.mode, options);
                const variant = getVariant(group, options) || "normal";
                let node;
                if (group.mode === "text") {
                  node = new mathMLTree.MathNode("mtext", [text3]);
                } else if (/[0-9]/.test(group.text)) {
                  node = new mathMLTree.MathNode("mn", [text3]);
                } else if (group.text === "\\prime") {
                  node = new mathMLTree.MathNode("mo", [text3]);
                } else {
                  node = new mathMLTree.MathNode("mi", [text3]);
                }
                if (variant !== defaultVariant[node.type]) {
                  node.setAttribute("mathvariant", variant);
                }
                return node;
              }
            });
            ;
            const cssSpace = {
              "\\nobreak": "nobreak",
              "\\allowbreak": "allowbreak"
            };
            const regularSpace = {
              " ": {},
              "\\ ": {},
              "~": {
                className: "nobreak"
              },
              "\\space": {},
              "\\nobreakspace": {
                className: "nobreak"
              }
            };
            defineFunctionBuilders({
              type: "spacing",
              htmlBuilder(group, options) {
                if (regularSpace.hasOwnProperty(group.text)) {
                  const className = regularSpace[group.text].className || "";
                  if (group.mode === "text") {
                    const ord = buildCommon.makeOrd(group, options, "textord");
                    ord.classes.push(className);
                    return ord;
                  } else {
                    return buildCommon.makeSpan(["mspace", className], [buildCommon.mathsym(group.text, group.mode, options)], options);
                  }
                } else if (cssSpace.hasOwnProperty(group.text)) {
                  return buildCommon.makeSpan(["mspace", cssSpace[group.text]], [], options);
                } else {
                  throw new src_ParseError('Unknown type of space "' + group.text + '"');
                }
              },
              mathmlBuilder(group, options) {
                let node;
                if (regularSpace.hasOwnProperty(group.text)) {
                  node = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode("\xA0")]);
                } else if (cssSpace.hasOwnProperty(group.text)) {
                  return new mathMLTree.MathNode("mspace");
                } else {
                  throw new src_ParseError('Unknown type of space "' + group.text + '"');
                }
                return node;
              }
            });
            ;
            const pad = () => {
              const padNode = new mathMLTree.MathNode("mtd", []);
              padNode.setAttribute("width", "50%");
              return padNode;
            };
            defineFunctionBuilders({
              type: "tag",
              mathmlBuilder(group, options) {
                const table2 = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mtr", [pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.body, options)]), pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.tag, options)])])]);
                table2.setAttribute("width", "100%");
                return table2;
              }
            });
            ;
            const textFontFamilies = {
              "\\text": void 0,
              "\\textrm": "textrm",
              "\\textsf": "textsf",
              "\\texttt": "texttt",
              "\\textnormal": "textrm"
            };
            const textFontWeights = {
              "\\textbf": "textbf",
              "\\textmd": "textmd"
            };
            const textFontShapes = {
              "\\textit": "textit",
              "\\textup": "textup"
            };
            const optionsWithFont = (group, options) => {
              const font = group.font;
              if (!font) {
                return options;
              } else if (textFontFamilies[font]) {
                return options.withTextFontFamily(textFontFamilies[font]);
              } else if (textFontWeights[font]) {
                return options.withTextFontWeight(textFontWeights[font]);
              } else if (font === "\\emph") {
                return options.fontShape === "textit" ? options.withTextFontShape("textup") : options.withTextFontShape("textit");
              }
              return options.withTextFontShape(textFontShapes[font]);
            };
            defineFunction({
              type: "text",
              names: [
                // Font families
                "\\text",
                "\\textrm",
                "\\textsf",
                "\\texttt",
                "\\textnormal",
                // Font weights
                "\\textbf",
                "\\textmd",
                // Font Shapes
                "\\textit",
                "\\textup",
                "\\emph"
              ],
              props: {
                numArgs: 1,
                argTypes: ["text"],
                allowedInArgument: true,
                allowedInText: true
              },
              handler(_ref, args) {
                let {
                  parser,
                  funcName
                } = _ref;
                const body = args[0];
                return {
                  type: "text",
                  mode: parser.mode,
                  body: ordargument(body),
                  font: funcName
                };
              },
              htmlBuilder(group, options) {
                const newOptions = optionsWithFont(group, options);
                const inner2 = buildExpression(group.body, newOptions, true);
                return buildCommon.makeSpan(["mord", "text"], inner2, newOptions);
              },
              mathmlBuilder(group, options) {
                const newOptions = optionsWithFont(group, options);
                return buildExpressionRow(group.body, newOptions);
              }
            });
            ;
            defineFunction({
              type: "underline",
              names: ["\\underline"],
              props: {
                numArgs: 1,
                allowedInText: true
              },
              handler(_ref, args) {
                let {
                  parser
                } = _ref;
                return {
                  type: "underline",
                  mode: parser.mode,
                  body: args[0]
                };
              },
              htmlBuilder(group, options) {
                const innerGroup = buildGroup(group.body, options);
                const line = buildCommon.makeLineSpan("underline-line", options);
                const defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
                const vlist = buildCommon.makeVList({
                  positionType: "top",
                  positionData: innerGroup.height,
                  children: [{
                    type: "kern",
                    size: defaultRuleThickness
                  }, {
                    type: "elem",
                    elem: line
                  }, {
                    type: "kern",
                    size: 3 * defaultRuleThickness
                  }, {
                    type: "elem",
                    elem: innerGroup
                  }]
                }, options);
                return buildCommon.makeSpan(["mord", "underline"], [vlist], options);
              },
              mathmlBuilder(group, options) {
                const operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203E")]);
                operator.setAttribute("stretchy", "true");
                const node = new mathMLTree.MathNode("munder", [buildMathML_buildGroup(group.body, options), operator]);
                node.setAttribute("accentunder", "true");
                return node;
              }
            });
            ;
            defineFunction({
              type: "vcenter",
              names: ["\\vcenter"],
              props: {
                numArgs: 1,
                argTypes: ["original"],
                // In LaTeX, \vcenter can act only on a box.
                allowedInText: false
              },
              handler(_ref, args) {
                let {
                  parser
                } = _ref;
                return {
                  type: "vcenter",
                  mode: parser.mode,
                  body: args[0]
                };
              },
              htmlBuilder(group, options) {
                const body = buildGroup(group.body, options);
                const axisHeight = options.fontMetrics().axisHeight;
                const dy = 0.5 * (body.height - axisHeight - (body.depth + axisHeight));
                return buildCommon.makeVList({
                  positionType: "shift",
                  positionData: dy,
                  children: [{
                    type: "elem",
                    elem: body
                  }]
                }, options);
              },
              mathmlBuilder(group, options) {
                return new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)], ["vcenter"]);
              }
            });
            ;
            defineFunction({
              type: "verb",
              names: ["\\verb"],
              props: {
                numArgs: 0,
                allowedInText: true
              },
              handler(context, args, optArgs) {
                throw new src_ParseError("\\verb ended by end of line instead of matching delimiter");
              },
              htmlBuilder(group, options) {
                const text3 = makeVerb(group);
                const body = [];
                const newOptions = options.havingStyle(options.style.text());
                for (let i = 0; i < text3.length; i++) {
                  let c = text3[i];
                  if (c === "~") {
                    c = "\\textasciitilde";
                  }
                  body.push(buildCommon.makeSymbol(c, "Typewriter-Regular", group.mode, newOptions, ["mord", "texttt"]));
                }
                return buildCommon.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options)), buildCommon.tryCombineChars(body), newOptions);
              },
              mathmlBuilder(group, options) {
                const text3 = new mathMLTree.TextNode(makeVerb(group));
                const node = new mathMLTree.MathNode("mtext", [text3]);
                node.setAttribute("mathvariant", "monospace");
                return node;
              }
            });
            const makeVerb = (group) => group.body.replace(/ /g, group.star ? "\u2423" : "\xA0");
            ;
            const functions = _functions;
            var src_functions = functions;
            ;
            const spaceRegexString = "[ \r\n	]";
            const controlWordRegexString = "\\\\[a-zA-Z@]+";
            const controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
            const controlWordWhitespaceRegexString = "(" + controlWordRegexString + ")" + spaceRegexString + "*";
            const controlSpaceRegexString = "\\\\(\n|[ \r	]+\n?)[ \r	]*";
            const combiningDiacriticalMarkString = "[\u0300-\u036F]";
            const combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + "+$");
            const tokenRegexString = "(" + spaceRegexString + "+)|" + // whitespace
            (controlSpaceRegexString + "|") + // \whitespace
            "([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" + // single codepoint
            (combiningDiacriticalMarkString + "*") + // ...plus accents
            "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
            (combiningDiacriticalMarkString + "*") + // ...plus accents
            "|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
            ("|" + controlWordWhitespaceRegexString) + // \macroName + spaces
            ("|" + controlSymbolRegexString + ")");
            class Lexer2 {
              // Category codes. The lexer only supports comment characters (14) for now.
              // MacroExpander additionally distinguishes active (13).
              constructor(input, settings) {
                this.input = void 0;
                this.settings = void 0;
                this.tokenRegex = void 0;
                this.catcodes = void 0;
                this.input = input;
                this.settings = settings;
                this.tokenRegex = new RegExp(tokenRegexString, "g");
                this.catcodes = {
                  "%": 14,
                  // comment character
                  "~": 13
                  // active character
                };
              }
              setCatcode(char, code2) {
                this.catcodes[char] = code2;
              }
              /**
               * This function lexes a single token.
               */
              lex() {
                const input = this.input;
                const pos = this.tokenRegex.lastIndex;
                if (pos === input.length) {
                  return new Token2("EOF", new SourceLocation(this, pos, pos));
                }
                const match2 = this.tokenRegex.exec(input);
                if (match2 === null || match2.index !== pos) {
                  throw new src_ParseError("Unexpected character: '" + input[pos] + "'", new Token2(input[pos], new SourceLocation(this, pos, pos + 1)));
                }
                const text3 = match2[6] || match2[3] || (match2[2] ? "\\ " : " ");
                if (this.catcodes[text3] === 14) {
                  const nlIndex = input.indexOf("\n", this.tokenRegex.lastIndex);
                  if (nlIndex === -1) {
                    this.tokenRegex.lastIndex = input.length;
                    this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)");
                  } else {
                    this.tokenRegex.lastIndex = nlIndex + 1;
                  }
                  return this.lex();
                }
                return new Token2(text3, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
              }
            }
            ;
            class Namespace {
              /**
               * Both arguments are optional.  The first argument is an object of
               * built-in mappings which never change.  The second argument is an object
               * of initial (global-level) mappings, which will constantly change
               * according to any global/top-level `set`s done.
               */
              constructor(builtins, globalMacros) {
                if (builtins === void 0) {
                  builtins = {};
                }
                if (globalMacros === void 0) {
                  globalMacros = {};
                }
                this.current = void 0;
                this.builtins = void 0;
                this.undefStack = void 0;
                this.current = globalMacros;
                this.builtins = builtins;
                this.undefStack = [];
              }
              /**
               * Start a new nested group, affecting future local `set`s.
               */
              beginGroup() {
                this.undefStack.push({});
              }
              /**
               * End current nested group, restoring values before the group began.
               */
              endGroup() {
                if (this.undefStack.length === 0) {
                  throw new src_ParseError("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
                }
                const undefs = this.undefStack.pop();
                for (const undef in undefs) {
                  if (undefs.hasOwnProperty(undef)) {
                    if (undefs[undef] == null) {
                      delete this.current[undef];
                    } else {
                      this.current[undef] = undefs[undef];
                    }
                  }
                }
              }
              /**
               * Ends all currently nested groups (if any), restoring values before the
               * groups began.  Useful in case of an error in the middle of parsing.
               */
              endGroups() {
                while (this.undefStack.length > 0) {
                  this.endGroup();
                }
              }
              /**
               * Detect whether `name` has a definition.  Equivalent to
               * `get(name) != null`.
               */
              has(name2) {
                return this.current.hasOwnProperty(name2) || this.builtins.hasOwnProperty(name2);
              }
              /**
               * Get the current value of a name, or `undefined` if there is no value.
               *
               * Note: Do not use `if (namespace.get(...))` to detect whether a macro
               * is defined, as the definition may be the empty string which evaluates
               * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
               * `if (namespace.has(...))`.
               */
              get(name2) {
                if (this.current.hasOwnProperty(name2)) {
                  return this.current[name2];
                } else {
                  return this.builtins[name2];
                }
              }
              /**
               * Set the current value of a name, and optionally set it globally too.
               * Local set() sets the current value and (when appropriate) adds an undo
               * operation to the undo stack.  Global set() may change the undo
               * operation at every level, so takes time linear in their number.
               * A value of undefined means to delete existing definitions.
               */
              set(name2, value, global) {
                if (global === void 0) {
                  global = false;
                }
                if (global) {
                  for (let i = 0; i < this.undefStack.length; i++) {
                    delete this.undefStack[i][name2];
                  }
                  if (this.undefStack.length > 0) {
                    this.undefStack[this.undefStack.length - 1][name2] = value;
                  }
                } else {
                  const top = this.undefStack[this.undefStack.length - 1];
                  if (top && !top.hasOwnProperty(name2)) {
                    top[name2] = this.current[name2];
                  }
                }
                if (value == null) {
                  delete this.current[name2];
                } else {
                  this.current[name2] = value;
                }
              }
            }
            ;
            const macros = _macros;
            var src_macros = macros;
            defineMacro("\\noexpand", function(context) {
              const t = context.popToken();
              if (context.isExpandable(t.text)) {
                t.noexpand = true;
                t.treatAsRelax = true;
              }
              return {
                tokens: [t],
                numArgs: 0
              };
            });
            defineMacro("\\expandafter", function(context) {
              const t = context.popToken();
              context.expandOnce(true);
              return {
                tokens: [t],
                numArgs: 0
              };
            });
            defineMacro("\\@firstoftwo", function(context) {
              const args = context.consumeArgs(2);
              return {
                tokens: args[0],
                numArgs: 0
              };
            });
            defineMacro("\\@secondoftwo", function(context) {
              const args = context.consumeArgs(2);
              return {
                tokens: args[1],
                numArgs: 0
              };
            });
            defineMacro("\\@ifnextchar", function(context) {
              const args = context.consumeArgs(3);
              context.consumeSpaces();
              const nextToken = context.future();
              if (args[0].length === 1 && args[0][0].text === nextToken.text) {
                return {
                  tokens: args[1],
                  numArgs: 0
                };
              } else {
                return {
                  tokens: args[2],
                  numArgs: 0
                };
              }
            });
            defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
            defineMacro("\\TextOrMath", function(context) {
              const args = context.consumeArgs(2);
              if (context.mode === "text") {
                return {
                  tokens: args[0],
                  numArgs: 0
                };
              } else {
                return {
                  tokens: args[1],
                  numArgs: 0
                };
              }
            });
            const digitToNumber = {
              "0": 0,
              "1": 1,
              "2": 2,
              "3": 3,
              "4": 4,
              "5": 5,
              "6": 6,
              "7": 7,
              "8": 8,
              "9": 9,
              "a": 10,
              "A": 10,
              "b": 11,
              "B": 11,
              "c": 12,
              "C": 12,
              "d": 13,
              "D": 13,
              "e": 14,
              "E": 14,
              "f": 15,
              "F": 15
            };
            defineMacro("\\char", function(context) {
              let token = context.popToken();
              let base2;
              let number = "";
              if (token.text === "'") {
                base2 = 8;
                token = context.popToken();
              } else if (token.text === '"') {
                base2 = 16;
                token = context.popToken();
              } else if (token.text === "`") {
                token = context.popToken();
                if (token.text[0] === "\\") {
                  number = token.text.charCodeAt(1);
                } else if (token.text === "EOF") {
                  throw new src_ParseError("\\char` missing argument");
                } else {
                  number = token.text.charCodeAt(0);
                }
              } else {
                base2 = 10;
              }
              if (base2) {
                number = digitToNumber[token.text];
                if (number == null || number >= base2) {
                  throw new src_ParseError("Invalid base-" + base2 + " digit " + token.text);
                }
                let digit;
                while ((digit = digitToNumber[context.future().text]) != null && digit < base2) {
                  number *= base2;
                  number += digit;
                  context.popToken();
                }
              }
              return "\\@char{" + number + "}";
            });
            const newcommand = (context, existsOK, nonexistsOK, skipIfExists) => {
              let arg = context.consumeArg().tokens;
              if (arg.length !== 1) {
                throw new src_ParseError("\\newcommand's first argument must be a macro name");
              }
              const name2 = arg[0].text;
              const exists = context.isDefined(name2);
              if (exists && !existsOK) {
                throw new src_ParseError("\\newcommand{" + name2 + "} attempting to redefine " + (name2 + "; use \\renewcommand"));
              }
              if (!exists && !nonexistsOK) {
                throw new src_ParseError("\\renewcommand{" + name2 + "} when command " + name2 + " does not yet exist; use \\newcommand");
              }
              let numArgs = 0;
              arg = context.consumeArg().tokens;
              if (arg.length === 1 && arg[0].text === "[") {
                let argText = "";
                let token = context.expandNextToken();
                while (token.text !== "]" && token.text !== "EOF") {
                  argText += token.text;
                  token = context.expandNextToken();
                }
                if (!argText.match(/^\s*[0-9]+\s*$/)) {
                  throw new src_ParseError("Invalid number of arguments: " + argText);
                }
                numArgs = parseInt(argText);
                arg = context.consumeArg().tokens;
              }
              if (!(exists && skipIfExists)) {
                context.macros.set(name2, {
                  tokens: arg,
                  numArgs
                });
              }
              return "";
            };
            defineMacro("\\newcommand", (context) => newcommand(context, false, true, false));
            defineMacro("\\renewcommand", (context) => newcommand(context, true, false, false));
            defineMacro("\\providecommand", (context) => newcommand(context, true, true, true));
            defineMacro("\\message", (context) => {
              const arg = context.consumeArgs(1)[0];
              console.log(arg.reverse().map((token) => token.text).join(""));
              return "";
            });
            defineMacro("\\errmessage", (context) => {
              const arg = context.consumeArgs(1)[0];
              console.error(arg.reverse().map((token) => token.text).join(""));
              return "";
            });
            defineMacro("\\show", (context) => {
              const tok = context.popToken();
              const name2 = tok.text;
              console.log(tok, context.macros.get(name2), src_functions[name2], src_symbols.math[name2], src_symbols.text[name2]);
              return "";
            });
            defineMacro("\\bgroup", "{");
            defineMacro("\\egroup", "}");
            defineMacro("~", "\\nobreakspace");
            defineMacro("\\lq", "`");
            defineMacro("\\rq", "'");
            defineMacro("\\aa", "\\r a");
            defineMacro("\\AA", "\\r A");
            defineMacro("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`\xA9}");
            defineMacro("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
            defineMacro("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`\xAE}");
            defineMacro("\u212C", "\\mathscr{B}");
            defineMacro("\u2130", "\\mathscr{E}");
            defineMacro("\u2131", "\\mathscr{F}");
            defineMacro("\u210B", "\\mathscr{H}");
            defineMacro("\u2110", "\\mathscr{I}");
            defineMacro("\u2112", "\\mathscr{L}");
            defineMacro("\u2133", "\\mathscr{M}");
            defineMacro("\u211B", "\\mathscr{R}");
            defineMacro("\u212D", "\\mathfrak{C}");
            defineMacro("\u210C", "\\mathfrak{H}");
            defineMacro("\u2128", "\\mathfrak{Z}");
            defineMacro("\\Bbbk", "\\Bbb{k}");
            defineMacro("\xB7", "\\cdotp");
            defineMacro("\\llap", "\\mathllap{\\textrm{#1}}");
            defineMacro("\\rlap", "\\mathrlap{\\textrm{#1}}");
            defineMacro("\\clap", "\\mathclap{\\textrm{#1}}");
            defineMacro("\\mathstrut", "\\vphantom{(}");
            defineMacro("\\underbar", "\\underline{\\text{#1}}");
            defineMacro("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
            defineMacro("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`\u2260}}");
            defineMacro("\\ne", "\\neq");
            defineMacro("\u2260", "\\neq");
            defineMacro("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`\u2209}}");
            defineMacro("\u2209", "\\notin");
            defineMacro("\u2258", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`\u2258}}");
            defineMacro("\u2259", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`\u2258}}");
            defineMacro("\u225A", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`\u225A}}");
            defineMacro("\u225B", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`\u225B}}");
            defineMacro("\u225D", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`\u225D}}");
            defineMacro("\u225E", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`\u225E}}");
            defineMacro("\u225F", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`\u225F}}");
            defineMacro("\u27C2", "\\perp");
            defineMacro("\u203C", "\\mathclose{!\\mkern-0.8mu!}");
            defineMacro("\u220C", "\\notni");
            defineMacro("\u231C", "\\ulcorner");
            defineMacro("\u231D", "\\urcorner");
            defineMacro("\u231E", "\\llcorner");
            defineMacro("\u231F", "\\lrcorner");
            defineMacro("\xA9", "\\copyright");
            defineMacro("\xAE", "\\textregistered");
            defineMacro("\uFE0F", "\\textregistered");
            defineMacro("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
            defineMacro("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
            defineMacro("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
            defineMacro("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
            defineMacro("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}");
            defineMacro("\u22EE", "\\vdots");
            defineMacro("\\varGamma", "\\mathit{\\Gamma}");
            defineMacro("\\varDelta", "\\mathit{\\Delta}");
            defineMacro("\\varTheta", "\\mathit{\\Theta}");
            defineMacro("\\varLambda", "\\mathit{\\Lambda}");
            defineMacro("\\varXi", "\\mathit{\\Xi}");
            defineMacro("\\varPi", "\\mathit{\\Pi}");
            defineMacro("\\varSigma", "\\mathit{\\Sigma}");
            defineMacro("\\varUpsilon", "\\mathit{\\Upsilon}");
            defineMacro("\\varPhi", "\\mathit{\\Phi}");
            defineMacro("\\varPsi", "\\mathit{\\Psi}");
            defineMacro("\\varOmega", "\\mathit{\\Omega}");
            defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
            defineMacro("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
            defineMacro("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
            defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
            defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
            defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
            defineMacro("\\dddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ...}}{#1}}");
            defineMacro("\\ddddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ....}}{#1}}");
            const dotsByToken = {
              ",": "\\dotsc",
              "\\not": "\\dotsb",
              // \keybin@ checks for the following:
              "+": "\\dotsb",
              "=": "\\dotsb",
              "<": "\\dotsb",
              ">": "\\dotsb",
              "-": "\\dotsb",
              "*": "\\dotsb",
              ":": "\\dotsb",
              // Symbols whose definition starts with \DOTSB:
              "\\DOTSB": "\\dotsb",
              "\\coprod": "\\dotsb",
              "\\bigvee": "\\dotsb",
              "\\bigwedge": "\\dotsb",
              "\\biguplus": "\\dotsb",
              "\\bigcap": "\\dotsb",
              "\\bigcup": "\\dotsb",
              "\\prod": "\\dotsb",
              "\\sum": "\\dotsb",
              "\\bigotimes": "\\dotsb",
              "\\bigoplus": "\\dotsb",
              "\\bigodot": "\\dotsb",
              "\\bigsqcup": "\\dotsb",
              "\\And": "\\dotsb",
              "\\longrightarrow": "\\dotsb",
              "\\Longrightarrow": "\\dotsb",
              "\\longleftarrow": "\\dotsb",
              "\\Longleftarrow": "\\dotsb",
              "\\longleftrightarrow": "\\dotsb",
              "\\Longleftrightarrow": "\\dotsb",
              "\\mapsto": "\\dotsb",
              "\\longmapsto": "\\dotsb",
              "\\hookrightarrow": "\\dotsb",
              "\\doteq": "\\dotsb",
              // Symbols whose definition starts with \mathbin:
              "\\mathbin": "\\dotsb",
              // Symbols whose definition starts with \mathrel:
              "\\mathrel": "\\dotsb",
              "\\relbar": "\\dotsb",
              "\\Relbar": "\\dotsb",
              "\\xrightarrow": "\\dotsb",
              "\\xleftarrow": "\\dotsb",
              // Symbols whose definition starts with \DOTSI:
              "\\DOTSI": "\\dotsi",
              "\\int": "\\dotsi",
              "\\oint": "\\dotsi",
              "\\iint": "\\dotsi",
              "\\iiint": "\\dotsi",
              "\\iiiint": "\\dotsi",
              "\\idotsint": "\\dotsi",
              // Symbols whose definition starts with \DOTSX:
              "\\DOTSX": "\\dotsx"
            };
            defineMacro("\\dots", function(context) {
              let thedots = "\\dotso";
              const next2 = context.expandAfterFuture().text;
              if (next2 in dotsByToken) {
                thedots = dotsByToken[next2];
              } else if (next2.slice(0, 4) === "\\not") {
                thedots = "\\dotsb";
              } else if (next2 in src_symbols.math) {
                if (["bin", "rel"].includes(src_symbols.math[next2].group)) {
                  thedots = "\\dotsb";
                }
              }
              return thedots;
            });
            const spaceAfterDots = {
              // \rightdelim@ checks for the following:
              ")": true,
              "]": true,
              "\\rbrack": true,
              "\\}": true,
              "\\rbrace": true,
              "\\rangle": true,
              "\\rceil": true,
              "\\rfloor": true,
              "\\rgroup": true,
              "\\rmoustache": true,
              "\\right": true,
              "\\bigr": true,
              "\\biggr": true,
              "\\Bigr": true,
              "\\Biggr": true,
              // \extra@ also tests for the following:
              "$": true,
              // \extrap@ checks for the following:
              ";": true,
              ".": true,
              ",": true
            };
            defineMacro("\\dotso", function(context) {
              const next2 = context.future().text;
              if (next2 in spaceAfterDots) {
                return "\\ldots\\,";
              } else {
                return "\\ldots";
              }
            });
            defineMacro("\\dotsc", function(context) {
              const next2 = context.future().text;
              if (next2 in spaceAfterDots && next2 !== ",") {
                return "\\ldots\\,";
              } else {
                return "\\ldots";
              }
            });
            defineMacro("\\cdots", function(context) {
              const next2 = context.future().text;
              if (next2 in spaceAfterDots) {
                return "\\@cdots\\,";
              } else {
                return "\\@cdots";
              }
            });
            defineMacro("\\dotsb", "\\cdots");
            defineMacro("\\dotsm", "\\cdots");
            defineMacro("\\dotsi", "\\!\\cdots");
            defineMacro("\\dotsx", "\\ldots\\,");
            defineMacro("\\DOTSI", "\\relax");
            defineMacro("\\DOTSB", "\\relax");
            defineMacro("\\DOTSX", "\\relax");
            defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
            defineMacro("\\,", "\\tmspace+{3mu}{.1667em}");
            defineMacro("\\thinspace", "\\,");
            defineMacro("\\>", "\\mskip{4mu}");
            defineMacro("\\:", "\\tmspace+{4mu}{.2222em}");
            defineMacro("\\medspace", "\\:");
            defineMacro("\\;", "\\tmspace+{5mu}{.2777em}");
            defineMacro("\\thickspace", "\\;");
            defineMacro("\\!", "\\tmspace-{3mu}{.1667em}");
            defineMacro("\\negthinspace", "\\!");
            defineMacro("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
            defineMacro("\\negthickspace", "\\tmspace-{5mu}{.277em}");
            defineMacro("\\enspace", "\\kern.5em ");
            defineMacro("\\enskip", "\\hskip.5em\\relax");
            defineMacro("\\quad", "\\hskip1em\\relax");
            defineMacro("\\qquad", "\\hskip2em\\relax");
            defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
            defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
            defineMacro("\\tag@literal", (context) => {
              if (context.macros.get("\\df@tag")) {
                throw new src_ParseError("Multiple \\tag");
              }
              return "\\gdef\\df@tag{\\text{#1}}";
            });
            defineMacro("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
            defineMacro("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
            defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
            defineMacro("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
            defineMacro("\\newline", "\\\\\\relax");
            defineMacro("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
            const latexRaiseA = makeEm(fontMetricsData["Main-Regular"]["T".charCodeAt(0)][1] - 0.7 * fontMetricsData["Main-Regular"]["A".charCodeAt(0)][1]);
            defineMacro("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
            defineMacro("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
            defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
            defineMacro("\\@hspace", "\\hskip #1\\relax");
            defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
            defineMacro("\\ordinarycolon", ":");
            defineMacro("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
            defineMacro("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
            defineMacro("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
            defineMacro("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
            defineMacro("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
            defineMacro("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
            defineMacro("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
            defineMacro("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
            defineMacro("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
            defineMacro("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
            defineMacro("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
            defineMacro("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
            defineMacro("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
            defineMacro("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
            defineMacro("\u2237", "\\dblcolon");
            defineMacro("\u2239", "\\eqcolon");
            defineMacro("\u2254", "\\coloneqq");
            defineMacro("\u2255", "\\eqqcolon");
            defineMacro("\u2A74", "\\Coloneqq");
            defineMacro("\\ratio", "\\vcentcolon");
            defineMacro("\\coloncolon", "\\dblcolon");
            defineMacro("\\colonequals", "\\coloneqq");
            defineMacro("\\coloncolonequals", "\\Coloneqq");
            defineMacro("\\equalscolon", "\\eqqcolon");
            defineMacro("\\equalscoloncolon", "\\Eqqcolon");
            defineMacro("\\colonminus", "\\coloneq");
            defineMacro("\\coloncolonminus", "\\Coloneq");
            defineMacro("\\minuscolon", "\\eqcolon");
            defineMacro("\\minuscoloncolon", "\\Eqcolon");
            defineMacro("\\coloncolonapprox", "\\Colonapprox");
            defineMacro("\\coloncolonsim", "\\Colonsim");
            defineMacro("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
            defineMacro("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
            defineMacro("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
            defineMacro("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
            defineMacro("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`\u220C}}");
            defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
            defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
            defineMacro("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
            defineMacro("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
            defineMacro("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
            defineMacro("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
            defineMacro("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
            defineMacro("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
            defineMacro("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{\u2269}");
            defineMacro("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{\u2268}");
            defineMacro("\\ngeqq", "\\html@mathml{\\@ngeqq}{\u2271}");
            defineMacro("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{\u2271}");
            defineMacro("\\nleqq", "\\html@mathml{\\@nleqq}{\u2270}");
            defineMacro("\\nleqslant", "\\html@mathml{\\@nleqslant}{\u2270}");
            defineMacro("\\nshortmid", "\\html@mathml{\\@nshortmid}{\u2224}");
            defineMacro("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{\u2226}");
            defineMacro("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{\u2288}");
            defineMacro("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{\u2289}");
            defineMacro("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{\u228A}");
            defineMacro("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{\u2ACB}");
            defineMacro("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{\u228B}");
            defineMacro("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{\u2ACC}");
            defineMacro("\\imath", "\\html@mathml{\\@imath}{\u0131}");
            defineMacro("\\jmath", "\\html@mathml{\\@jmath}{\u0237}");
            defineMacro("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`\u27E6}}");
            defineMacro("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`\u27E7}}");
            defineMacro("\u27E6", "\\llbracket");
            defineMacro("\u27E7", "\\rrbracket");
            defineMacro("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`\u2983}}");
            defineMacro("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`\u2984}}");
            defineMacro("\u2983", "\\lBrace");
            defineMacro("\u2984", "\\rBrace");
            defineMacro("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`\u29B5}}");
            defineMacro("\u29B5", "\\minuso");
            defineMacro("\\darr", "\\downarrow");
            defineMacro("\\dArr", "\\Downarrow");
            defineMacro("\\Darr", "\\Downarrow");
            defineMacro("\\lang", "\\langle");
            defineMacro("\\rang", "\\rangle");
            defineMacro("\\uarr", "\\uparrow");
            defineMacro("\\uArr", "\\Uparrow");
            defineMacro("\\Uarr", "\\Uparrow");
            defineMacro("\\N", "\\mathbb{N}");
            defineMacro("\\R", "\\mathbb{R}");
            defineMacro("\\Z", "\\mathbb{Z}");
            defineMacro("\\alef", "\\aleph");
            defineMacro("\\alefsym", "\\aleph");
            defineMacro("\\Alpha", "\\mathrm{A}");
            defineMacro("\\Beta", "\\mathrm{B}");
            defineMacro("\\bull", "\\bullet");
            defineMacro("\\Chi", "\\mathrm{X}");
            defineMacro("\\clubs", "\\clubsuit");
            defineMacro("\\cnums", "\\mathbb{C}");
            defineMacro("\\Complex", "\\mathbb{C}");
            defineMacro("\\Dagger", "\\ddagger");
            defineMacro("\\diamonds", "\\diamondsuit");
            defineMacro("\\empty", "\\emptyset");
            defineMacro("\\Epsilon", "\\mathrm{E}");
            defineMacro("\\Eta", "\\mathrm{H}");
            defineMacro("\\exist", "\\exists");
            defineMacro("\\harr", "\\leftrightarrow");
            defineMacro("\\hArr", "\\Leftrightarrow");
            defineMacro("\\Harr", "\\Leftrightarrow");
            defineMacro("\\hearts", "\\heartsuit");
            defineMacro("\\image", "\\Im");
            defineMacro("\\infin", "\\infty");
            defineMacro("\\Iota", "\\mathrm{I}");
            defineMacro("\\isin", "\\in");
            defineMacro("\\Kappa", "\\mathrm{K}");
            defineMacro("\\larr", "\\leftarrow");
            defineMacro("\\lArr", "\\Leftarrow");
            defineMacro("\\Larr", "\\Leftarrow");
            defineMacro("\\lrarr", "\\leftrightarrow");
            defineMacro("\\lrArr", "\\Leftrightarrow");
            defineMacro("\\Lrarr", "\\Leftrightarrow");
            defineMacro("\\Mu", "\\mathrm{M}");
            defineMacro("\\natnums", "\\mathbb{N}");
            defineMacro("\\Nu", "\\mathrm{N}");
            defineMacro("\\Omicron", "\\mathrm{O}");
            defineMacro("\\plusmn", "\\pm");
            defineMacro("\\rarr", "\\rightarrow");
            defineMacro("\\rArr", "\\Rightarrow");
            defineMacro("\\Rarr", "\\Rightarrow");
            defineMacro("\\real", "\\Re");
            defineMacro("\\reals", "\\mathbb{R}");
            defineMacro("\\Reals", "\\mathbb{R}");
            defineMacro("\\Rho", "\\mathrm{P}");
            defineMacro("\\sdot", "\\cdot");
            defineMacro("\\sect", "\\S");
            defineMacro("\\spades", "\\spadesuit");
            defineMacro("\\sub", "\\subset");
            defineMacro("\\sube", "\\subseteq");
            defineMacro("\\supe", "\\supseteq");
            defineMacro("\\Tau", "\\mathrm{T}");
            defineMacro("\\thetasym", "\\vartheta");
            defineMacro("\\weierp", "\\wp");
            defineMacro("\\Zeta", "\\mathrm{Z}");
            defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
            defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
            defineMacro("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
            defineMacro("\\bra", "\\mathinner{\\langle{#1}|}");
            defineMacro("\\ket", "\\mathinner{|{#1}\\rangle}");
            defineMacro("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
            defineMacro("\\Bra", "\\left\\langle#1\\right|");
            defineMacro("\\Ket", "\\left|#1\\right\\rangle");
            const braketHelper = (one2) => (context) => {
              const left = context.consumeArg().tokens;
              const middle = context.consumeArg().tokens;
              const middleDouble = context.consumeArg().tokens;
              const right = context.consumeArg().tokens;
              const oldMiddle = context.macros.get("|");
              const oldMiddleDouble = context.macros.get("\\|");
              context.macros.beginGroup();
              const midMacro = (double) => (context2) => {
                if (one2) {
                  context2.macros.set("|", oldMiddle);
                  if (middleDouble.length) {
                    context2.macros.set("\\|", oldMiddleDouble);
                  }
                }
                let doubled = double;
                if (!double && middleDouble.length) {
                  const nextToken = context2.future();
                  if (nextToken.text === "|") {
                    context2.popToken();
                    doubled = true;
                  }
                }
                return {
                  tokens: doubled ? middleDouble : middle,
                  numArgs: 0
                };
              };
              context.macros.set("|", midMacro(false));
              if (middleDouble.length) {
                context.macros.set("\\|", midMacro(true));
              }
              const arg = context.consumeArg().tokens;
              const expanded = context.expandTokens([
                ...right,
                ...arg,
                ...left
                // reversed
              ]);
              context.macros.endGroup();
              return {
                tokens: expanded.reverse(),
                numArgs: 0
              };
            };
            defineMacro("\\bra@ket", braketHelper(false));
            defineMacro("\\bra@set", braketHelper(true));
            defineMacro("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
            defineMacro("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
            defineMacro("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
            defineMacro("\\angln", "{\\angl n}");
            defineMacro("\\blue", "\\textcolor{##6495ed}{#1}");
            defineMacro("\\orange", "\\textcolor{##ffa500}{#1}");
            defineMacro("\\pink", "\\textcolor{##ff00af}{#1}");
            defineMacro("\\red", "\\textcolor{##df0030}{#1}");
            defineMacro("\\green", "\\textcolor{##28ae7b}{#1}");
            defineMacro("\\gray", "\\textcolor{gray}{#1}");
            defineMacro("\\purple", "\\textcolor{##9d38bd}{#1}");
            defineMacro("\\blueA", "\\textcolor{##ccfaff}{#1}");
            defineMacro("\\blueB", "\\textcolor{##80f6ff}{#1}");
            defineMacro("\\blueC", "\\textcolor{##63d9ea}{#1}");
            defineMacro("\\blueD", "\\textcolor{##11accd}{#1}");
            defineMacro("\\blueE", "\\textcolor{##0c7f99}{#1}");
            defineMacro("\\tealA", "\\textcolor{##94fff5}{#1}");
            defineMacro("\\tealB", "\\textcolor{##26edd5}{#1}");
            defineMacro("\\tealC", "\\textcolor{##01d1c1}{#1}");
            defineMacro("\\tealD", "\\textcolor{##01a995}{#1}");
            defineMacro("\\tealE", "\\textcolor{##208170}{#1}");
            defineMacro("\\greenA", "\\textcolor{##b6ffb0}{#1}");
            defineMacro("\\greenB", "\\textcolor{##8af281}{#1}");
            defineMacro("\\greenC", "\\textcolor{##74cf70}{#1}");
            defineMacro("\\greenD", "\\textcolor{##1fab54}{#1}");
            defineMacro("\\greenE", "\\textcolor{##0d923f}{#1}");
            defineMacro("\\goldA", "\\textcolor{##ffd0a9}{#1}");
            defineMacro("\\goldB", "\\textcolor{##ffbb71}{#1}");
            defineMacro("\\goldC", "\\textcolor{##ff9c39}{#1}");
            defineMacro("\\goldD", "\\textcolor{##e07d10}{#1}");
            defineMacro("\\goldE", "\\textcolor{##a75a05}{#1}");
            defineMacro("\\redA", "\\textcolor{##fca9a9}{#1}");
            defineMacro("\\redB", "\\textcolor{##ff8482}{#1}");
            defineMacro("\\redC", "\\textcolor{##f9685d}{#1}");
            defineMacro("\\redD", "\\textcolor{##e84d39}{#1}");
            defineMacro("\\redE", "\\textcolor{##bc2612}{#1}");
            defineMacro("\\maroonA", "\\textcolor{##ffbde0}{#1}");
            defineMacro("\\maroonB", "\\textcolor{##ff92c6}{#1}");
            defineMacro("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
            defineMacro("\\maroonD", "\\textcolor{##ca337c}{#1}");
            defineMacro("\\maroonE", "\\textcolor{##9e034e}{#1}");
            defineMacro("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
            defineMacro("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
            defineMacro("\\purpleC", "\\textcolor{##aa87ff}{#1}");
            defineMacro("\\purpleD", "\\textcolor{##7854ab}{#1}");
            defineMacro("\\purpleE", "\\textcolor{##543b78}{#1}");
            defineMacro("\\mintA", "\\textcolor{##f5f9e8}{#1}");
            defineMacro("\\mintB", "\\textcolor{##edf2df}{#1}");
            defineMacro("\\mintC", "\\textcolor{##e0e5cc}{#1}");
            defineMacro("\\grayA", "\\textcolor{##f6f7f7}{#1}");
            defineMacro("\\grayB", "\\textcolor{##f0f1f2}{#1}");
            defineMacro("\\grayC", "\\textcolor{##e3e5e6}{#1}");
            defineMacro("\\grayD", "\\textcolor{##d6d8da}{#1}");
            defineMacro("\\grayE", "\\textcolor{##babec2}{#1}");
            defineMacro("\\grayF", "\\textcolor{##888d93}{#1}");
            defineMacro("\\grayG", "\\textcolor{##626569}{#1}");
            defineMacro("\\grayH", "\\textcolor{##3b3e40}{#1}");
            defineMacro("\\grayI", "\\textcolor{##21242c}{#1}");
            defineMacro("\\kaBlue", "\\textcolor{##314453}{#1}");
            defineMacro("\\kaGreen", "\\textcolor{##71B307}{#1}");
            ;
            const implicitCommands = {
              "^": true,
              // Parser.js
              "_": true,
              // Parser.js
              "\\limits": true,
              // Parser.js
              "\\nolimits": true
              // Parser.js
            };
            class MacroExpander {
              constructor(input, settings, mode) {
                this.settings = void 0;
                this.expansionCount = void 0;
                this.lexer = void 0;
                this.macros = void 0;
                this.stack = void 0;
                this.mode = void 0;
                this.settings = settings;
                this.expansionCount = 0;
                this.feed(input);
                this.macros = new Namespace(src_macros, settings.macros);
                this.mode = mode;
                this.stack = [];
              }
              /**
               * Feed a new input string to the same MacroExpander
               * (with existing macros etc.).
               */
              feed(input) {
                this.lexer = new Lexer2(input, this.settings);
              }
              /**
               * Switches between "text" and "math" modes.
               */
              switchMode(newMode) {
                this.mode = newMode;
              }
              /**
               * Start a new group nesting within all namespaces.
               */
              beginGroup() {
                this.macros.beginGroup();
              }
              /**
               * End current group nesting within all namespaces.
               */
              endGroup() {
                this.macros.endGroup();
              }
              /**
               * Ends all currently nested groups (if any), restoring values before the
               * groups began.  Useful in case of an error in the middle of parsing.
               */
              endGroups() {
                this.macros.endGroups();
              }
              /**
               * Returns the topmost token on the stack, without expanding it.
               * Similar in behavior to TeX's `\futurelet`.
               */
              future() {
                if (this.stack.length === 0) {
                  this.pushToken(this.lexer.lex());
                }
                return this.stack[this.stack.length - 1];
              }
              /**
               * Remove and return the next unexpanded token.
               */
              popToken() {
                this.future();
                return this.stack.pop();
              }
              /**
               * Add a given token to the token stack.  In particular, this get be used
               * to put back a token returned from one of the other methods.
               */
              pushToken(token) {
                this.stack.push(token);
              }
              /**
               * Append an array of tokens to the token stack.
               */
              pushTokens(tokens) {
                this.stack.push(...tokens);
              }
              /**
               * Find an macro argument without expanding tokens and append the array of
               * tokens to the token stack. Uses Token as a container for the result.
               */
              scanArgument(isOptional) {
                let start2;
                let end2;
                let tokens;
                if (isOptional) {
                  this.consumeSpaces();
                  if (this.future().text !== "[") {
                    return null;
                  }
                  start2 = this.popToken();
                  ({
                    tokens,
                    end: end2
                  } = this.consumeArg(["]"]));
                } else {
                  ({
                    tokens,
                    start: start2,
                    end: end2
                  } = this.consumeArg());
                }
                this.pushToken(new Token2("EOF", end2.loc));
                this.pushTokens(tokens);
                return new Token2("", SourceLocation.range(start2, end2));
              }
              /**
               * Consume all following space tokens, without expansion.
               */
              consumeSpaces() {
                for (; ; ) {
                  const token = this.future();
                  if (token.text === " ") {
                    this.stack.pop();
                  } else {
                    break;
                  }
                }
              }
              /**
               * Consume an argument from the token stream, and return the resulting array
               * of tokens and start/end token.
               */
              consumeArg(delims2) {
                const tokens = [];
                const isDelimited = delims2 && delims2.length > 0;
                if (!isDelimited) {
                  this.consumeSpaces();
                }
                const start2 = this.future();
                let tok;
                let depth = 0;
                let match2 = 0;
                do {
                  tok = this.popToken();
                  tokens.push(tok);
                  if (tok.text === "{") {
                    ++depth;
                  } else if (tok.text === "}") {
                    --depth;
                    if (depth === -1) {
                      throw new src_ParseError("Extra }", tok);
                    }
                  } else if (tok.text === "EOF") {
                    throw new src_ParseError("Unexpected end of input in a macro argument, expected '" + (delims2 && isDelimited ? delims2[match2] : "}") + "'", tok);
                  }
                  if (delims2 && isDelimited) {
                    if ((depth === 0 || depth === 1 && delims2[match2] === "{") && tok.text === delims2[match2]) {
                      ++match2;
                      if (match2 === delims2.length) {
                        tokens.splice(-match2, match2);
                        break;
                      }
                    } else {
                      match2 = 0;
                    }
                  }
                } while (depth !== 0 || isDelimited);
                if (start2.text === "{" && tokens[tokens.length - 1].text === "}") {
                  tokens.pop();
                  tokens.shift();
                }
                tokens.reverse();
                return {
                  tokens,
                  start: start2,
                  end: tok
                };
              }
              /**
               * Consume the specified number of (delimited) arguments from the token
               * stream and return the resulting array of arguments.
               */
              consumeArgs(numArgs, delimiters2) {
                if (delimiters2) {
                  if (delimiters2.length !== numArgs + 1) {
                    throw new src_ParseError("The length of delimiters doesn't match the number of args!");
                  }
                  const delims2 = delimiters2[0];
                  for (let i = 0; i < delims2.length; i++) {
                    const tok = this.popToken();
                    if (delims2[i] !== tok.text) {
                      throw new src_ParseError("Use of the macro doesn't match its definition", tok);
                    }
                  }
                }
                const args = [];
                for (let i = 0; i < numArgs; i++) {
                  args.push(this.consumeArg(delimiters2 && delimiters2[i + 1]).tokens);
                }
                return args;
              }
              /**
               * Increment `expansionCount` by the specified amount.
               * Throw an error if it exceeds `maxExpand`.
               */
              countExpansion(amount) {
                this.expansionCount += amount;
                if (this.expansionCount > this.settings.maxExpand) {
                  throw new src_ParseError("Too many expansions: infinite loop or need to increase maxExpand setting");
                }
              }
              /**
               * Expand the next token only once if possible.
               *
               * If the token is expanded, the resulting tokens will be pushed onto
               * the stack in reverse order, and the number of such tokens will be
               * returned.  This number might be zero or positive.
               *
               * If not, the return value is `false`, and the next token remains at the
               * top of the stack.
               *
               * In either case, the next token will be on the top of the stack,
               * or the stack will be empty (in case of empty expansion
               * and no other tokens).
               *
               * Used to implement `expandAfterFuture` and `expandNextToken`.
               *
               * If expandableOnly, only expandable tokens are expanded and
               * an undefined control sequence results in an error.
               */
              expandOnce(expandableOnly) {
                const topToken = this.popToken();
                const name2 = topToken.text;
                const expansion = !topToken.noexpand ? this._getExpansion(name2) : null;
                if (expansion == null || expandableOnly && expansion.unexpandable) {
                  if (expandableOnly && expansion == null && name2[0] === "\\" && !this.isDefined(name2)) {
                    throw new src_ParseError("Undefined control sequence: " + name2);
                  }
                  this.pushToken(topToken);
                  return false;
                }
                this.countExpansion(1);
                let tokens = expansion.tokens;
                const args = this.consumeArgs(expansion.numArgs, expansion.delimiters);
                if (expansion.numArgs) {
                  tokens = tokens.slice();
                  for (let i = tokens.length - 1; i >= 0; --i) {
                    let tok = tokens[i];
                    if (tok.text === "#") {
                      if (i === 0) {
                        throw new src_ParseError("Incomplete placeholder at end of macro body", tok);
                      }
                      tok = tokens[--i];
                      if (tok.text === "#") {
                        tokens.splice(i + 1, 1);
                      } else if (/^[1-9]$/.test(tok.text)) {
                        tokens.splice(i, 2, ...args[+tok.text - 1]);
                      } else {
                        throw new src_ParseError("Not a valid argument number", tok);
                      }
                    }
                  }
                }
                this.pushTokens(tokens);
                return tokens.length;
              }
              /**
               * Expand the next token only once (if possible), and return the resulting
               * top token on the stack (without removing anything from the stack).
               * Similar in behavior to TeX's `\expandafter\futurelet`.
               * Equivalent to expandOnce() followed by future().
               */
              expandAfterFuture() {
                this.expandOnce();
                return this.future();
              }
              /**
               * Recursively expand first token, then return first non-expandable token.
               */
              expandNextToken() {
                for (; ; ) {
                  if (this.expandOnce() === false) {
                    const token = this.stack.pop();
                    if (token.treatAsRelax) {
                      token.text = "\\relax";
                    }
                    return token;
                  }
                }
                throw new Error();
              }
              /**
               * Fully expand the given macro name and return the resulting list of
               * tokens, or return `undefined` if no such macro is defined.
               */
              expandMacro(name2) {
                return this.macros.has(name2) ? this.expandTokens([new Token2(name2)]) : void 0;
              }
              /**
               * Fully expand the given token stream and return the resulting list of
               * tokens.  Note that the input tokens are in reverse order, but the
               * output tokens are in forward order.
               */
              expandTokens(tokens) {
                const output = [];
                const oldStackLength = this.stack.length;
                this.pushTokens(tokens);
                while (this.stack.length > oldStackLength) {
                  if (this.expandOnce(true) === false) {
                    const token = this.stack.pop();
                    if (token.treatAsRelax) {
                      token.noexpand = false;
                      token.treatAsRelax = false;
                    }
                    output.push(token);
                  }
                }
                this.countExpansion(output.length);
                return output;
              }
              /**
               * Fully expand the given macro name and return the result as a string,
               * or return `undefined` if no such macro is defined.
               */
              expandMacroAsText(name2) {
                const tokens = this.expandMacro(name2);
                if (tokens) {
                  return tokens.map((token) => token.text).join("");
                } else {
                  return tokens;
                }
              }
              /**
               * Returns the expanded macro as a reversed array of tokens and a macro
               * argument count.  Or returns `null` if no such macro.
               */
              _getExpansion(name2) {
                const definition = this.macros.get(name2);
                if (definition == null) {
                  return definition;
                }
                if (name2.length === 1) {
                  const catcode = this.lexer.catcodes[name2];
                  if (catcode != null && catcode !== 13) {
                    return;
                  }
                }
                const expansion = typeof definition === "function" ? definition(this) : definition;
                if (typeof expansion === "string") {
                  let numArgs = 0;
                  if (expansion.indexOf("#") !== -1) {
                    const stripped = expansion.replace(/##/g, "");
                    while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
                      ++numArgs;
                    }
                  }
                  const bodyLexer = new Lexer2(expansion, this.settings);
                  const tokens = [];
                  let tok = bodyLexer.lex();
                  while (tok.text !== "EOF") {
                    tokens.push(tok);
                    tok = bodyLexer.lex();
                  }
                  tokens.reverse();
                  const expanded = {
                    tokens,
                    numArgs
                  };
                  return expanded;
                }
                return expansion;
              }
              /**
               * Determine whether a command is currently "defined" (has some
               * functionality), meaning that it's a macro (in the current group),
               * a function, a symbol, or one of the special commands listed in
               * `implicitCommands`.
               */
              isDefined(name2) {
                return this.macros.has(name2) || src_functions.hasOwnProperty(name2) || src_symbols.math.hasOwnProperty(name2) || src_symbols.text.hasOwnProperty(name2) || implicitCommands.hasOwnProperty(name2);
              }
              /**
               * Determine whether a command is expandable.
               */
              isExpandable(name2) {
                const macro = this.macros.get(name2);
                return macro != null ? typeof macro === "string" || typeof macro === "function" || !macro.unexpandable : src_functions.hasOwnProperty(name2) && !src_functions[name2].primitive;
              }
            }
            ;
            const unicodeSubRegEx = /^[₊₋₌₍₎₀₁₂₃₄₅₆₇₈₉ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ]/;
            const uSubsAndSups = Object.freeze({
              "\u208A": "+",
              "\u208B": "-",
              "\u208C": "=",
              "\u208D": "(",
              "\u208E": ")",
              "\u2080": "0",
              "\u2081": "1",
              "\u2082": "2",
              "\u2083": "3",
              "\u2084": "4",
              "\u2085": "5",
              "\u2086": "6",
              "\u2087": "7",
              "\u2088": "8",
              "\u2089": "9",
              "\u2090": "a",
              "\u2091": "e",
              "\u2095": "h",
              "\u1D62": "i",
              "\u2C7C": "j",
              "\u2096": "k",
              "\u2097": "l",
              "\u2098": "m",
              "\u2099": "n",
              "\u2092": "o",
              "\u209A": "p",
              "\u1D63": "r",
              "\u209B": "s",
              "\u209C": "t",
              "\u1D64": "u",
              "\u1D65": "v",
              "\u2093": "x",
              "\u1D66": "\u03B2",
              "\u1D67": "\u03B3",
              "\u1D68": "\u03C1",
              "\u1D69": "\u03D5",
              "\u1D6A": "\u03C7",
              "\u207A": "+",
              "\u207B": "-",
              "\u207C": "=",
              "\u207D": "(",
              "\u207E": ")",
              "\u2070": "0",
              "\xB9": "1",
              "\xB2": "2",
              "\xB3": "3",
              "\u2074": "4",
              "\u2075": "5",
              "\u2076": "6",
              "\u2077": "7",
              "\u2078": "8",
              "\u2079": "9",
              "\u1D2C": "A",
              "\u1D2E": "B",
              "\u1D30": "D",
              "\u1D31": "E",
              "\u1D33": "G",
              "\u1D34": "H",
              "\u1D35": "I",
              "\u1D36": "J",
              "\u1D37": "K",
              "\u1D38": "L",
              "\u1D39": "M",
              "\u1D3A": "N",
              "\u1D3C": "O",
              "\u1D3E": "P",
              "\u1D3F": "R",
              "\u1D40": "T",
              "\u1D41": "U",
              "\u2C7D": "V",
              "\u1D42": "W",
              "\u1D43": "a",
              "\u1D47": "b",
              "\u1D9C": "c",
              "\u1D48": "d",
              "\u1D49": "e",
              "\u1DA0": "f",
              "\u1D4D": "g",
              "\u02B0": "h",
              "\u2071": "i",
              "\u02B2": "j",
              "\u1D4F": "k",
              "\u02E1": "l",
              "\u1D50": "m",
              "\u207F": "n",
              "\u1D52": "o",
              "\u1D56": "p",
              "\u02B3": "r",
              "\u02E2": "s",
              "\u1D57": "t",
              "\u1D58": "u",
              "\u1D5B": "v",
              "\u02B7": "w",
              "\u02E3": "x",
              "\u02B8": "y",
              "\u1DBB": "z",
              "\u1D5D": "\u03B2",
              "\u1D5E": "\u03B3",
              "\u1D5F": "\u03B4",
              "\u1D60": "\u03D5",
              "\u1D61": "\u03C7",
              "\u1DBF": "\u03B8"
            });
            ;
            const unicodeAccents = {
              "\u0301": {
                "text": "\\'",
                "math": "\\acute"
              },
              "\u0300": {
                "text": "\\`",
                "math": "\\grave"
              },
              "\u0308": {
                "text": '\\"',
                "math": "\\ddot"
              },
              "\u0303": {
                "text": "\\~",
                "math": "\\tilde"
              },
              "\u0304": {
                "text": "\\=",
                "math": "\\bar"
              },
              "\u0306": {
                "text": "\\u",
                "math": "\\breve"
              },
              "\u030C": {
                "text": "\\v",
                "math": "\\check"
              },
              "\u0302": {
                "text": "\\^",
                "math": "\\hat"
              },
              "\u0307": {
                "text": "\\.",
                "math": "\\dot"
              },
              "\u030A": {
                "text": "\\r",
                "math": "\\mathring"
              },
              "\u030B": {
                "text": "\\H"
              },
              "\u0327": {
                "text": "\\c"
              }
            };
            const unicodeSymbols = {
              "\xE1": "a\u0301",
              "\xE0": "a\u0300",
              "\xE4": "a\u0308",
              "\u01DF": "a\u0308\u0304",
              "\xE3": "a\u0303",
              "\u0101": "a\u0304",
              "\u0103": "a\u0306",
              "\u1EAF": "a\u0306\u0301",
              "\u1EB1": "a\u0306\u0300",
              "\u1EB5": "a\u0306\u0303",
              "\u01CE": "a\u030C",
              "\xE2": "a\u0302",
              "\u1EA5": "a\u0302\u0301",
              "\u1EA7": "a\u0302\u0300",
              "\u1EAB": "a\u0302\u0303",
              "\u0227": "a\u0307",
              "\u01E1": "a\u0307\u0304",
              "\xE5": "a\u030A",
              "\u01FB": "a\u030A\u0301",
              "\u1E03": "b\u0307",
              "\u0107": "c\u0301",
              "\u1E09": "c\u0327\u0301",
              "\u010D": "c\u030C",
              "\u0109": "c\u0302",
              "\u010B": "c\u0307",
              "\xE7": "c\u0327",
              "\u010F": "d\u030C",
              "\u1E0B": "d\u0307",
              "\u1E11": "d\u0327",
              "\xE9": "e\u0301",
              "\xE8": "e\u0300",
              "\xEB": "e\u0308",
              "\u1EBD": "e\u0303",
              "\u0113": "e\u0304",
              "\u1E17": "e\u0304\u0301",
              "\u1E15": "e\u0304\u0300",
              "\u0115": "e\u0306",
              "\u1E1D": "e\u0327\u0306",
              "\u011B": "e\u030C",
              "\xEA": "e\u0302",
              "\u1EBF": "e\u0302\u0301",
              "\u1EC1": "e\u0302\u0300",
              "\u1EC5": "e\u0302\u0303",
              "\u0117": "e\u0307",
              "\u0229": "e\u0327",
              "\u1E1F": "f\u0307",
              "\u01F5": "g\u0301",
              "\u1E21": "g\u0304",
              "\u011F": "g\u0306",
              "\u01E7": "g\u030C",
              "\u011D": "g\u0302",
              "\u0121": "g\u0307",
              "\u0123": "g\u0327",
              "\u1E27": "h\u0308",
              "\u021F": "h\u030C",
              "\u0125": "h\u0302",
              "\u1E23": "h\u0307",
              "\u1E29": "h\u0327",
              "\xED": "i\u0301",
              "\xEC": "i\u0300",
              "\xEF": "i\u0308",
              "\u1E2F": "i\u0308\u0301",
              "\u0129": "i\u0303",
              "\u012B": "i\u0304",
              "\u012D": "i\u0306",
              "\u01D0": "i\u030C",
              "\xEE": "i\u0302",
              "\u01F0": "j\u030C",
              "\u0135": "j\u0302",
              "\u1E31": "k\u0301",
              "\u01E9": "k\u030C",
              "\u0137": "k\u0327",
              "\u013A": "l\u0301",
              "\u013E": "l\u030C",
              "\u013C": "l\u0327",
              "\u1E3F": "m\u0301",
              "\u1E41": "m\u0307",
              "\u0144": "n\u0301",
              "\u01F9": "n\u0300",
              "\xF1": "n\u0303",
              "\u0148": "n\u030C",
              "\u1E45": "n\u0307",
              "\u0146": "n\u0327",
              "\xF3": "o\u0301",
              "\xF2": "o\u0300",
              "\xF6": "o\u0308",
              "\u022B": "o\u0308\u0304",
              "\xF5": "o\u0303",
              "\u1E4D": "o\u0303\u0301",
              "\u1E4F": "o\u0303\u0308",
              "\u022D": "o\u0303\u0304",
              "\u014D": "o\u0304",
              "\u1E53": "o\u0304\u0301",
              "\u1E51": "o\u0304\u0300",
              "\u014F": "o\u0306",
              "\u01D2": "o\u030C",
              "\xF4": "o\u0302",
              "\u1ED1": "o\u0302\u0301",
              "\u1ED3": "o\u0302\u0300",
              "\u1ED7": "o\u0302\u0303",
              "\u022F": "o\u0307",
              "\u0231": "o\u0307\u0304",
              "\u0151": "o\u030B",
              "\u1E55": "p\u0301",
              "\u1E57": "p\u0307",
              "\u0155": "r\u0301",
              "\u0159": "r\u030C",
              "\u1E59": "r\u0307",
              "\u0157": "r\u0327",
              "\u015B": "s\u0301",
              "\u1E65": "s\u0301\u0307",
              "\u0161": "s\u030C",
              "\u1E67": "s\u030C\u0307",
              "\u015D": "s\u0302",
              "\u1E61": "s\u0307",
              "\u015F": "s\u0327",
              "\u1E97": "t\u0308",
              "\u0165": "t\u030C",
              "\u1E6B": "t\u0307",
              "\u0163": "t\u0327",
              "\xFA": "u\u0301",
              "\xF9": "u\u0300",
              "\xFC": "u\u0308",
              "\u01D8": "u\u0308\u0301",
              "\u01DC": "u\u0308\u0300",
              "\u01D6": "u\u0308\u0304",
              "\u01DA": "u\u0308\u030C",
              "\u0169": "u\u0303",
              "\u1E79": "u\u0303\u0301",
              "\u016B": "u\u0304",
              "\u1E7B": "u\u0304\u0308",
              "\u016D": "u\u0306",
              "\u01D4": "u\u030C",
              "\xFB": "u\u0302",
              "\u016F": "u\u030A",
              "\u0171": "u\u030B",
              "\u1E7D": "v\u0303",
              "\u1E83": "w\u0301",
              "\u1E81": "w\u0300",
              "\u1E85": "w\u0308",
              "\u0175": "w\u0302",
              "\u1E87": "w\u0307",
              "\u1E98": "w\u030A",
              "\u1E8D": "x\u0308",
              "\u1E8B": "x\u0307",
              "\xFD": "y\u0301",
              "\u1EF3": "y\u0300",
              "\xFF": "y\u0308",
              "\u1EF9": "y\u0303",
              "\u0233": "y\u0304",
              "\u0177": "y\u0302",
              "\u1E8F": "y\u0307",
              "\u1E99": "y\u030A",
              "\u017A": "z\u0301",
              "\u017E": "z\u030C",
              "\u1E91": "z\u0302",
              "\u017C": "z\u0307",
              "\xC1": "A\u0301",
              "\xC0": "A\u0300",
              "\xC4": "A\u0308",
              "\u01DE": "A\u0308\u0304",
              "\xC3": "A\u0303",
              "\u0100": "A\u0304",
              "\u0102": "A\u0306",
              "\u1EAE": "A\u0306\u0301",
              "\u1EB0": "A\u0306\u0300",
              "\u1EB4": "A\u0306\u0303",
              "\u01CD": "A\u030C",
              "\xC2": "A\u0302",
              "\u1EA4": "A\u0302\u0301",
              "\u1EA6": "A\u0302\u0300",
              "\u1EAA": "A\u0302\u0303",
              "\u0226": "A\u0307",
              "\u01E0": "A\u0307\u0304",
              "\xC5": "A\u030A",
              "\u01FA": "A\u030A\u0301",
              "\u1E02": "B\u0307",
              "\u0106": "C\u0301",
              "\u1E08": "C\u0327\u0301",
              "\u010C": "C\u030C",
              "\u0108": "C\u0302",
              "\u010A": "C\u0307",
              "\xC7": "C\u0327",
              "\u010E": "D\u030C",
              "\u1E0A": "D\u0307",
              "\u1E10": "D\u0327",
              "\xC9": "E\u0301",
              "\xC8": "E\u0300",
              "\xCB": "E\u0308",
              "\u1EBC": "E\u0303",
              "\u0112": "E\u0304",
              "\u1E16": "E\u0304\u0301",
              "\u1E14": "E\u0304\u0300",
              "\u0114": "E\u0306",
              "\u1E1C": "E\u0327\u0306",
              "\u011A": "E\u030C",
              "\xCA": "E\u0302",
              "\u1EBE": "E\u0302\u0301",
              "\u1EC0": "E\u0302\u0300",
              "\u1EC4": "E\u0302\u0303",
              "\u0116": "E\u0307",
              "\u0228": "E\u0327",
              "\u1E1E": "F\u0307",
              "\u01F4": "G\u0301",
              "\u1E20": "G\u0304",
              "\u011E": "G\u0306",
              "\u01E6": "G\u030C",
              "\u011C": "G\u0302",
              "\u0120": "G\u0307",
              "\u0122": "G\u0327",
              "\u1E26": "H\u0308",
              "\u021E": "H\u030C",
              "\u0124": "H\u0302",
              "\u1E22": "H\u0307",
              "\u1E28": "H\u0327",
              "\xCD": "I\u0301",
              "\xCC": "I\u0300",
              "\xCF": "I\u0308",
              "\u1E2E": "I\u0308\u0301",
              "\u0128": "I\u0303",
              "\u012A": "I\u0304",
              "\u012C": "I\u0306",
              "\u01CF": "I\u030C",
              "\xCE": "I\u0302",
              "\u0130": "I\u0307",
              "\u0134": "J\u0302",
              "\u1E30": "K\u0301",
              "\u01E8": "K\u030C",
              "\u0136": "K\u0327",
              "\u0139": "L\u0301",
              "\u013D": "L\u030C",
              "\u013B": "L\u0327",
              "\u1E3E": "M\u0301",
              "\u1E40": "M\u0307",
              "\u0143": "N\u0301",
              "\u01F8": "N\u0300",
              "\xD1": "N\u0303",
              "\u0147": "N\u030C",
              "\u1E44": "N\u0307",
              "\u0145": "N\u0327",
              "\xD3": "O\u0301",
              "\xD2": "O\u0300",
              "\xD6": "O\u0308",
              "\u022A": "O\u0308\u0304",
              "\xD5": "O\u0303",
              "\u1E4C": "O\u0303\u0301",
              "\u1E4E": "O\u0303\u0308",
              "\u022C": "O\u0303\u0304",
              "\u014C": "O\u0304",
              "\u1E52": "O\u0304\u0301",
              "\u1E50": "O\u0304\u0300",
              "\u014E": "O\u0306",
              "\u01D1": "O\u030C",
              "\xD4": "O\u0302",
              "\u1ED0": "O\u0302\u0301",
              "\u1ED2": "O\u0302\u0300",
              "\u1ED6": "O\u0302\u0303",
              "\u022E": "O\u0307",
              "\u0230": "O\u0307\u0304",
              "\u0150": "O\u030B",
              "\u1E54": "P\u0301",
              "\u1E56": "P\u0307",
              "\u0154": "R\u0301",
              "\u0158": "R\u030C",
              "\u1E58": "R\u0307",
              "\u0156": "R\u0327",
              "\u015A": "S\u0301",
              "\u1E64": "S\u0301\u0307",
              "\u0160": "S\u030C",
              "\u1E66": "S\u030C\u0307",
              "\u015C": "S\u0302",
              "\u1E60": "S\u0307",
              "\u015E": "S\u0327",
              "\u0164": "T\u030C",
              "\u1E6A": "T\u0307",
              "\u0162": "T\u0327",
              "\xDA": "U\u0301",
              "\xD9": "U\u0300",
              "\xDC": "U\u0308",
              "\u01D7": "U\u0308\u0301",
              "\u01DB": "U\u0308\u0300",
              "\u01D5": "U\u0308\u0304",
              "\u01D9": "U\u0308\u030C",
              "\u0168": "U\u0303",
              "\u1E78": "U\u0303\u0301",
              "\u016A": "U\u0304",
              "\u1E7A": "U\u0304\u0308",
              "\u016C": "U\u0306",
              "\u01D3": "U\u030C",
              "\xDB": "U\u0302",
              "\u016E": "U\u030A",
              "\u0170": "U\u030B",
              "\u1E7C": "V\u0303",
              "\u1E82": "W\u0301",
              "\u1E80": "W\u0300",
              "\u1E84": "W\u0308",
              "\u0174": "W\u0302",
              "\u1E86": "W\u0307",
              "\u1E8C": "X\u0308",
              "\u1E8A": "X\u0307",
              "\xDD": "Y\u0301",
              "\u1EF2": "Y\u0300",
              "\u0178": "Y\u0308",
              "\u1EF8": "Y\u0303",
              "\u0232": "Y\u0304",
              "\u0176": "Y\u0302",
              "\u1E8E": "Y\u0307",
              "\u0179": "Z\u0301",
              "\u017D": "Z\u030C",
              "\u1E90": "Z\u0302",
              "\u017B": "Z\u0307",
              "\u03AC": "\u03B1\u0301",
              "\u1F70": "\u03B1\u0300",
              "\u1FB1": "\u03B1\u0304",
              "\u1FB0": "\u03B1\u0306",
              "\u03AD": "\u03B5\u0301",
              "\u1F72": "\u03B5\u0300",
              "\u03AE": "\u03B7\u0301",
              "\u1F74": "\u03B7\u0300",
              "\u03AF": "\u03B9\u0301",
              "\u1F76": "\u03B9\u0300",
              "\u03CA": "\u03B9\u0308",
              "\u0390": "\u03B9\u0308\u0301",
              "\u1FD2": "\u03B9\u0308\u0300",
              "\u1FD1": "\u03B9\u0304",
              "\u1FD0": "\u03B9\u0306",
              "\u03CC": "\u03BF\u0301",
              "\u1F78": "\u03BF\u0300",
              "\u03CD": "\u03C5\u0301",
              "\u1F7A": "\u03C5\u0300",
              "\u03CB": "\u03C5\u0308",
              "\u03B0": "\u03C5\u0308\u0301",
              "\u1FE2": "\u03C5\u0308\u0300",
              "\u1FE1": "\u03C5\u0304",
              "\u1FE0": "\u03C5\u0306",
              "\u03CE": "\u03C9\u0301",
              "\u1F7C": "\u03C9\u0300",
              "\u038E": "\u03A5\u0301",
              "\u1FEA": "\u03A5\u0300",
              "\u03AB": "\u03A5\u0308",
              "\u1FE9": "\u03A5\u0304",
              "\u1FE8": "\u03A5\u0306",
              "\u038F": "\u03A9\u0301",
              "\u1FFA": "\u03A9\u0300"
            };
            class Parser3 {
              constructor(input, settings) {
                this.mode = void 0;
                this.gullet = void 0;
                this.settings = void 0;
                this.leftrightDepth = void 0;
                this.nextToken = void 0;
                this.mode = "math";
                this.gullet = new MacroExpander(input, settings, this.mode);
                this.settings = settings;
                this.leftrightDepth = 0;
              }
              /**
               * Checks a result to make sure it has the right type, and throws an
               * appropriate error otherwise.
               */
              expect(text3, consume) {
                if (consume === void 0) {
                  consume = true;
                }
                if (this.fetch().text !== text3) {
                  throw new src_ParseError("Expected '" + text3 + "', got '" + this.fetch().text + "'", this.fetch());
                }
                if (consume) {
                  this.consume();
                }
              }
              /**
               * Discards the current lookahead token, considering it consumed.
               */
              consume() {
                this.nextToken = null;
              }
              /**
               * Return the current lookahead token, or if there isn't one (at the
               * beginning, or if the previous lookahead token was consume()d),
               * fetch the next token as the new lookahead token and return it.
               */
              fetch() {
                if (this.nextToken == null) {
                  this.nextToken = this.gullet.expandNextToken();
                }
                return this.nextToken;
              }
              /**
               * Switches between "text" and "math" modes.
               */
              switchMode(newMode) {
                this.mode = newMode;
                this.gullet.switchMode(newMode);
              }
              /**
               * Main parsing function, which parses an entire input.
               */
              parse() {
                if (!this.settings.globalGroup) {
                  this.gullet.beginGroup();
                }
                if (this.settings.colorIsTextColor) {
                  this.gullet.macros.set("\\color", "\\textcolor");
                }
                try {
                  const parse3 = this.parseExpression(false);
                  this.expect("EOF");
                  if (!this.settings.globalGroup) {
                    this.gullet.endGroup();
                  }
                  return parse3;
                } finally {
                  this.gullet.endGroups();
                }
              }
              /**
               * Fully parse a separate sequence of tokens as a separate job.
               * Tokens should be specified in reverse order, as in a MacroDefinition.
               */
              subparse(tokens) {
                const oldToken = this.nextToken;
                this.consume();
                this.gullet.pushToken(new Token2("}"));
                this.gullet.pushTokens(tokens);
                const parse3 = this.parseExpression(false);
                this.expect("}");
                this.nextToken = oldToken;
                return parse3;
              }
              /**
               * Parses an "expression", which is a list of atoms.
               *
               * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
               *                 happens when functions have higher precedence han infix
               *                 nodes in implicit parses.
               *
               * `breakOnTokenText`: The text of the token that the expression should end
               *                     with, or `null` if something else should end the
               *                     expression.
               */
              parseExpression(breakOnInfix, breakOnTokenText) {
                const body = [];
                while (true) {
                  if (this.mode === "math") {
                    this.consumeSpaces();
                  }
                  const lex = this.fetch();
                  if (Parser3.endOfExpression.indexOf(lex.text) !== -1) {
                    break;
                  }
                  if (breakOnTokenText && lex.text === breakOnTokenText) {
                    break;
                  }
                  if (breakOnInfix && src_functions[lex.text] && src_functions[lex.text].infix) {
                    break;
                  }
                  const atom = this.parseAtom(breakOnTokenText);
                  if (!atom) {
                    break;
                  } else if (atom.type === "internal") {
                    continue;
                  }
                  body.push(atom);
                }
                if (this.mode === "text") {
                  this.formLigatures(body);
                }
                return this.handleInfixNodes(body);
              }
              /**
               * Rewrites infix operators such as \over with corresponding commands such
               * as \frac.
               *
               * There can only be one infix operator per group.  If there's more than one
               * then the expression is ambiguous.  This can be resolved by adding {}.
               */
              handleInfixNodes(body) {
                let overIndex = -1;
                let funcName;
                for (let i = 0; i < body.length; i++) {
                  if (body[i].type === "infix") {
                    if (overIndex !== -1) {
                      throw new src_ParseError("only one infix operator per group", body[i].token);
                    }
                    overIndex = i;
                    funcName = body[i].replaceWith;
                  }
                }
                if (overIndex !== -1 && funcName) {
                  let numerNode;
                  let denomNode;
                  const numerBody = body.slice(0, overIndex);
                  const denomBody = body.slice(overIndex + 1);
                  if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
                    numerNode = numerBody[0];
                  } else {
                    numerNode = {
                      type: "ordgroup",
                      mode: this.mode,
                      body: numerBody
                    };
                  }
                  if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
                    denomNode = denomBody[0];
                  } else {
                    denomNode = {
                      type: "ordgroup",
                      mode: this.mode,
                      body: denomBody
                    };
                  }
                  let node;
                  if (funcName === "\\\\abovefrac") {
                    node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
                  } else {
                    node = this.callFunction(funcName, [numerNode, denomNode], []);
                  }
                  return [node];
                } else {
                  return body;
                }
              }
              /**
               * Handle a subscript or superscript with nice errors.
               */
              handleSupSubscript(name2) {
                const symbolToken = this.fetch();
                const symbol = symbolToken.text;
                this.consume();
                this.consumeSpaces();
                let group;
                do {
                  var _group;
                  group = this.parseGroup(name2);
                } while (((_group = group) == null ? void 0 : _group.type) === "internal");
                if (!group) {
                  throw new src_ParseError("Expected group after '" + symbol + "'", symbolToken);
                }
                return group;
              }
              /**
               * Converts the textual input of an unsupported command into a text node
               * contained within a color node whose color is determined by errorColor
               */
              formatUnsupportedCmd(text3) {
                const textordArray = [];
                for (let i = 0; i < text3.length; i++) {
                  textordArray.push({
                    type: "textord",
                    mode: "text",
                    text: text3[i]
                  });
                }
                const textNode = {
                  type: "text",
                  mode: this.mode,
                  body: textordArray
                };
                const colorNode = {
                  type: "color",
                  mode: this.mode,
                  color: this.settings.errorColor,
                  body: [textNode]
                };
                return colorNode;
              }
              /**
               * Parses a group with optional super/subscripts.
               */
              parseAtom(breakOnTokenText) {
                const base2 = this.parseGroup("atom", breakOnTokenText);
                if ((base2 == null ? void 0 : base2.type) === "internal") {
                  return base2;
                }
                if (this.mode === "text") {
                  return base2;
                }
                let superscript2;
                let subscript2;
                while (true) {
                  this.consumeSpaces();
                  const lex = this.fetch();
                  if (lex.text === "\\limits" || lex.text === "\\nolimits") {
                    if (base2 && base2.type === "op") {
                      const limits = lex.text === "\\limits";
                      base2.limits = limits;
                      base2.alwaysHandleSupSub = true;
                    } else if (base2 && base2.type === "operatorname") {
                      if (base2.alwaysHandleSupSub) {
                        base2.limits = lex.text === "\\limits";
                      }
                    } else {
                      throw new src_ParseError("Limit controls must follow a math operator", lex);
                    }
                    this.consume();
                  } else if (lex.text === "^") {
                    if (superscript2) {
                      throw new src_ParseError("Double superscript", lex);
                    }
                    superscript2 = this.handleSupSubscript("superscript");
                  } else if (lex.text === "_") {
                    if (subscript2) {
                      throw new src_ParseError("Double subscript", lex);
                    }
                    subscript2 = this.handleSupSubscript("subscript");
                  } else if (lex.text === "'") {
                    if (superscript2) {
                      throw new src_ParseError("Double superscript", lex);
                    }
                    const prime = {
                      type: "textord",
                      mode: this.mode,
                      text: "\\prime"
                    };
                    const primes = [prime];
                    this.consume();
                    while (this.fetch().text === "'") {
                      primes.push(prime);
                      this.consume();
                    }
                    if (this.fetch().text === "^") {
                      primes.push(this.handleSupSubscript("superscript"));
                    }
                    superscript2 = {
                      type: "ordgroup",
                      mode: this.mode,
                      body: primes
                    };
                  } else if (uSubsAndSups[lex.text]) {
                    const isSub = unicodeSubRegEx.test(lex.text);
                    const subsupTokens = [];
                    subsupTokens.push(new Token2(uSubsAndSups[lex.text]));
                    this.consume();
                    while (true) {
                      const token = this.fetch().text;
                      if (!uSubsAndSups[token]) {
                        break;
                      }
                      if (unicodeSubRegEx.test(token) !== isSub) {
                        break;
                      }
                      subsupTokens.unshift(new Token2(uSubsAndSups[token]));
                      this.consume();
                    }
                    const body = this.subparse(subsupTokens);
                    if (isSub) {
                      subscript2 = {
                        type: "ordgroup",
                        mode: "math",
                        body
                      };
                    } else {
                      superscript2 = {
                        type: "ordgroup",
                        mode: "math",
                        body
                      };
                    }
                  } else {
                    break;
                  }
                }
                if (superscript2 || subscript2) {
                  return {
                    type: "supsub",
                    mode: this.mode,
                    base: base2,
                    sup: superscript2,
                    sub: subscript2
                  };
                } else {
                  return base2;
                }
              }
              /**
               * Parses an entire function, including its base and all of its arguments.
               */
              parseFunction(breakOnTokenText, name2) {
                const token = this.fetch();
                const func = token.text;
                const funcData = src_functions[func];
                if (!funcData) {
                  return null;
                }
                this.consume();
                if (name2 && name2 !== "atom" && !funcData.allowedInArgument) {
                  throw new src_ParseError("Got function '" + func + "' with no arguments" + (name2 ? " as " + name2 : ""), token);
                } else if (this.mode === "text" && !funcData.allowedInText) {
                  throw new src_ParseError("Can't use function '" + func + "' in text mode", token);
                } else if (this.mode === "math" && funcData.allowedInMath === false) {
                  throw new src_ParseError("Can't use function '" + func + "' in math mode", token);
                }
                const {
                  args,
                  optArgs
                } = this.parseArguments(func, funcData);
                return this.callFunction(func, args, optArgs, token, breakOnTokenText);
              }
              /**
               * Call a function handler with a suitable context and arguments.
               */
              callFunction(name2, args, optArgs, token, breakOnTokenText) {
                const context = {
                  funcName: name2,
                  parser: this,
                  token,
                  breakOnTokenText
                };
                const func = src_functions[name2];
                if (func && func.handler) {
                  return func.handler(context, args, optArgs);
                } else {
                  throw new src_ParseError("No function handler for " + name2);
                }
              }
              /**
               * Parses the arguments of a function or environment
               */
              parseArguments(func, funcData) {
                const totalArgs = funcData.numArgs + funcData.numOptionalArgs;
                if (totalArgs === 0) {
                  return {
                    args: [],
                    optArgs: []
                  };
                }
                const args = [];
                const optArgs = [];
                for (let i = 0; i < totalArgs; i++) {
                  let argType = funcData.argTypes && funcData.argTypes[i];
                  const isOptional = i < funcData.numOptionalArgs;
                  if (funcData.primitive && argType == null || // \sqrt expands into primitive if optional argument doesn't exist
                  funcData.type === "sqrt" && i === 1 && optArgs[0] == null) {
                    argType = "primitive";
                  }
                  const arg = this.parseGroupOfType("argument to '" + func + "'", argType, isOptional);
                  if (isOptional) {
                    optArgs.push(arg);
                  } else if (arg != null) {
                    args.push(arg);
                  } else {
                    throw new src_ParseError("Null argument, please report this as a bug");
                  }
                }
                return {
                  args,
                  optArgs
                };
              }
              /**
               * Parses a group when the mode is changing.
               */
              parseGroupOfType(name2, type2, optional) {
                switch (type2) {
                  case "color":
                    return this.parseColorGroup(optional);
                  case "size":
                    return this.parseSizeGroup(optional);
                  case "url":
                    return this.parseUrlGroup(optional);
                  case "math":
                  case "text":
                    return this.parseArgumentGroup(optional, type2);
                  case "hbox": {
                    const group = this.parseArgumentGroup(optional, "text");
                    return group != null ? {
                      type: "styling",
                      mode: group.mode,
                      body: [group],
                      style: "text"
                      // simulate \textstyle
                    } : null;
                  }
                  case "raw": {
                    const token = this.parseStringGroup("raw", optional);
                    return token != null ? {
                      type: "raw",
                      mode: "text",
                      string: token.text
                    } : null;
                  }
                  case "primitive": {
                    if (optional) {
                      throw new src_ParseError("A primitive argument cannot be optional");
                    }
                    const group = this.parseGroup(name2);
                    if (group == null) {
                      throw new src_ParseError("Expected group as " + name2, this.fetch());
                    }
                    return group;
                  }
                  case "original":
                  case null:
                  case void 0:
                    return this.parseArgumentGroup(optional);
                  default:
                    throw new src_ParseError("Unknown group type as " + name2, this.fetch());
                }
              }
              /**
               * Discard any space tokens, fetching the next non-space token.
               */
              consumeSpaces() {
                while (this.fetch().text === " ") {
                  this.consume();
                }
              }
              /**
               * Parses a group, essentially returning the string formed by the
               * brace-enclosed tokens plus some position information.
               */
              parseStringGroup(modeName, optional) {
                const argToken = this.gullet.scanArgument(optional);
                if (argToken == null) {
                  return null;
                }
                let str = "";
                let nextToken;
                while ((nextToken = this.fetch()).text !== "EOF") {
                  str += nextToken.text;
                  this.consume();
                }
                this.consume();
                argToken.text = str;
                return argToken;
              }
              /**
               * Parses a regex-delimited group: the largest sequence of tokens
               * whose concatenated strings match `regex`. Returns the string
               * formed by the tokens plus some position information.
               */
              parseRegexGroup(regex, modeName) {
                const firstToken = this.fetch();
                let lastToken = firstToken;
                let str = "";
                let nextToken;
                while ((nextToken = this.fetch()).text !== "EOF" && regex.test(str + nextToken.text)) {
                  lastToken = nextToken;
                  str += lastToken.text;
                  this.consume();
                }
                if (str === "") {
                  throw new src_ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
                }
                return firstToken.range(lastToken, str);
              }
              /**
               * Parses a color description.
               */
              parseColorGroup(optional) {
                const res = this.parseStringGroup("color", optional);
                if (res == null) {
                  return null;
                }
                const match2 = /^(#[a-f0-9]{3,4}|#[a-f0-9]{6}|#[a-f0-9]{8}|[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);
                if (!match2) {
                  throw new src_ParseError("Invalid color: '" + res.text + "'", res);
                }
                let color2 = match2[0];
                if (/^[0-9a-f]{6}$/i.test(color2)) {
                  color2 = "#" + color2;
                }
                return {
                  type: "color-token",
                  mode: this.mode,
                  color: color2
                };
              }
              /**
               * Parses a size specification, consisting of magnitude and unit.
               */
              parseSizeGroup(optional) {
                let res;
                let isBlank = false;
                this.gullet.consumeSpaces();
                if (!optional && this.gullet.future().text !== "{") {
                  res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
                } else {
                  res = this.parseStringGroup("size", optional);
                }
                if (!res) {
                  return null;
                }
                if (!optional && res.text.length === 0) {
                  res.text = "0pt";
                  isBlank = true;
                }
                const match2 = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);
                if (!match2) {
                  throw new src_ParseError("Invalid size: '" + res.text + "'", res);
                }
                const data2 = {
                  number: +(match2[1] + match2[2]),
                  // sign + magnitude, cast to number
                  unit: match2[3]
                };
                if (!validUnit(data2)) {
                  throw new src_ParseError("Invalid unit: '" + data2.unit + "'", res);
                }
                return {
                  type: "size",
                  mode: this.mode,
                  value: data2,
                  isBlank
                };
              }
              /**
               * Parses an URL, checking escaped letters and allowed protocols,
               * and setting the catcode of % as an active character (as in \hyperref).
               */
              parseUrlGroup(optional) {
                this.gullet.lexer.setCatcode("%", 13);
                this.gullet.lexer.setCatcode("~", 12);
                const res = this.parseStringGroup("url", optional);
                this.gullet.lexer.setCatcode("%", 14);
                this.gullet.lexer.setCatcode("~", 13);
                if (res == null) {
                  return null;
                }
                const url = res.text.replace(/\\([#$%&~_^{}])/g, "$1");
                return {
                  type: "url",
                  mode: this.mode,
                  url
                };
              }
              /**
               * Parses an argument with the mode specified.
               */
              parseArgumentGroup(optional, mode) {
                const argToken = this.gullet.scanArgument(optional);
                if (argToken == null) {
                  return null;
                }
                const outerMode = this.mode;
                if (mode) {
                  this.switchMode(mode);
                }
                this.gullet.beginGroup();
                const expression = this.parseExpression(false, "EOF");
                this.expect("EOF");
                this.gullet.endGroup();
                const result = {
                  type: "ordgroup",
                  mode: this.mode,
                  loc: argToken.loc,
                  body: expression
                };
                if (mode) {
                  this.switchMode(outerMode);
                }
                return result;
              }
              /**
               * Parses an ordinary group, which is either a single nucleus (like "x")
               * or an expression in braces (like "{x+y}") or an implicit group, a group
               * that starts at the current position, and ends right before a higher explicit
               * group ends, or at EOF.
               */
              parseGroup(name2, breakOnTokenText) {
                const firstToken = this.fetch();
                const text3 = firstToken.text;
                let result;
                if (text3 === "{" || text3 === "\\begingroup") {
                  this.consume();
                  const groupEnd = text3 === "{" ? "}" : "\\endgroup";
                  this.gullet.beginGroup();
                  const expression = this.parseExpression(false, groupEnd);
                  const lastToken = this.fetch();
                  this.expect(groupEnd);
                  this.gullet.endGroup();
                  result = {
                    type: "ordgroup",
                    mode: this.mode,
                    loc: SourceLocation.range(firstToken, lastToken),
                    body: expression,
                    // A group formed by \begingroup...\endgroup is a semi-simple group
                    // which doesn't affect spacing in math mode, i.e., is transparent.
                    // https://tex.stackexchange.com/questions/1930/when-should-one-
                    // use-begingroup-instead-of-bgroup
                    semisimple: text3 === "\\begingroup" || void 0
                  };
                } else {
                  result = this.parseFunction(breakOnTokenText, name2) || this.parseSymbol();
                  if (result == null && text3[0] === "\\" && !implicitCommands.hasOwnProperty(text3)) {
                    if (this.settings.throwOnError) {
                      throw new src_ParseError("Undefined control sequence: " + text3, firstToken);
                    }
                    result = this.formatUnsupportedCmd(text3);
                    this.consume();
                  }
                }
                return result;
              }
              /**
               * Form ligature-like combinations of characters for text mode.
               * This includes inputs like "--", "---", "``" and "''".
               * The result will simply replace multiple textord nodes with a single
               * character in each value by a single textord node having multiple
               * characters in its value.  The representation is still ASCII source.
               * The group will be modified in place.
               */
              formLigatures(group) {
                let n = group.length - 1;
                for (let i = 0; i < n; ++i) {
                  const a = group[i];
                  const v2 = a.text;
                  if (v2 === "-" && group[i + 1].text === "-") {
                    if (i + 1 < n && group[i + 2].text === "-") {
                      group.splice(i, 3, {
                        type: "textord",
                        mode: "text",
                        loc: SourceLocation.range(a, group[i + 2]),
                        text: "---"
                      });
                      n -= 2;
                    } else {
                      group.splice(i, 2, {
                        type: "textord",
                        mode: "text",
                        loc: SourceLocation.range(a, group[i + 1]),
                        text: "--"
                      });
                      n -= 1;
                    }
                  }
                  if ((v2 === "'" || v2 === "`") && group[i + 1].text === v2) {
                    group.splice(i, 2, {
                      type: "textord",
                      mode: "text",
                      loc: SourceLocation.range(a, group[i + 1]),
                      text: v2 + v2
                    });
                    n -= 1;
                  }
                }
              }
              /**
               * Parse a single symbol out of the string. Here, we handle single character
               * symbols and special functions like \verb.
               */
              parseSymbol() {
                const nucleus = this.fetch();
                let text3 = nucleus.text;
                if (/^\\verb[^a-zA-Z]/.test(text3)) {
                  this.consume();
                  let arg = text3.slice(5);
                  const star = arg.charAt(0) === "*";
                  if (star) {
                    arg = arg.slice(1);
                  }
                  if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
                    throw new src_ParseError("\\verb assertion failed --\n                    please report what input caused this bug");
                  }
                  arg = arg.slice(1, -1);
                  return {
                    type: "verb",
                    mode: "text",
                    body: arg,
                    star
                  };
                }
                if (unicodeSymbols.hasOwnProperty(text3[0]) && !src_symbols[this.mode][text3[0]]) {
                  if (this.settings.strict && this.mode === "math") {
                    this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + text3[0] + '" used in math mode', nucleus);
                  }
                  text3 = unicodeSymbols[text3[0]] + text3.slice(1);
                }
                const match2 = combiningDiacriticalMarksEndRegex.exec(text3);
                if (match2) {
                  text3 = text3.substring(0, match2.index);
                  if (text3 === "i") {
                    text3 = "\u0131";
                  } else if (text3 === "j") {
                    text3 = "\u0237";
                  }
                }
                let symbol;
                if (src_symbols[this.mode][text3]) {
                  if (this.settings.strict && this.mode === "math" && extraLatin.indexOf(text3) >= 0) {
                    this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + text3[0] + '" used in math mode', nucleus);
                  }
                  const group = src_symbols[this.mode][text3].group;
                  const loc = SourceLocation.range(nucleus);
                  let s;
                  if (ATOMS.hasOwnProperty(group)) {
                    const family = group;
                    s = {
                      type: "atom",
                      mode: this.mode,
                      family,
                      loc,
                      text: text3
                    };
                  } else {
                    s = {
                      type: group,
                      mode: this.mode,
                      loc,
                      text: text3
                    };
                  }
                  symbol = s;
                } else if (text3.charCodeAt(0) >= 128) {
                  if (this.settings.strict) {
                    if (!supportedCodepoint(text3.charCodeAt(0))) {
                      this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + text3[0] + '"' + (" (" + text3.charCodeAt(0) + ")"), nucleus);
                    } else if (this.mode === "math") {
                      this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + text3[0] + '" used in math mode', nucleus);
                    }
                  }
                  symbol = {
                    type: "textord",
                    mode: "text",
                    loc: SourceLocation.range(nucleus),
                    text: text3
                  };
                } else {
                  return null;
                }
                this.consume();
                if (match2) {
                  for (let i = 0; i < match2[0].length; i++) {
                    const accent2 = match2[0][i];
                    if (!unicodeAccents[accent2]) {
                      throw new src_ParseError("Unknown accent ' " + accent2 + "'", nucleus);
                    }
                    const command = unicodeAccents[accent2][this.mode] || unicodeAccents[accent2].text;
                    if (!command) {
                      throw new src_ParseError("Accent " + accent2 + " unsupported in " + this.mode + " mode", nucleus);
                    }
                    symbol = {
                      type: "accent",
                      mode: this.mode,
                      loc: SourceLocation.range(nucleus),
                      label: command,
                      isStretchy: false,
                      isShifty: true,
                      // $FlowFixMe
                      base: symbol
                    };
                  }
                }
                return symbol;
              }
            }
            Parser3.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
            ;
            const parseTree = function(toParse, settings) {
              if (!(typeof toParse === "string" || toParse instanceof String)) {
                throw new TypeError("KaTeX can only parse string typed expression");
              }
              const parser = new Parser3(toParse, settings);
              delete parser.gullet.macros.current["\\df@tag"];
              let tree = parser.parse();
              delete parser.gullet.macros.current["\\current@color"];
              delete parser.gullet.macros.current["\\color"];
              if (parser.gullet.macros.get("\\df@tag")) {
                if (!settings.displayMode) {
                  throw new src_ParseError("\\tag works only in display equations");
                }
                tree = [{
                  type: "tag",
                  mode: "text",
                  body: tree,
                  tag: parser.subparse([new Token2("\\df@tag")])
                }];
              }
              return tree;
            };
            var src_parseTree = parseTree;
            ;
            let render2 = function(expression, baseNode, options) {
              baseNode.textContent = "";
              const node = renderToDomTree(expression, options).toNode();
              baseNode.appendChild(node);
            };
            if (typeof document !== "undefined") {
              if (document.compatMode !== "CSS1Compat") {
                typeof console !== "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype.");
                render2 = function() {
                  throw new src_ParseError("KaTeX doesn't work in quirks mode.");
                };
              }
            }
            const renderToString = function(expression, options) {
              const markup = renderToDomTree(expression, options).toMarkup();
              return markup;
            };
            const generateParseTree = function(expression, options) {
              const settings = new Settings(options);
              return src_parseTree(expression, settings);
            };
            const renderError = function(error2, expression, options) {
              if (options.throwOnError || !(error2 instanceof src_ParseError)) {
                throw error2;
              }
              const node = buildCommon.makeSpan(["katex-error"], [new SymbolNode(expression)]);
              node.setAttribute("title", error2.toString());
              node.setAttribute("style", "color:" + options.errorColor);
              return node;
            };
            const renderToDomTree = function(expression, options) {
              const settings = new Settings(options);
              try {
                const tree = src_parseTree(expression, settings);
                return buildTree2(tree, expression, settings);
              } catch (error2) {
                return renderError(error2, expression, settings);
              }
            };
            const renderToHTMLTree = function(expression, options) {
              const settings = new Settings(options);
              try {
                const tree = src_parseTree(expression, settings);
                return buildHTMLTree(tree, expression, settings);
              } catch (error2) {
                return renderError(error2, expression, settings);
              }
            };
            const version = "0.16.27";
            const __domTree = {
              Span,
              Anchor,
              SymbolNode,
              SvgNode,
              PathNode,
              LineNode
            };
            var katex = {
              /**
               * Current KaTeX version
               */
              version,
              /**
               * Renders the given LaTeX into an HTML+MathML combination, and adds
               * it as a child to the specified DOM node.
               */
              render: render2,
              /**
               * Renders the given LaTeX into an HTML+MathML combination string,
               * for sending to the client.
               */
              renderToString,
              /**
               * KaTeX error, usually during parsing.
               */
              ParseError: src_ParseError,
              /**
               * The schema of Settings
               */
              SETTINGS_SCHEMA,
              /**
               * Parses the given LaTeX into KaTeX's internal parse tree structure,
               * without rendering to HTML or MathML.
               *
               * NOTE: This method is not currently recommended for public use.
               * The internal tree representation is unstable and is very likely
               * to change. Use at your own risk.
               */
              __parse: generateParseTree,
              /**
               * Renders the given LaTeX into an HTML+MathML internal DOM tree
               * representation, without flattening that representation to a string.
               *
               * NOTE: This method is not currently recommended for public use.
               * The internal tree representation is unstable and is very likely
               * to change. Use at your own risk.
               */
              __renderToDomTree: renderToDomTree,
              /**
               * Renders the given LaTeX into an HTML internal DOM tree representation,
               * without MathML and without flattening that representation to a string.
               *
               * NOTE: This method is not currently recommended for public use.
               * The internal tree representation is unstable and is very likely
               * to change. Use at your own risk.
               */
              __renderToHTMLTree: renderToHTMLTree,
              /**
               * extends internal font metrics object with a new object
               * each key in the new object represents a font name
              */
              __setFontMetrics: setFontMetrics,
              /**
               * adds a new symbol to builtin symbols table
               */
              __defineSymbol: defineSymbol,
              /**
               * adds a new function to builtin function list,
               * which directly produce parse tree elements
               * and have their own html/mathml builders
               */
              __defineFunction: defineFunction,
              /**
               * adds a new macro to builtin macro list
               */
              __defineMacro: defineMacro,
              /**
               * Expose the dom tree node types, which can be useful for type checking nodes.
               *
               * NOTE: These methods are not currently recommended for public use.
               * The internal tree representation is unstable and is very likely
               * to change. Use at your own risk.
               */
              __domTree
            };
            ;
            var katex_webpack = katex;
            __webpack_exports__ = __webpack_exports__["default"];
            return __webpack_exports__;
          }()
        );
      });
    }
  });

  // node_modules/@vscode/markdown-it-katex/dist/index.js
  var require_dist = __commonJS({
    "node_modules/@vscode/markdown-it-katex/dist/index.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var katex_1 = __importDefault(require_katex());
      function isValidInlineDelim(state, pos) {
        const prevChar = state.src[pos - 1];
        const char = state.src[pos];
        const nextChar = state.src[pos + 1];
        if (char !== "$") {
          return { can_open: false, can_close: false };
        }
        let canOpen = false;
        let canClose = false;
        if (prevChar !== "$" && prevChar !== "\\" && (prevChar === void 0 || isWhitespace2(prevChar) || !isWordCharacterOrNumber(prevChar))) {
          canOpen = true;
        }
        if (nextChar !== "$" && (nextChar == void 0 || isWhitespace2(nextChar) || !isWordCharacterOrNumber(nextChar))) {
          canClose = true;
        }
        return { can_open: canOpen, can_close: canClose };
      }
      function isWhitespace2(char) {
        return /^\s$/u.test(char);
      }
      function isWordCharacterOrNumber(char) {
        return /^[\w\d]$/u.test(char);
      }
      function isValidBlockDelim(state, pos) {
        const prevChar = state.src[pos - 1];
        const char = state.src[pos];
        const nextChar = state.src[pos + 1];
        const nextCharPlus1 = state.src[pos + 2];
        if (char === "$" && prevChar !== "$" && prevChar !== "\\" && nextChar === "$" && nextCharPlus1 !== "$") {
          return { can_open: true, can_close: true };
        }
        return { can_open: false, can_close: false };
      }
      function inlineMath(state, silent) {
        if (state.src[state.pos] !== "$") {
          return false;
        }
        const lastToken = state.tokens.at(-1);
        if (lastToken?.type === "html_inline") {
          if (/^<\w+.+[^/]>$/.test(lastToken.content)) {
            return false;
          }
        }
        let res = isValidInlineDelim(state, state.pos);
        if (!res.can_open) {
          if (!silent) {
            state.pending += "$";
          }
          state.pos += 1;
          return true;
        }
        let start2 = state.pos + 1;
        let match2 = start2;
        let pos;
        while ((match2 = state.src.indexOf("$", match2)) !== -1) {
          pos = match2 - 1;
          while (state.src[pos] === "\\") {
            pos -= 1;
          }
          if ((match2 - pos) % 2 == 1) {
            break;
          }
          match2 += 1;
        }
        if (match2 === -1) {
          if (!silent) {
            state.pending += "$";
          }
          state.pos = start2;
          return true;
        }
        if (match2 - start2 === 0) {
          if (!silent) {
            state.pending += "$$";
          }
          state.pos = start2 + 1;
          return true;
        }
        res = isValidInlineDelim(state, match2);
        if (!res.can_close) {
          if (!silent) {
            state.pending += "$";
          }
          state.pos = start2;
          return true;
        }
        if (!silent) {
          const token = state.push("math_inline", "math", 0);
          token.markup = "$";
          token.content = state.src.slice(start2, match2);
        }
        state.pos = match2 + 1;
        return true;
      }
      function blockMath(state, start2, end2, silent) {
        let found = false;
        let pos = state.bMarks[start2] + state.tShift[start2];
        let max3 = state.eMarks[start2];
        if (pos + 2 > max3) {
          return false;
        }
        if (state.src.slice(pos, pos + 2) !== "$$") {
          return false;
        }
        pos += 2;
        let firstLine = state.src.slice(pos, max3);
        const endIndexes = [...firstLine.matchAll(/\$\$/g)];
        if (endIndexes.length === 1 && endIndexes[0].index === firstLine.length - 2) {
          firstLine = firstLine.trim().slice(0, -2);
          found = true;
        } else if (endIndexes.length > 1) {
          return false;
        }
        if (silent) {
          return true;
        }
        let lastLine;
        let next2;
        let lastPos;
        for (next2 = start2; !found; ) {
          next2++;
          if (next2 >= end2) {
            break;
          }
          pos = state.bMarks[next2] + state.tShift[next2];
          max3 = state.eMarks[next2];
          if (pos < max3 && state.tShift[next2] < state.blkIndent) {
            break;
          }
          if (state.src.slice(pos, max3).trim().slice(-2) === "$$") {
            lastPos = state.src.slice(0, max3).lastIndexOf("$$");
            lastLine = state.src.slice(pos, lastPos);
            found = true;
          } else if (state.src.slice(pos, max3).trim().includes("$$")) {
            lastPos = state.src.slice(0, max3).trim().indexOf("$$");
            lastLine = state.src.slice(pos, lastPos);
            found = true;
          }
        }
        state.line = next2 + 1;
        const token = state.push("math_block", "math", 0);
        token.block = true;
        token.content = (firstLine && firstLine.trim() ? firstLine + "\n" : "") + state.getLines(start2 + 1, next2, state.tShift[start2], true) + (lastLine && lastLine.trim() ? lastLine : "");
        token.map = [start2, state.line];
        token.markup = "$$";
        return true;
      }
      function blockBareMath(state, start2, end2, silent) {
        const startPos = state.bMarks[start2] + state.tShift[start2];
        const startMax = state.eMarks[start2];
        const firstLine = state.src.slice(startPos, startMax);
        const beginMatch = firstLine.match(/^\s*\\begin\s*\{([^{}]+)\}/);
        if (!beginMatch) {
          return false;
        }
        if (start2 > 0) {
          const previousStart = state.bMarks[start2 - 1] + state.tShift[start2 - 1];
          const previousEnd = state.eMarks[start2 - 1];
          const previousLine = state.src.slice(previousStart, previousEnd);
          if (!/^\s*$/.test(previousLine)) {
            return false;
          }
        }
        if (silent) {
          return true;
        }
        const beginEndStack = [];
        let next2 = start2;
        let lastLine;
        let found = false;
        outer: for (; !found; next2++) {
          if (next2 >= end2) {
            break;
          }
          const pos = state.bMarks[next2] + state.tShift[next2];
          const max3 = state.eMarks[next2];
          if (pos < max3 && state.tShift[next2] < state.blkIndent) {
            break;
          }
          const line = state.src.slice(pos, max3);
          for (const match2 of line.matchAll(/(\\begin|\\end)\s*\{([^{}]+)\}/g)) {
            if (match2[1] === "\\begin") {
              beginEndStack.push(match2[2].trim());
            } else if (match2[1] === "\\end") {
              beginEndStack.pop();
              if (!beginEndStack.length) {
                lastLine = state.src.slice(pos, max3);
                found = true;
                break outer;
              }
            }
          }
        }
        state.line = next2 + 1;
        const token = state.push("math_block", "math", 0);
        token.block = true;
        token.content = (state.getLines(start2, next2, state.tShift[start2], true) + (lastLine ?? "")).trim();
        token.map = [start2, state.line];
        token.markup = "$$";
        return true;
      }
      function inlineMathBlock(state, silent) {
        var start2, match2, token, res, pos;
        if (state.src.slice(state.pos, state.pos + 2) !== "$$") {
          return false;
        }
        res = isValidBlockDelim(state, state.pos);
        if (!res.can_open) {
          if (!silent) {
            state.pending += "$$";
          }
          state.pos += 2;
          return true;
        }
        start2 = state.pos + 2;
        match2 = start2;
        while ((match2 = state.src.indexOf("$$", match2)) !== -1) {
          pos = match2 - 1;
          while (state.src[pos] === "\\") {
            pos -= 1;
          }
          if ((match2 - pos) % 2 == 1) {
            break;
          }
          match2 += 2;
        }
        if (match2 === -1) {
          if (!silent) {
            state.pending += "$$";
          }
          state.pos = start2;
          return true;
        }
        if (match2 - start2 === 0) {
          if (!silent) {
            state.pending += "$$$$";
          }
          state.pos = start2 + 2;
          return true;
        }
        res = isValidBlockDelim(state, match2);
        if (!res.can_close) {
          if (!silent) {
            state.pending += "$$";
          }
          state.pos = start2;
          return true;
        }
        if (!silent) {
          token = state.push("math_block", "math", 0);
          token.block = true;
          token.markup = "$$";
          token.content = state.src.slice(start2, match2);
        }
        state.pos = match2 + 2;
        return true;
      }
      function inlineBareBlock(state, silent) {
        const text3 = state.src.slice(state.pos);
        if (!/^\n\\begin/.test(text3)) {
          return false;
        }
        state.pos += 1;
        if (silent) {
          return true;
        }
        const lines = text3.split(/\n/g).slice(1);
        let foundLine;
        const beginEndStack = [];
        outer: for (var i = 0; i < lines.length; ++i) {
          const line = lines[i];
          for (const match2 of line.matchAll(/(\\begin|\\end)\s*\{([^{}]+)\}/g)) {
            if (match2[1] === "\\begin") {
              beginEndStack.push(match2[2].trim());
            } else if (match2[1] === "\\end") {
              beginEndStack.pop();
              if (!beginEndStack.length) {
                foundLine = i;
                break outer;
              }
            }
          }
        }
        if (typeof foundLine === "undefined") {
          return false;
        }
        const endIndex = lines.slice(0, foundLine + 1).reduce((p, c) => p + c.length, 0) + foundLine + 1;
        const token = state.push("math_inline_bare_block", "math", 0);
        token.block = true;
        token.markup = "$$";
        token.content = text3.slice(1, endIndex);
        state.pos = state.pos + endIndex;
        return true;
      }
      function handleMathInHtml(state, mathType, mathMarkup, mathRegex) {
        const tokens = state.tokens;
        for (let index2 = tokens.length - 1; index2 >= 0; index2--) {
          const currentToken = tokens[index2];
          const newTokens = [];
          if (currentToken.type !== "html_block") {
            continue;
          }
          const content = currentToken.content;
          for (const match2 of content.matchAll(mathRegex)) {
            if (!match2.groups) {
              continue;
            }
            const html_before_math = match2.groups.html_before_math;
            const math = match2.groups.math;
            const html_after_math = match2.groups.html_after_math;
            if (html_before_math) {
              newTokens.push({ ...currentToken, type: "html_block", map: null, content: html_before_math });
            }
            if (math) {
              newTokens.push({
                ...currentToken,
                type: mathType,
                map: null,
                content: math,
                markup: mathMarkup,
                block: true,
                tag: "math"
              });
            }
            if (html_after_math) {
              newTokens.push({ ...currentToken, type: "html_block", map: null, content: html_after_math });
            }
          }
          if (newTokens.length > 0) {
            tokens.splice(index2, 1, ...newTokens);
          }
        }
        return true;
      }
      function escapeHtml2(unsafe) {
        return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
      }
      function default_1(md, options) {
        const katex = options?.katex ?? katex_1.default;
        const enableBareBlocks = options?.enableBareBlocks;
        const enableMathBlockInHtml = options?.enableMathBlockInHtml;
        const enableMathInlineInHtml = options?.enableMathInlineInHtml;
        const enableFencedBlocks = options?.enableFencedBlocks;
        md.inline.ruler.after("escape", "math_inline", inlineMath);
        md.inline.ruler.after("escape", "math_inline_block", inlineMathBlock);
        if (enableBareBlocks) {
          md.inline.ruler.before("text", "math_inline_bare_block", inlineBareBlock);
        }
        md.block.ruler.after("blockquote", "math_block", (state, start2, end2, silent) => {
          if (enableBareBlocks && blockBareMath(state, start2, end2, silent)) {
            return true;
          }
          return blockMath(state, start2, end2, silent);
        }, {
          alt: ["paragraph", "reference", "blockquote", "list"]
        });
        const math_block_within_html_regex = /(?<html_before_math>[\s\S]*?)\$\$(?<math>[\s\S]+?)\$\$(?<html_after_math>(?:(?!\$\$[\s\S]+?\$\$)[\s\S])*)/gm;
        const math_inline_within_html_regex = /(?<html_before_math>[\s\S]*?)\$(?<math>.*?)\$(?<html_after_math>(?:(?!\$.*?\$)[\s\S])*)/gm;
        if (enableMathBlockInHtml) {
          md.core.ruler.push("math_block_in_html_block", (state) => {
            return handleMathInHtml(state, "math_block", "$$", math_block_within_html_regex);
          });
        }
        if (enableMathInlineInHtml) {
          md.core.ruler.push("math_inline_in_html_block", (state) => {
            return handleMathInHtml(state, "math_inline", "$", math_inline_within_html_regex);
          });
        }
        const katexInline = (latex) => {
          const displayMode = /\\begin\{(align|equation|gather|cd|alignat)\}/ig.test(latex);
          try {
            return katex.renderToString(latex, { ...options, displayMode });
          } catch (error2) {
            if (options?.throwOnError) {
              console.log(error2);
            }
            return `<span class="katex-error" title="${escapeHtml2(latex)}">${escapeHtml2(error2 + "")}</span>`;
          }
        };
        const inlineRenderer = (tokens, idx) => {
          const content = tokens[idx].content;
          const hasBacktick = content.length > 2 && content[0] === "`" && content[content.length - 1] === "`";
          const sanitized = hasBacktick ? content.slice(1, -1) : content;
          return katexInline(sanitized);
        };
        const katexBlockRenderer = (latex) => {
          try {
            return `<p class="katex-block">${katex.renderToString(latex, { ...options, displayMode: true })}</p>`;
          } catch (error2) {
            if (options?.throwOnError) {
              console.log(error2);
            }
            return `<p class="katex-block katex-error" title="${escapeHtml2(latex)}">${escapeHtml2(error2 + "")}</p>`;
          }
        };
        const blockRenderer = (tokens, idx) => {
          return katexBlockRenderer(tokens[idx].content) + "\n";
        };
        md.renderer.rules.math_inline = inlineRenderer;
        md.renderer.rules.math_inline_block = blockRenderer;
        md.renderer.rules.math_inline_bare_block = blockRenderer;
        md.renderer.rules.math_block = blockRenderer;
        if (enableFencedBlocks) {
          const mathLanguageId = "math";
          const originalFenceRenderer = md.renderer.rules.fence;
          md.renderer.rules.fence = function(tokens, idx, options2, env, self2) {
            const token = tokens[idx];
            if (token.info.trim().toLowerCase() === mathLanguageId && enableFencedBlocks) {
              return katexBlockRenderer(token.content) + "\n";
            } else {
              return originalFenceRenderer?.call(this, tokens, idx, options2, env, self2) || "";
            }
          };
        }
      }
      exports.default = default_1;
    }
  });

  // node_modules/markmap-common/dist/index.mjs
  var testPath = "npm2url/dist/index.cjs";
  var defaultProviders = {
    jsdelivr: (path2) => `https://cdn.jsdelivr.net/npm/${path2}`,
    unpkg: (path2) => `https://unpkg.com/${path2}`
  };
  async function checkUrl(url, signal) {
    const res = await fetch(url, {
      signal
    });
    if (!res.ok) {
      throw res;
    }
    await res.text();
  }
  var UrlBuilder = class {
    constructor() {
      this.providers = { ...defaultProviders };
      this.provider = "jsdelivr";
    }
    /**
     * Get the fastest provider name.
     * If none of the providers returns a valid response within `timeout`, an error will be thrown.
     */
    async getFastestProvider(timeout2 = 5e3, path2 = testPath) {
      const controller = new AbortController();
      let timer2 = 0;
      try {
        return await new Promise((resolve, reject) => {
          Promise.all(
            Object.entries(this.providers).map(async ([name2, factory]) => {
              try {
                await checkUrl(factory(path2), controller.signal);
                resolve(name2);
              } catch {
              }
            })
          ).then(() => reject(new Error("All providers failed")));
          timer2 = setTimeout(reject, timeout2, new Error("Timed out"));
        });
      } finally {
        controller.abort();
        clearTimeout(timer2);
      }
    }
    /**
     * Set the current provider to the fastest provider found by `getFastestProvider`.
     */
    async findFastestProvider(timeout2, path2) {
      this.provider = await this.getFastestProvider(timeout2, path2);
      return this.provider;
    }
    setProvider(name2, factory) {
      if (factory) {
        this.providers[name2] = factory;
      } else {
        delete this.providers[name2];
      }
    }
    getFullUrl(path2, provider = this.provider) {
      if (path2.includes("://")) {
        return path2;
      }
      const factory = this.providers[provider];
      if (!factory) {
        throw new Error(`Provider ${provider} not found`);
      }
      return factory(path2);
    }
  };
  var urlBuilder = new UrlBuilder();
  var Hook = class {
    constructor() {
      this.listeners = [];
    }
    tap(fn) {
      this.listeners.push(fn);
      return () => this.revoke(fn);
    }
    revoke(fn) {
      const i = this.listeners.indexOf(fn);
      if (i >= 0) this.listeners.splice(i, 1);
    }
    revokeAll() {
      this.listeners.splice(0);
    }
    call(...args) {
      for (const fn of this.listeners) {
        fn(...args);
      }
    }
  };
  var uniqId = Math.random().toString(36).slice(2, 8);
  var globalIndex = 0;
  function getId() {
    globalIndex += 1;
    return `mm-${uniqId}-${globalIndex}`;
  }
  function noop() {
  }
  function walkTree(tree, callback) {
    const walk = (item, parent2) => callback(
      item,
      () => {
        var _a3;
        return (_a3 = item.children) == null ? void 0 : _a3.map((child) => walk(child, item));
      },
      parent2
    );
    return walk(tree);
  }
  function addClass(className, ...rest) {
    const classList2 = (className || "").split(" ").filter(Boolean);
    rest.forEach((item) => {
      if (item && classList2.indexOf(item) < 0) classList2.push(item);
    });
    return classList2.join(" ");
  }
  function wrapFunction(fn, wrapper) {
    return (...args) => wrapper(fn, ...args);
  }
  function defer() {
    const obj = {};
    obj.promise = new Promise((resolve, reject) => {
      obj.resolve = resolve;
      obj.reject = reject;
    });
    return obj;
  }
  function memoize(fn) {
    const cache = {};
    return function memoized(...args) {
      const key = `${args[0]}`;
      let data2 = cache[key];
      if (!data2) {
        data2 = {
          value: fn(...args)
        };
        cache[key] = data2;
      }
      return data2.value;
    };
  }
  function debounce(fn, time) {
    const state = {
      timer: 0
    };
    function reset() {
      if (state.timer) {
        window.clearTimeout(state.timer);
        state.timer = 0;
      }
    }
    function run() {
      reset();
      if (state.args) state.result = fn(...state.args);
    }
    return function debounced(...args) {
      reset();
      state.args = args;
      state.timer = window.setTimeout(run, time);
      return state.result;
    };
  }
  var VTYPE_ELEMENT = 1;
  var VTYPE_FUNCTION = 2;
  var SVG_NS = "http://www.w3.org/2000/svg";
  var XLINK_NS = "http://www.w3.org/1999/xlink";
  var NS_ATTRS = {
    show: XLINK_NS,
    actuate: XLINK_NS,
    href: XLINK_NS
  };
  var isLeaf = (c) => typeof c === "string" || typeof c === "number";
  var isElement = (c) => (c == null ? void 0 : c.vtype) === VTYPE_ELEMENT;
  var isRenderFunction = (c) => (c == null ? void 0 : c.vtype) === VTYPE_FUNCTION;
  function h(type2, props, ...children3) {
    props = Object.assign({}, props, {
      children: children3.length === 1 ? children3[0] : children3
    });
    return jsx(type2, props);
  }
  function jsx(type2, props) {
    let vtype;
    if (typeof type2 === "string") vtype = VTYPE_ELEMENT;
    else if (typeof type2 === "function") vtype = VTYPE_FUNCTION;
    else throw new Error("Invalid VNode type");
    return {
      vtype,
      type: type2,
      props
    };
  }
  function Fragment(props) {
    return props.children;
  }
  var DEFAULT_ENV = {
    isSvg: false
  };
  function insertDom(parent2, nodes) {
    if (!Array.isArray(nodes)) nodes = [nodes];
    nodes = nodes.filter(Boolean);
    if (nodes.length) parent2.append(...nodes);
  }
  function mountAttributes(domElement, props, env) {
    for (const key in props) {
      if (key === "key" || key === "children" || key === "ref") continue;
      if (key === "dangerouslySetInnerHTML") {
        domElement.innerHTML = props[key].__html;
      } else if (key === "innerHTML" || key === "textContent" || key === "innerText" || key === "value" && ["textarea", "select"].includes(domElement.tagName)) {
        const value = props[key];
        if (value != null) domElement[key] = value;
      } else if (key.startsWith("on")) {
        domElement[key.toLowerCase()] = props[key];
      } else {
        setDOMAttribute(domElement, key, props[key], env.isSvg);
      }
    }
  }
  var attrMap = {
    className: "class",
    labelFor: "for"
  };
  function setDOMAttribute(el, attr2, value, isSVG) {
    attr2 = attrMap[attr2] || attr2;
    if (value === true) {
      el.setAttribute(attr2, "");
    } else if (value === false) {
      el.removeAttribute(attr2);
    } else {
      const namespace = isSVG ? NS_ATTRS[attr2] : void 0;
      if (namespace !== void 0) {
        el.setAttributeNS(namespace, attr2, value);
      } else {
        el.setAttribute(attr2, value);
      }
    }
  }
  function flatten(arr) {
    return arr.reduce((prev2, item) => prev2.concat(item), []);
  }
  function mountChildren(children3, env) {
    return Array.isArray(children3) ? flatten(children3.map((child) => mountChildren(child, env))) : mount(children3, env);
  }
  function mount(vnode, env = DEFAULT_ENV) {
    if (vnode == null || typeof vnode === "boolean") {
      return null;
    }
    if (vnode instanceof Node) {
      return vnode;
    }
    if (isRenderFunction(vnode)) {
      const {
        type: type2,
        props
      } = vnode;
      if (type2 === Fragment) {
        const node = document.createDocumentFragment();
        if (props.children) {
          const children3 = mountChildren(props.children, env);
          insertDom(node, children3);
        }
        return node;
      }
      const childVNode = type2(props);
      return mount(childVNode, env);
    }
    if (isLeaf(vnode)) {
      return document.createTextNode(`${vnode}`);
    }
    if (isElement(vnode)) {
      let node;
      const {
        type: type2,
        props
      } = vnode;
      if (!env.isSvg && type2 === "svg") {
        env = Object.assign({}, env, {
          isSvg: true
        });
      }
      if (!env.isSvg) {
        node = document.createElement(type2);
      } else {
        node = document.createElementNS(SVG_NS, type2);
      }
      mountAttributes(node, props, env);
      if (props.children) {
        let childEnv = env;
        if (env.isSvg && type2 === "foreignObject") {
          childEnv = Object.assign({}, childEnv, {
            isSvg: false
          });
        }
        const children3 = mountChildren(props.children, childEnv);
        if (children3 != null) insertDom(node, children3);
      }
      const {
        ref
      } = props;
      if (typeof ref === "function") ref(node);
      return node;
    }
    throw new Error("mount: Invalid Vnode!");
  }
  function mountDom(vnode) {
    return mount(vnode);
  }
  function hm(...args) {
    return mountDom(h(...args));
  }
  var memoizedPreloadJS = memoize((url) => {
    document.head.append(
      hm("link", {
        rel: "preload",
        as: "script",
        href: url
      })
    );
  });
  var jsCache = {};
  async function loadJSItem(item, context) {
    var _a3;
    const src = item.type === "script" && ((_a3 = item.data) == null ? void 0 : _a3.src) || "";
    item.loaded || (item.loaded = jsCache[src]);
    if (!item.loaded) {
      const deferred = defer();
      item.loaded = deferred.promise;
      if (item.type === "script") {
        document.head.append(
          hm("script", {
            ...item.data,
            onLoad: () => deferred.resolve(),
            onError: deferred.reject
          })
        );
        if (!src) {
          deferred.resolve();
        } else {
          jsCache[src] = item.loaded;
        }
      }
      if (item.type === "iife") {
        const { fn, getParams } = item.data;
        fn(...(getParams == null ? void 0 : getParams(context)) || []);
        deferred.resolve();
      }
    }
    await item.loaded;
  }
  async function loadJS(items, context) {
    items.forEach((item) => {
      var _a3;
      if (item.type === "script" && ((_a3 = item.data) == null ? void 0 : _a3.src)) {
        memoizedPreloadJS(item.data.src);
      }
    });
    context = {
      getMarkmap: () => window.markmap,
      ...context
    };
    for (const item of items) {
      await loadJSItem(item, context);
    }
  }
  function buildJSItem(path2) {
    return {
      type: "script",
      data: {
        src: path2
      }
    };
  }
  function buildCSSItem(path2) {
    return {
      type: "stylesheet",
      data: {
        href: path2
      }
    };
  }

  // node_modules/markmap-html-parser/dist/index.mjs
  var defaultOpts$1 = {
    _useHtmlParser2: false
  };
  function flattenOptions(options, baseOptions) {
    if (!options) {
      return baseOptions !== null && baseOptions !== void 0 ? baseOptions : defaultOpts$1;
    }
    const opts = {
      _useHtmlParser2: !!options.xmlMode,
      ...baseOptions,
      ...options
    };
    if (options.xml) {
      opts._useHtmlParser2 = true;
      opts.xmlMode = true;
      if (options.xml !== true) {
        Object.assign(opts, options.xml);
      }
    } else if (options.xmlMode) {
      opts._useHtmlParser2 = true;
    }
    return opts;
  }
  var ElementType;
  (function(ElementType2) {
    ElementType2["Root"] = "root";
    ElementType2["Text"] = "text";
    ElementType2["Directive"] = "directive";
    ElementType2["Comment"] = "comment";
    ElementType2["Script"] = "script";
    ElementType2["Style"] = "style";
    ElementType2["Tag"] = "tag";
    ElementType2["CDATA"] = "cdata";
    ElementType2["Doctype"] = "doctype";
  })(ElementType || (ElementType = {}));
  function isTag$1(elem) {
    return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
  }
  var Root = ElementType.Root;
  var Text$1 = ElementType.Text;
  var Directive = ElementType.Directive;
  var Comment$1 = ElementType.Comment;
  var Script = ElementType.Script;
  var Style = ElementType.Style;
  var Tag = ElementType.Tag;
  var CDATA$1 = ElementType.CDATA;
  var Doctype = ElementType.Doctype;
  var Node2 = class {
    constructor() {
      this.parent = null;
      this.prev = null;
      this.next = null;
      this.startIndex = null;
      this.endIndex = null;
    }
    // Read-write aliases for properties
    /**
     * Same as {@link parent}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get parentNode() {
      return this.parent;
    }
    set parentNode(parent2) {
      this.parent = parent2;
    }
    /**
     * Same as {@link prev}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get previousSibling() {
      return this.prev;
    }
    set previousSibling(prev2) {
      this.prev = prev2;
    }
    /**
     * Same as {@link next}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get nextSibling() {
      return this.next;
    }
    set nextSibling(next2) {
      this.next = next2;
    }
    /**
     * Clone this node, and optionally its children.
     *
     * @param recursive Clone child nodes as well.
     * @returns A clone of the node.
     */
    cloneNode(recursive = false) {
      return cloneNode(this, recursive);
    }
  };
  var DataNode = class extends Node2 {
    /**
     * @param data The content of the data node
     */
    constructor(data2) {
      super();
      this.data = data2;
    }
    /**
     * Same as {@link data}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get nodeValue() {
      return this.data;
    }
    set nodeValue(data2) {
      this.data = data2;
    }
  };
  var Text = class extends DataNode {
    constructor() {
      super(...arguments);
      this.type = ElementType.Text;
    }
    get nodeType() {
      return 3;
    }
  };
  var Comment = class extends DataNode {
    constructor() {
      super(...arguments);
      this.type = ElementType.Comment;
    }
    get nodeType() {
      return 8;
    }
  };
  var ProcessingInstruction = class extends DataNode {
    constructor(name2, data2) {
      super(data2);
      this.name = name2;
      this.type = ElementType.Directive;
    }
    get nodeType() {
      return 1;
    }
  };
  var NodeWithChildren = class extends Node2 {
    /**
     * @param children Children of the node. Only certain node types can have children.
     */
    constructor(children22) {
      super();
      this.children = children22;
    }
    // Aliases
    /** First child of the node. */
    get firstChild() {
      var _a22;
      return (_a22 = this.children[0]) !== null && _a22 !== void 0 ? _a22 : null;
    }
    /** Last child of the node. */
    get lastChild() {
      return this.children.length > 0 ? this.children[this.children.length - 1] : null;
    }
    /**
     * Same as {@link children}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get childNodes() {
      return this.children;
    }
    set childNodes(children22) {
      this.children = children22;
    }
  };
  var CDATA = class extends NodeWithChildren {
    constructor() {
      super(...arguments);
      this.type = ElementType.CDATA;
    }
    get nodeType() {
      return 4;
    }
  };
  var Document = class extends NodeWithChildren {
    constructor() {
      super(...arguments);
      this.type = ElementType.Root;
    }
    get nodeType() {
      return 9;
    }
  };
  var Element = class extends NodeWithChildren {
    /**
     * @param name Name of the tag, eg. `div`, `span`.
     * @param attribs Object mapping attribute names to attribute values.
     * @param children Children of the node.
     */
    constructor(name2, attribs, children22 = [], type2 = name2 === "script" ? ElementType.Script : name2 === "style" ? ElementType.Style : ElementType.Tag) {
      super(children22);
      this.name = name2;
      this.attribs = attribs;
      this.type = type2;
    }
    get nodeType() {
      return 1;
    }
    // DOM Level 1 aliases
    /**
     * Same as {@link name}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get tagName() {
      return this.name;
    }
    set tagName(name2) {
      this.name = name2;
    }
    get attributes() {
      return Object.keys(this.attribs).map((name2) => {
        var _a22, _b;
        return {
          name: name2,
          value: this.attribs[name2],
          namespace: (_a22 = this["x-attribsNamespace"]) === null || _a22 === void 0 ? void 0 : _a22[name2],
          prefix: (_b = this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name2]
        };
      });
    }
  };
  function isTag(node) {
    return isTag$1(node);
  }
  function isCDATA(node) {
    return node.type === ElementType.CDATA;
  }
  function isText(node) {
    return node.type === ElementType.Text;
  }
  function isComment(node) {
    return node.type === ElementType.Comment;
  }
  function isDirective(node) {
    return node.type === ElementType.Directive;
  }
  function isDocument(node) {
    return node.type === ElementType.Root;
  }
  function hasChildren(node) {
    return Object.prototype.hasOwnProperty.call(node, "children");
  }
  function cloneNode(node, recursive = false) {
    let result;
    if (isText(node)) {
      result = new Text(node.data);
    } else if (isComment(node)) {
      result = new Comment(node.data);
    } else if (isTag(node)) {
      const children22 = recursive ? cloneChildren(node.children) : [];
      const clone2 = new Element(node.name, { ...node.attribs }, children22);
      children22.forEach((child) => child.parent = clone2);
      if (node.namespace != null) {
        clone2.namespace = node.namespace;
      }
      if (node["x-attribsNamespace"]) {
        clone2["x-attribsNamespace"] = { ...node["x-attribsNamespace"] };
      }
      if (node["x-attribsPrefix"]) {
        clone2["x-attribsPrefix"] = { ...node["x-attribsPrefix"] };
      }
      result = clone2;
    } else if (isCDATA(node)) {
      const children22 = recursive ? cloneChildren(node.children) : [];
      const clone2 = new CDATA(children22);
      children22.forEach((child) => child.parent = clone2);
      result = clone2;
    } else if (isDocument(node)) {
      const children22 = recursive ? cloneChildren(node.children) : [];
      const clone2 = new Document(children22);
      children22.forEach((child) => child.parent = clone2);
      if (node["x-mode"]) {
        clone2["x-mode"] = node["x-mode"];
      }
      result = clone2;
    } else if (isDirective(node)) {
      const instruction = new ProcessingInstruction(node.name, node.data);
      if (node["x-name"] != null) {
        instruction["x-name"] = node["x-name"];
        instruction["x-publicId"] = node["x-publicId"];
        instruction["x-systemId"] = node["x-systemId"];
      }
      result = instruction;
    } else {
      throw new Error(`Not implemented yet: ${node.type}`);
    }
    result.startIndex = node.startIndex;
    result.endIndex = node.endIndex;
    if (node.sourceCodeLocation != null) {
      result.sourceCodeLocation = node.sourceCodeLocation;
    }
    return result;
  }
  function cloneChildren(childs) {
    const children22 = childs.map((child) => cloneNode(child, true));
    for (let i = 1; i < children22.length; i++) {
      children22[i].prev = children22[i - 1];
      children22[i - 1].next = children22[i];
    }
    return children22;
  }
  var defaultOpts = {
    withStartIndices: false,
    withEndIndices: false,
    xmlMode: false
  };
  var DomHandler = class {
    /**
     * @param callback Called once parsing has completed.
     * @param options Settings for the handler.
     * @param elementCB Callback whenever a tag is closed.
     */
    constructor(callback, options, elementCB) {
      this.dom = [];
      this.root = new Document(this.dom);
      this.done = false;
      this.tagStack = [this.root];
      this.lastNode = null;
      this.parser = null;
      if (typeof options === "function") {
        elementCB = options;
        options = defaultOpts;
      }
      if (typeof callback === "object") {
        options = callback;
        callback = void 0;
      }
      this.callback = callback !== null && callback !== void 0 ? callback : null;
      this.options = options !== null && options !== void 0 ? options : defaultOpts;
      this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
    }
    onparserinit(parser) {
      this.parser = parser;
    }
    // Resets the handler back to starting state
    onreset() {
      this.dom = [];
      this.root = new Document(this.dom);
      this.done = false;
      this.tagStack = [this.root];
      this.lastNode = null;
      this.parser = null;
    }
    // Signals the handler that parsing is done
    onend() {
      if (this.done)
        return;
      this.done = true;
      this.parser = null;
      this.handleCallback(null);
    }
    onerror(error2) {
      this.handleCallback(error2);
    }
    onclosetag() {
      this.lastNode = null;
      const elem = this.tagStack.pop();
      if (this.options.withEndIndices) {
        elem.endIndex = this.parser.endIndex;
      }
      if (this.elementCB)
        this.elementCB(elem);
    }
    onopentag(name2, attribs) {
      const type2 = this.options.xmlMode ? ElementType.Tag : void 0;
      const element = new Element(name2, attribs, void 0, type2);
      this.addNode(element);
      this.tagStack.push(element);
    }
    ontext(data2) {
      const { lastNode } = this;
      if (lastNode && lastNode.type === ElementType.Text) {
        lastNode.data += data2;
        if (this.options.withEndIndices) {
          lastNode.endIndex = this.parser.endIndex;
        }
      } else {
        const node = new Text(data2);
        this.addNode(node);
        this.lastNode = node;
      }
    }
    oncomment(data2) {
      if (this.lastNode && this.lastNode.type === ElementType.Comment) {
        this.lastNode.data += data2;
        return;
      }
      const node = new Comment(data2);
      this.addNode(node);
      this.lastNode = node;
    }
    oncommentend() {
      this.lastNode = null;
    }
    oncdatastart() {
      const text22 = new Text("");
      const node = new CDATA([text22]);
      this.addNode(node);
      text22.parent = node;
      this.lastNode = text22;
    }
    oncdataend() {
      this.lastNode = null;
    }
    onprocessinginstruction(name2, data2) {
      const node = new ProcessingInstruction(name2, data2);
      this.addNode(node);
    }
    handleCallback(error2) {
      if (typeof this.callback === "function") {
        this.callback(error2, this.dom);
      } else if (error2) {
        throw error2;
      }
    }
    addNode(node) {
      const parent2 = this.tagStack[this.tagStack.length - 1];
      const previousSibling = parent2.children[parent2.children.length - 1];
      if (this.options.withStartIndices) {
        node.startIndex = this.parser.startIndex;
      }
      if (this.options.withEndIndices) {
        node.endIndex = this.parser.endIndex;
      }
      parent2.children.push(node);
      if (previousSibling) {
        node.prev = previousSibling;
        previousSibling.next = node;
      }
      node.parent = parent2;
      this.lastNode = null;
    }
  };
  var htmlDecodeTree = new Uint16Array(
    // prettier-ignore
    '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map((c) => c.charCodeAt(0))
  );
  var xmlDecodeTree = new Uint16Array(
    // prettier-ignore
    "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map((c) => c.charCodeAt(0))
  );
  var _a;
  var decodeMap = /* @__PURE__ */ new Map([
    [0, 65533],
    // C1 Unicode control character reference replacements
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376]
  ]);
  var fromCodePoint = (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
    (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
      let output = "";
      if (codePoint > 65535) {
        codePoint -= 65536;
        output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      output += String.fromCharCode(codePoint);
      return output;
    }
  );
  function replaceCodePoint(codePoint) {
    var _a22;
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
      return 65533;
    }
    return (_a22 = decodeMap.get(codePoint)) !== null && _a22 !== void 0 ? _a22 : codePoint;
  }
  var CharCodes$1;
  (function(CharCodes22) {
    CharCodes22[CharCodes22["NUM"] = 35] = "NUM";
    CharCodes22[CharCodes22["SEMI"] = 59] = "SEMI";
    CharCodes22[CharCodes22["EQUALS"] = 61] = "EQUALS";
    CharCodes22[CharCodes22["ZERO"] = 48] = "ZERO";
    CharCodes22[CharCodes22["NINE"] = 57] = "NINE";
    CharCodes22[CharCodes22["LOWER_A"] = 97] = "LOWER_A";
    CharCodes22[CharCodes22["LOWER_F"] = 102] = "LOWER_F";
    CharCodes22[CharCodes22["LOWER_X"] = 120] = "LOWER_X";
    CharCodes22[CharCodes22["LOWER_Z"] = 122] = "LOWER_Z";
    CharCodes22[CharCodes22["UPPER_A"] = 65] = "UPPER_A";
    CharCodes22[CharCodes22["UPPER_F"] = 70] = "UPPER_F";
    CharCodes22[CharCodes22["UPPER_Z"] = 90] = "UPPER_Z";
  })(CharCodes$1 || (CharCodes$1 = {}));
  var TO_LOWER_BIT = 32;
  var BinTrieFlags;
  (function(BinTrieFlags22) {
    BinTrieFlags22[BinTrieFlags22["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
    BinTrieFlags22[BinTrieFlags22["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
    BinTrieFlags22[BinTrieFlags22["JUMP_TABLE"] = 127] = "JUMP_TABLE";
  })(BinTrieFlags || (BinTrieFlags = {}));
  function isNumber(code2) {
    return code2 >= CharCodes$1.ZERO && code2 <= CharCodes$1.NINE;
  }
  function isHexadecimalCharacter(code2) {
    return code2 >= CharCodes$1.UPPER_A && code2 <= CharCodes$1.UPPER_F || code2 >= CharCodes$1.LOWER_A && code2 <= CharCodes$1.LOWER_F;
  }
  function isAsciiAlphaNumeric(code2) {
    return code2 >= CharCodes$1.UPPER_A && code2 <= CharCodes$1.UPPER_Z || code2 >= CharCodes$1.LOWER_A && code2 <= CharCodes$1.LOWER_Z || isNumber(code2);
  }
  function isEntityInAttributeInvalidEnd(code2) {
    return code2 === CharCodes$1.EQUALS || isAsciiAlphaNumeric(code2);
  }
  var EntityDecoderState;
  (function(EntityDecoderState22) {
    EntityDecoderState22[EntityDecoderState22["EntityStart"] = 0] = "EntityStart";
    EntityDecoderState22[EntityDecoderState22["NumericStart"] = 1] = "NumericStart";
    EntityDecoderState22[EntityDecoderState22["NumericDecimal"] = 2] = "NumericDecimal";
    EntityDecoderState22[EntityDecoderState22["NumericHex"] = 3] = "NumericHex";
    EntityDecoderState22[EntityDecoderState22["NamedEntity"] = 4] = "NamedEntity";
  })(EntityDecoderState || (EntityDecoderState = {}));
  var DecodingMode;
  (function(DecodingMode22) {
    DecodingMode22[DecodingMode22["Legacy"] = 0] = "Legacy";
    DecodingMode22[DecodingMode22["Strict"] = 1] = "Strict";
    DecodingMode22[DecodingMode22["Attribute"] = 2] = "Attribute";
  })(DecodingMode || (DecodingMode = {}));
  var EntityDecoder = class {
    constructor(decodeTree, emitCodePoint, errors2) {
      this.decodeTree = decodeTree;
      this.emitCodePoint = emitCodePoint;
      this.errors = errors2;
      this.state = EntityDecoderState.EntityStart;
      this.consumed = 1;
      this.result = 0;
      this.treeIndex = 0;
      this.excess = 1;
      this.decodeMode = DecodingMode.Strict;
    }
    /** Resets the instance to make it reusable. */
    startEntity(decodeMode) {
      this.decodeMode = decodeMode;
      this.state = EntityDecoderState.EntityStart;
      this.result = 0;
      this.treeIndex = 0;
      this.excess = 1;
      this.consumed = 1;
    }
    /**
     * Write an entity to the decoder. This can be called multiple times with partial entities.
     * If the entity is incomplete, the decoder will return -1.
     *
     * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
     * entity is incomplete, and resume when the next string is written.
     *
     * @param string The string containing the entity (or a continuation of the entity).
     * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    write(str, offset) {
      switch (this.state) {
        case EntityDecoderState.EntityStart: {
          if (str.charCodeAt(offset) === CharCodes$1.NUM) {
            this.state = EntityDecoderState.NumericStart;
            this.consumed += 1;
            return this.stateNumericStart(str, offset + 1);
          }
          this.state = EntityDecoderState.NamedEntity;
          return this.stateNamedEntity(str, offset);
        }
        case EntityDecoderState.NumericStart: {
          return this.stateNumericStart(str, offset);
        }
        case EntityDecoderState.NumericDecimal: {
          return this.stateNumericDecimal(str, offset);
        }
        case EntityDecoderState.NumericHex: {
          return this.stateNumericHex(str, offset);
        }
        case EntityDecoderState.NamedEntity: {
          return this.stateNamedEntity(str, offset);
        }
      }
    }
    /**
     * Switches between the numeric decimal and hexadecimal states.
     *
     * Equivalent to the `Numeric character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNumericStart(str, offset) {
      if (offset >= str.length) {
        return -1;
      }
      if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes$1.LOWER_X) {
        this.state = EntityDecoderState.NumericHex;
        this.consumed += 1;
        return this.stateNumericHex(str, offset + 1);
      }
      this.state = EntityDecoderState.NumericDecimal;
      return this.stateNumericDecimal(str, offset);
    }
    addToNumericResult(str, start2, end2, base2) {
      if (start2 !== end2) {
        const digitCount = end2 - start2;
        this.result = this.result * Math.pow(base2, digitCount) + parseInt(str.substr(start2, digitCount), base2);
        this.consumed += digitCount;
      }
    }
    /**
     * Parses a hexadecimal numeric entity.
     *
     * Equivalent to the `Hexademical character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNumericHex(str, offset) {
      const startIdx = offset;
      while (offset < str.length) {
        const char = str.charCodeAt(offset);
        if (isNumber(char) || isHexadecimalCharacter(char)) {
          offset += 1;
        } else {
          this.addToNumericResult(str, startIdx, offset, 16);
          return this.emitNumericEntity(char, 3);
        }
      }
      this.addToNumericResult(str, startIdx, offset, 16);
      return -1;
    }
    /**
     * Parses a decimal numeric entity.
     *
     * Equivalent to the `Decimal character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNumericDecimal(str, offset) {
      const startIdx = offset;
      while (offset < str.length) {
        const char = str.charCodeAt(offset);
        if (isNumber(char)) {
          offset += 1;
        } else {
          this.addToNumericResult(str, startIdx, offset, 10);
          return this.emitNumericEntity(char, 2);
        }
      }
      this.addToNumericResult(str, startIdx, offset, 10);
      return -1;
    }
    /**
     * Validate and emit a numeric entity.
     *
     * Implements the logic from the `Hexademical character reference start
     * state` and `Numeric character reference end state` in the HTML spec.
     *
     * @param lastCp The last code point of the entity. Used to see if the
     *               entity was terminated with a semicolon.
     * @param expectedLength The minimum number of characters that should be
     *                       consumed. Used to validate that at least one digit
     *                       was consumed.
     * @returns The number of characters that were consumed.
     */
    emitNumericEntity(lastCp, expectedLength) {
      var _a22;
      if (this.consumed <= expectedLength) {
        (_a22 = this.errors) === null || _a22 === void 0 ? void 0 : _a22.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      if (lastCp === CharCodes$1.SEMI) {
        this.consumed += 1;
      } else if (this.decodeMode === DecodingMode.Strict) {
        return 0;
      }
      this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
      if (this.errors) {
        if (lastCp !== CharCodes$1.SEMI) {
          this.errors.missingSemicolonAfterCharacterReference();
        }
        this.errors.validateNumericCharacterReference(this.result);
      }
      return this.consumed;
    }
    /**
     * Parses a named entity.
     *
     * Equivalent to the `Named character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNamedEntity(str, offset) {
      const { decodeTree } = this;
      let current = decodeTree[this.treeIndex];
      let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      for (; offset < str.length; offset++, this.excess++) {
        const char = str.charCodeAt(offset);
        this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
        if (this.treeIndex < 0) {
          return this.result === 0 || // If we are parsing an attribute
          this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
          (valueLength === 0 || // And there should be no invalid characters.
          isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
        }
        current = decodeTree[this.treeIndex];
        valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
        if (valueLength !== 0) {
          if (char === CharCodes$1.SEMI) {
            return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
          }
          if (this.decodeMode !== DecodingMode.Strict) {
            this.result = this.treeIndex;
            this.consumed += this.excess;
            this.excess = 0;
          }
        }
      }
      return -1;
    }
    /**
     * Emit a named entity that was not terminated with a semicolon.
     *
     * @returns The number of characters consumed.
     */
    emitNotTerminatedNamedEntity() {
      var _a22;
      const { result, decodeTree } = this;
      const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
      this.emitNamedEntityData(result, valueLength, this.consumed);
      (_a22 = this.errors) === null || _a22 === void 0 ? void 0 : _a22.missingSemicolonAfterCharacterReference();
      return this.consumed;
    }
    /**
     * Emit a named entity.
     *
     * @param result The index of the entity in the decode tree.
     * @param valueLength The number of bytes in the entity.
     * @param consumed The number of characters consumed.
     *
     * @returns The number of characters consumed.
     */
    emitNamedEntityData(result, valueLength, consumed) {
      const { decodeTree } = this;
      this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
      if (valueLength === 3) {
        this.emitCodePoint(decodeTree[result + 2], consumed);
      }
      return consumed;
    }
    /**
     * Signal to the parser that the end of the input was reached.
     *
     * Remaining data will be emitted and relevant errors will be produced.
     *
     * @returns The number of characters consumed.
     */
    end() {
      var _a22;
      switch (this.state) {
        case EntityDecoderState.NamedEntity: {
          return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
        }
        case EntityDecoderState.NumericDecimal: {
          return this.emitNumericEntity(0, 2);
        }
        case EntityDecoderState.NumericHex: {
          return this.emitNumericEntity(0, 3);
        }
        case EntityDecoderState.NumericStart: {
          (_a22 = this.errors) === null || _a22 === void 0 ? void 0 : _a22.absenceOfDigitsInNumericCharacterReference(this.consumed);
          return 0;
        }
        case EntityDecoderState.EntityStart: {
          return 0;
        }
      }
    }
  };
  function getDecoder(decodeTree) {
    let ret = "";
    const decoder = new EntityDecoder(decodeTree, (str) => ret += fromCodePoint(str));
    return function decodeWithTrie(str, decodeMode) {
      let lastIndex = 0;
      let offset = 0;
      while ((offset = str.indexOf("&", offset)) >= 0) {
        ret += str.slice(lastIndex, offset);
        decoder.startEntity(decodeMode);
        const len = decoder.write(
          str,
          // Skip the "&"
          offset + 1
        );
        if (len < 0) {
          lastIndex = offset + decoder.end();
          break;
        }
        lastIndex = offset + len;
        offset = len === 0 ? lastIndex + 1 : lastIndex;
      }
      const result = ret + str.slice(lastIndex);
      ret = "";
      return result;
    };
  }
  function determineBranch(decodeTree, current, nodeIdx, char) {
    const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
    const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
    if (branchCount === 0) {
      return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
    }
    if (jumpOffset) {
      const value = char - jumpOffset;
      return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
    }
    let lo = nodeIdx;
    let hi = lo + branchCount - 1;
    while (lo <= hi) {
      const mid = lo + hi >>> 1;
      const midVal = decodeTree[mid];
      if (midVal < char) {
        lo = mid + 1;
      } else if (midVal > char) {
        hi = mid - 1;
      } else {
        return decodeTree[mid + branchCount];
      }
    }
    return -1;
  }
  getDecoder(htmlDecodeTree);
  getDecoder(xmlDecodeTree);
  var xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
  var xmlCodeMap = /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [39, "&apos;"],
    [60, "&lt;"],
    [62, "&gt;"]
  ]);
  var getCodePoint = (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.prototype.codePointAt != null ? (str, index2) => str.codePointAt(index2) : (
      // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      (c, index2) => (c.charCodeAt(index2) & 64512) === 55296 ? (c.charCodeAt(index2) - 55296) * 1024 + c.charCodeAt(index2 + 1) - 56320 + 65536 : c.charCodeAt(index2)
    )
  );
  function encodeXML(str) {
    let ret = "";
    let lastIdx = 0;
    let match2;
    while ((match2 = xmlReplacer.exec(str)) !== null) {
      const i = match2.index;
      const char = str.charCodeAt(i);
      const next2 = xmlCodeMap.get(char);
      if (next2 !== void 0) {
        ret += str.substring(lastIdx, i) + next2;
        lastIdx = i + 1;
      } else {
        ret += `${str.substring(lastIdx, i)}&#x${getCodePoint(str, i).toString(16)};`;
        lastIdx = xmlReplacer.lastIndex += Number((char & 64512) === 55296);
      }
    }
    return ret + str.substr(lastIdx);
  }
  function getEscaper(regex, map22) {
    return function escape3(data2) {
      let match2;
      let lastIdx = 0;
      let result = "";
      while (match2 = regex.exec(data2)) {
        if (lastIdx !== match2.index) {
          result += data2.substring(lastIdx, match2.index);
        }
        result += map22.get(match2[0].charCodeAt(0));
        lastIdx = match2.index + 1;
      }
      return result + data2.substring(lastIdx);
    };
  }
  var escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [160, "&nbsp;"]
  ]));
  var escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [160, "&nbsp;"]
  ]));
  var elementNames = new Map([
    "altGlyph",
    "altGlyphDef",
    "altGlyphItem",
    "animateColor",
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "glyphRef",
    "linearGradient",
    "radialGradient",
    "textPath"
  ].map((val2) => [val2.toLowerCase(), val2]));
  var attributeNames = new Map([
    "definitionURL",
    "attributeName",
    "attributeType",
    "baseFrequency",
    "baseProfile",
    "calcMode",
    "clipPathUnits",
    "diffuseConstant",
    "edgeMode",
    "filterUnits",
    "glyphRef",
    "gradientTransform",
    "gradientUnits",
    "kernelMatrix",
    "kernelUnitLength",
    "keyPoints",
    "keySplines",
    "keyTimes",
    "lengthAdjust",
    "limitingConeAngle",
    "markerHeight",
    "markerUnits",
    "markerWidth",
    "maskContentUnits",
    "maskUnits",
    "numOctaves",
    "pathLength",
    "patternContentUnits",
    "patternTransform",
    "patternUnits",
    "pointsAtX",
    "pointsAtY",
    "pointsAtZ",
    "preserveAlpha",
    "preserveAspectRatio",
    "primitiveUnits",
    "refX",
    "refY",
    "repeatCount",
    "repeatDur",
    "requiredExtensions",
    "requiredFeatures",
    "specularConstant",
    "specularExponent",
    "spreadMethod",
    "startOffset",
    "stdDeviation",
    "stitchTiles",
    "surfaceScale",
    "systemLanguage",
    "tableValues",
    "targetX",
    "targetY",
    "textLength",
    "viewBox",
    "viewTarget",
    "xChannelSelector",
    "yChannelSelector",
    "zoomAndPan"
  ].map((val2) => [val2.toLowerCase(), val2]));
  var unencodedElements = /* @__PURE__ */ new Set([
    "style",
    "script",
    "xmp",
    "iframe",
    "noembed",
    "noframes",
    "plaintext",
    "noscript"
  ]);
  function replaceQuotes(value) {
    return value.replace(/"/g, "&quot;");
  }
  function formatAttributes(attributes2, opts) {
    var _a22;
    if (!attributes2)
      return;
    const encode3 = ((_a22 = opts.encodeEntities) !== null && _a22 !== void 0 ? _a22 : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML : escapeAttribute;
    return Object.keys(attributes2).map((key) => {
      var _a3, _b;
      const value = (_a3 = attributes2[key]) !== null && _a3 !== void 0 ? _a3 : "";
      if (opts.xmlMode === "foreign") {
        key = (_b = attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
      }
      if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
        return key;
      }
      return `${key}="${encode3(value)}"`;
    }).join(" ");
  }
  var singleTag = /* @__PURE__ */ new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
  function render$1(node, options = {}) {
    const nodes = "length" in node ? node : [node];
    let output = "";
    for (let i = 0; i < nodes.length; i++) {
      output += renderNode(nodes[i], options);
    }
    return output;
  }
  function renderNode(node, options) {
    switch (node.type) {
      case Root:
        return render$1(node.children, options);
      case Doctype:
      case Directive:
        return renderDirective(node);
      case Comment$1:
        return renderComment(node);
      case CDATA$1:
        return renderCdata(node);
      case Script:
      case Style:
      case Tag:
        return renderTag(node, options);
      case Text$1:
        return renderText(node, options);
    }
  }
  var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title"
  ]);
  var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
  function renderTag(elem, opts) {
    var _a22;
    if (opts.xmlMode === "foreign") {
      elem.name = (_a22 = elementNames.get(elem.name)) !== null && _a22 !== void 0 ? _a22 : elem.name;
      if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
        opts = { ...opts, xmlMode: false };
      }
    }
    if (!opts.xmlMode && foreignElements.has(elem.name)) {
      opts = { ...opts, xmlMode: "foreign" };
    }
    let tag = `<${elem.name}`;
    const attribs = formatAttributes(elem.attribs, opts);
    if (attribs) {
      tag += ` ${attribs}`;
    }
    if (elem.children.length === 0 && (opts.xmlMode ? (
      // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
      opts.selfClosingTags !== false
    ) : (
      // User explicitly asked for self-closing tags, even in HTML mode
      opts.selfClosingTags && singleTag.has(elem.name)
    ))) {
      if (!opts.xmlMode)
        tag += " ";
      tag += "/>";
    } else {
      tag += ">";
      if (elem.children.length > 0) {
        tag += render$1(elem.children, opts);
      }
      if (opts.xmlMode || !singleTag.has(elem.name)) {
        tag += `</${elem.name}>`;
      }
    }
    return tag;
  }
  function renderDirective(elem) {
    return `<${elem.data}>`;
  }
  function renderText(elem, opts) {
    var _a22;
    let data2 = elem.data || "";
    if (((_a22 = opts.encodeEntities) !== null && _a22 !== void 0 ? _a22 : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
      data2 = opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML(data2) : escapeText(data2);
    }
    return data2;
  }
  function renderCdata(elem) {
    return `<![CDATA[${elem.children[0].data}]]>`;
  }
  function renderComment(elem) {
    return `<!--${elem.data}-->`;
  }
  function getOuterHTML(node, options) {
    return render$1(node, options);
  }
  function getInnerHTML(node, options) {
    return hasChildren(node) ? node.children.map((node2) => getOuterHTML(node2, options)).join("") : "";
  }
  function getText(node) {
    if (Array.isArray(node))
      return node.map(getText).join("");
    if (isTag(node))
      return node.name === "br" ? "\n" : getText(node.children);
    if (isCDATA(node))
      return getText(node.children);
    if (isText(node))
      return node.data;
    return "";
  }
  function textContent(node) {
    if (Array.isArray(node))
      return node.map(textContent).join("");
    if (hasChildren(node) && !isComment(node)) {
      return textContent(node.children);
    }
    if (isText(node))
      return node.data;
    return "";
  }
  function innerText(node) {
    if (Array.isArray(node))
      return node.map(innerText).join("");
    if (hasChildren(node) && (node.type === ElementType.Tag || isCDATA(node))) {
      return innerText(node.children);
    }
    if (isText(node))
      return node.data;
    return "";
  }
  function getChildren(elem) {
    return hasChildren(elem) ? elem.children : [];
  }
  function getParent(elem) {
    return elem.parent || null;
  }
  function getSiblings(elem) {
    const parent2 = getParent(elem);
    if (parent2 != null)
      return getChildren(parent2);
    const siblings2 = [elem];
    let { prev: prev2, next: next2 } = elem;
    while (prev2 != null) {
      siblings2.unshift(prev2);
      ({ prev: prev2 } = prev2);
    }
    while (next2 != null) {
      siblings2.push(next2);
      ({ next: next2 } = next2);
    }
    return siblings2;
  }
  function getAttributeValue(elem, name2) {
    var _a22;
    return (_a22 = elem.attribs) === null || _a22 === void 0 ? void 0 : _a22[name2];
  }
  function hasAttrib(elem, name2) {
    return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name2) && elem.attribs[name2] != null;
  }
  function getName(elem) {
    return elem.name;
  }
  function nextElementSibling(elem) {
    let { next: next2 } = elem;
    while (next2 !== null && !isTag(next2))
      ({ next: next2 } = next2);
    return next2;
  }
  function prevElementSibling(elem) {
    let { prev: prev2 } = elem;
    while (prev2 !== null && !isTag(prev2))
      ({ prev: prev2 } = prev2);
    return prev2;
  }
  function removeElement(elem) {
    if (elem.prev)
      elem.prev.next = elem.next;
    if (elem.next)
      elem.next.prev = elem.prev;
    if (elem.parent) {
      const childs = elem.parent.children;
      const childsIndex = childs.lastIndexOf(elem);
      if (childsIndex >= 0) {
        childs.splice(childsIndex, 1);
      }
    }
    elem.next = null;
    elem.prev = null;
    elem.parent = null;
  }
  function replaceElement(elem, replacement) {
    const prev2 = replacement.prev = elem.prev;
    if (prev2) {
      prev2.next = replacement;
    }
    const next2 = replacement.next = elem.next;
    if (next2) {
      next2.prev = replacement;
    }
    const parent2 = replacement.parent = elem.parent;
    if (parent2) {
      const childs = parent2.children;
      childs[childs.lastIndexOf(elem)] = replacement;
      elem.parent = null;
    }
  }
  function appendChild(parent2, child) {
    removeElement(child);
    child.next = null;
    child.parent = parent2;
    if (parent2.children.push(child) > 1) {
      const sibling = parent2.children[parent2.children.length - 2];
      sibling.next = child;
      child.prev = sibling;
    } else {
      child.prev = null;
    }
  }
  function append$1(elem, next2) {
    removeElement(next2);
    const { parent: parent2 } = elem;
    const currNext = elem.next;
    next2.next = currNext;
    next2.prev = elem;
    elem.next = next2;
    next2.parent = parent2;
    if (currNext) {
      currNext.prev = next2;
      if (parent2) {
        const childs = parent2.children;
        childs.splice(childs.lastIndexOf(currNext), 0, next2);
      }
    } else if (parent2) {
      parent2.children.push(next2);
    }
  }
  function prependChild(parent2, child) {
    removeElement(child);
    child.parent = parent2;
    child.prev = null;
    if (parent2.children.unshift(child) !== 1) {
      const sibling = parent2.children[1];
      sibling.prev = child;
      child.next = sibling;
    } else {
      child.next = null;
    }
  }
  function prepend$1(elem, prev2) {
    removeElement(prev2);
    const { parent: parent2 } = elem;
    if (parent2) {
      const childs = parent2.children;
      childs.splice(childs.indexOf(elem), 0, prev2);
    }
    if (elem.prev) {
      elem.prev.next = prev2;
    }
    prev2.parent = parent2;
    prev2.prev = elem.prev;
    prev2.next = elem;
    elem.prev = prev2;
  }
  function filter$2(test2, node, recurse = true, limit = Infinity) {
    return find$2(test2, Array.isArray(node) ? node : [node], recurse, limit);
  }
  function find$2(test2, nodes, recurse, limit) {
    const result = [];
    const nodeStack = [nodes];
    const indexStack = [0];
    for (; ; ) {
      if (indexStack[0] >= nodeStack[0].length) {
        if (indexStack.length === 1) {
          return result;
        }
        nodeStack.shift();
        indexStack.shift();
        continue;
      }
      const elem = nodeStack[0][indexStack[0]++];
      if (test2(elem)) {
        result.push(elem);
        if (--limit <= 0)
          return result;
      }
      if (recurse && hasChildren(elem) && elem.children.length > 0) {
        indexStack.unshift(0);
        nodeStack.unshift(elem.children);
      }
    }
  }
  function findOneChild(test2, nodes) {
    return nodes.find(test2);
  }
  function findOne(test2, nodes, recurse = true) {
    let elem = null;
    for (let i = 0; i < nodes.length && !elem; i++) {
      const node = nodes[i];
      if (!isTag(node)) {
        continue;
      } else if (test2(node)) {
        elem = node;
      } else if (recurse && node.children.length > 0) {
        elem = findOne(test2, node.children, true);
      }
    }
    return elem;
  }
  function existsOne(test2, nodes) {
    return nodes.some((checked) => isTag(checked) && (test2(checked) || existsOne(test2, checked.children)));
  }
  function findAll(test2, nodes) {
    const result = [];
    const nodeStack = [nodes];
    const indexStack = [0];
    for (; ; ) {
      if (indexStack[0] >= nodeStack[0].length) {
        if (nodeStack.length === 1) {
          return result;
        }
        nodeStack.shift();
        indexStack.shift();
        continue;
      }
      const elem = nodeStack[0][indexStack[0]++];
      if (!isTag(elem))
        continue;
      if (test2(elem))
        result.push(elem);
      if (elem.children.length > 0) {
        indexStack.unshift(0);
        nodeStack.unshift(elem.children);
      }
    }
  }
  var Checks = {
    tag_name(name2) {
      if (typeof name2 === "function") {
        return (elem) => isTag(elem) && name2(elem.name);
      } else if (name2 === "*") {
        return isTag;
      }
      return (elem) => isTag(elem) && elem.name === name2;
    },
    tag_type(type2) {
      if (typeof type2 === "function") {
        return (elem) => type2(elem.type);
      }
      return (elem) => elem.type === type2;
    },
    tag_contains(data2) {
      if (typeof data2 === "function") {
        return (elem) => isText(elem) && data2(elem.data);
      }
      return (elem) => isText(elem) && elem.data === data2;
    }
  };
  function getAttribCheck(attrib, value) {
    if (typeof value === "function") {
      return (elem) => isTag(elem) && value(elem.attribs[attrib]);
    }
    return (elem) => isTag(elem) && elem.attribs[attrib] === value;
  }
  function combineFuncs(a, b) {
    return (elem) => a(elem) || b(elem);
  }
  function compileTest(options) {
    const funcs = Object.keys(options).map((key) => {
      const value = options[key];
      return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
    });
    return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
  }
  function testElement(options, node) {
    const test2 = compileTest(options);
    return test2 ? test2(node) : true;
  }
  function getElements(options, nodes, recurse, limit = Infinity) {
    const test2 = compileTest(options);
    return test2 ? filter$2(test2, nodes, recurse, limit) : [];
  }
  function getElementById(id2, nodes, recurse = true) {
    if (!Array.isArray(nodes))
      nodes = [nodes];
    return findOne(getAttribCheck("id", id2), nodes, recurse);
  }
  function getElementsByTagName(tagName, nodes, recurse = true, limit = Infinity) {
    return filter$2(Checks["tag_name"](tagName), nodes, recurse, limit);
  }
  function getElementsByTagType(type2, nodes, recurse = true, limit = Infinity) {
    return filter$2(Checks["tag_type"](type2), nodes, recurse, limit);
  }
  function removeSubsets(nodes) {
    let idx = nodes.length;
    while (--idx >= 0) {
      const node = nodes[idx];
      if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
        nodes.splice(idx, 1);
        continue;
      }
      for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
        if (nodes.includes(ancestor)) {
          nodes.splice(idx, 1);
          break;
        }
      }
    }
    return nodes;
  }
  var DocumentPosition;
  (function(DocumentPosition2) {
    DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
    DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
    DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
    DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
    DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
  })(DocumentPosition || (DocumentPosition = {}));
  function compareDocumentPosition(nodeA, nodeB) {
    const aParents = [];
    const bParents = [];
    if (nodeA === nodeB) {
      return 0;
    }
    let current = hasChildren(nodeA) ? nodeA : nodeA.parent;
    while (current) {
      aParents.unshift(current);
      current = current.parent;
    }
    current = hasChildren(nodeB) ? nodeB : nodeB.parent;
    while (current) {
      bParents.unshift(current);
      current = current.parent;
    }
    const maxIdx = Math.min(aParents.length, bParents.length);
    let idx = 0;
    while (idx < maxIdx && aParents[idx] === bParents[idx]) {
      idx++;
    }
    if (idx === 0) {
      return DocumentPosition.DISCONNECTED;
    }
    const sharedParent = aParents[idx - 1];
    const siblings2 = sharedParent.children;
    const aSibling = aParents[idx];
    const bSibling = bParents[idx];
    if (siblings2.indexOf(aSibling) > siblings2.indexOf(bSibling)) {
      if (sharedParent === nodeB) {
        return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
      }
      return DocumentPosition.FOLLOWING;
    }
    if (sharedParent === nodeA) {
      return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
    }
    return DocumentPosition.PRECEDING;
  }
  function uniqueSort(nodes) {
    nodes = nodes.filter((node, i, arr) => !arr.includes(node, i + 1));
    nodes.sort((a, b) => {
      const relative = compareDocumentPosition(a, b);
      if (relative & DocumentPosition.PRECEDING) {
        return -1;
      } else if (relative & DocumentPosition.FOLLOWING) {
        return 1;
      }
      return 0;
    });
    return nodes;
  }
  function getFeed(doc) {
    const feedRoot = getOneElement(isValidFeed, doc);
    return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
  }
  function getAtomFeed(feedRoot) {
    var _a22;
    const childs = feedRoot.children;
    const feed = {
      type: "atom",
      items: getElementsByTagName("entry", childs).map((item) => {
        var _a3;
        const { children: children22 } = item;
        const entry = { media: getMediaElements(children22) };
        addConditionally(entry, "id", "id", children22);
        addConditionally(entry, "title", "title", children22);
        const href2 = (_a3 = getOneElement("link", children22)) === null || _a3 === void 0 ? void 0 : _a3.attribs["href"];
        if (href2) {
          entry.link = href2;
        }
        const description = fetch2("summary", children22) || fetch2("content", children22);
        if (description) {
          entry.description = description;
        }
        const pubDate = fetch2("updated", children22);
        if (pubDate) {
          entry.pubDate = new Date(pubDate);
        }
        return entry;
      })
    };
    addConditionally(feed, "id", "id", childs);
    addConditionally(feed, "title", "title", childs);
    const href = (_a22 = getOneElement("link", childs)) === null || _a22 === void 0 ? void 0 : _a22.attribs["href"];
    if (href) {
      feed.link = href;
    }
    addConditionally(feed, "description", "subtitle", childs);
    const updated = fetch2("updated", childs);
    if (updated) {
      feed.updated = new Date(updated);
    }
    addConditionally(feed, "author", "email", childs, true);
    return feed;
  }
  function getRssFeed(feedRoot) {
    var _a22, _b;
    const childs = (_b = (_a22 = getOneElement("channel", feedRoot.children)) === null || _a22 === void 0 ? void 0 : _a22.children) !== null && _b !== void 0 ? _b : [];
    const feed = {
      type: feedRoot.name.substr(0, 3),
      id: "",
      items: getElementsByTagName("item", feedRoot.children).map((item) => {
        const { children: children22 } = item;
        const entry = { media: getMediaElements(children22) };
        addConditionally(entry, "id", "guid", children22);
        addConditionally(entry, "title", "title", children22);
        addConditionally(entry, "link", "link", children22);
        addConditionally(entry, "description", "description", children22);
        const pubDate = fetch2("pubDate", children22) || fetch2("dc:date", children22);
        if (pubDate)
          entry.pubDate = new Date(pubDate);
        return entry;
      })
    };
    addConditionally(feed, "title", "title", childs);
    addConditionally(feed, "link", "link", childs);
    addConditionally(feed, "description", "description", childs);
    const updated = fetch2("lastBuildDate", childs);
    if (updated) {
      feed.updated = new Date(updated);
    }
    addConditionally(feed, "author", "managingEditor", childs, true);
    return feed;
  }
  var MEDIA_KEYS_STRING = ["url", "type", "lang"];
  var MEDIA_KEYS_INT = [
    "fileSize",
    "bitrate",
    "framerate",
    "samplingrate",
    "channels",
    "duration",
    "height",
    "width"
  ];
  function getMediaElements(where) {
    return getElementsByTagName("media:content", where).map((elem) => {
      const { attribs } = elem;
      const media = {
        medium: attribs["medium"],
        isDefault: !!attribs["isDefault"]
      };
      for (const attrib of MEDIA_KEYS_STRING) {
        if (attribs[attrib]) {
          media[attrib] = attribs[attrib];
        }
      }
      for (const attrib of MEDIA_KEYS_INT) {
        if (attribs[attrib]) {
          media[attrib] = parseInt(attribs[attrib], 10);
        }
      }
      if (attribs["expression"]) {
        media.expression = attribs["expression"];
      }
      return media;
    });
  }
  function getOneElement(tagName, node) {
    return getElementsByTagName(tagName, node, true, 1)[0];
  }
  function fetch2(tagName, where, recurse = false) {
    return textContent(getElementsByTagName(tagName, where, recurse, 1)).trim();
  }
  function addConditionally(obj, prop2, tagName, where, recurse = false) {
    const val2 = fetch2(tagName, where, recurse);
    if (val2)
      obj[prop2] = val2;
  }
  function isValidFeed(value) {
    return value === "rss" || value === "feed" || value === "rdf:RDF";
  }
  var DomUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    get DocumentPosition() {
      return DocumentPosition;
    },
    append: append$1,
    appendChild,
    compareDocumentPosition,
    existsOne,
    filter: filter$2,
    find: find$2,
    findAll,
    findOne,
    findOneChild,
    getAttributeValue,
    getChildren,
    getElementById,
    getElements,
    getElementsByTagName,
    getElementsByTagType,
    getFeed,
    getInnerHTML,
    getName,
    getOuterHTML,
    getParent,
    getSiblings,
    getText,
    hasAttrib,
    hasChildren,
    innerText,
    isCDATA,
    isComment,
    isDocument,
    isTag,
    isText,
    nextElementSibling,
    prepend: prepend$1,
    prependChild,
    prevElementSibling,
    removeElement,
    removeSubsets,
    replaceElement,
    testElement,
    textContent,
    uniqueSort
  }, Symbol.toStringTag, { value: "Module" }));
  function render(that, dom, options) {
    if (!that)
      return "";
    return that(dom !== null && dom !== void 0 ? dom : that._root.children, null, void 0, options).toString();
  }
  function isOptions(dom, options) {
    return typeof dom === "object" && dom != null && !("length" in dom) && !("type" in dom);
  }
  function html$1(dom, options) {
    const toRender = isOptions(dom) ? (options = dom, void 0) : dom;
    const opts = {
      ...this === null || this === void 0 ? void 0 : this._options,
      ...flattenOptions(options)
    };
    return render(this, toRender, opts);
  }
  function xml(dom) {
    const options = { ...this._options, xmlMode: true };
    return render(this, dom, options);
  }
  function text$1(elements) {
    const elems = elements !== null && elements !== void 0 ? elements : this ? this.root() : [];
    let ret = "";
    for (let i = 0; i < elems.length; i++) {
      ret += textContent(elems[i]);
    }
    return ret;
  }
  function parseHTML(data2, context, keepScripts = typeof context === "boolean" ? context : false) {
    if (!data2 || typeof data2 !== "string") {
      return null;
    }
    if (typeof context === "boolean") {
      keepScripts = context;
    }
    const parsed = this.load(data2, this._options, false);
    if (!keepScripts) {
      parsed("script").remove();
    }
    return [...parsed.root()[0].children];
  }
  function root() {
    return this(this._root);
  }
  function contains(container, contained) {
    if (contained === container) {
      return false;
    }
    let next2 = contained;
    while (next2 && next2 !== next2.parent) {
      next2 = next2.parent;
      if (next2 === container) {
        return true;
      }
    }
    return false;
  }
  function extract$1(map22) {
    return this.root().extract(map22);
  }
  function merge(arr1, arr2) {
    if (!isArrayLike(arr1) || !isArrayLike(arr2)) {
      return;
    }
    let newLength = arr1.length;
    const len = +arr2.length;
    for (let i = 0; i < len; i++) {
      arr1[newLength++] = arr2[i];
    }
    arr1.length = newLength;
    return arr1;
  }
  function isArrayLike(item) {
    if (Array.isArray(item)) {
      return true;
    }
    if (typeof item !== "object" || item === null || !("length" in item) || typeof item.length !== "number" || item.length < 0) {
      return false;
    }
    for (let i = 0; i < item.length; i++) {
      if (!(i in item)) {
        return false;
      }
    }
    return true;
  }
  var staticMethods = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    contains,
    extract: extract$1,
    html: html$1,
    merge,
    parseHTML,
    root,
    text: text$1,
    xml
  }, Symbol.toStringTag, { value: "Module" }));
  function isCheerio(maybeCheerio) {
    return maybeCheerio.cheerio != null;
  }
  function camelCase(str) {
    return str.replace(/[._-](\w|$)/g, (_2, x2) => x2.toUpperCase());
  }
  function cssCase(str) {
    return str.replace(/[A-Z]/g, "-$&").toLowerCase();
  }
  function domEach(array2, fn) {
    const len = array2.length;
    for (let i = 0; i < len; i++)
      fn(array2[i], i);
    return array2;
  }
  var CharacterCodes;
  (function(CharacterCodes2) {
    CharacterCodes2[CharacterCodes2["LowerA"] = 97] = "LowerA";
    CharacterCodes2[CharacterCodes2["LowerZ"] = 122] = "LowerZ";
    CharacterCodes2[CharacterCodes2["UpperA"] = 65] = "UpperA";
    CharacterCodes2[CharacterCodes2["UpperZ"] = 90] = "UpperZ";
    CharacterCodes2[CharacterCodes2["Exclamation"] = 33] = "Exclamation";
  })(CharacterCodes || (CharacterCodes = {}));
  function isHtml(str) {
    const tagStart = str.indexOf("<");
    if (tagStart < 0 || tagStart > str.length - 3)
      return false;
    const tagChar = str.charCodeAt(tagStart + 1);
    return (tagChar >= CharacterCodes.LowerA && tagChar <= CharacterCodes.LowerZ || tagChar >= CharacterCodes.UpperA && tagChar <= CharacterCodes.UpperZ || tagChar === CharacterCodes.Exclamation) && str.includes(">", tagStart + 2);
  }
  var hasOwn = Object.prototype.hasOwnProperty;
  var rspace = /\s+/;
  var dataAttrPrefix = "data-";
  var rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i;
  var rbrace = /^{[^]*}$|^\[[^]*]$/;
  function getAttr(elem, name2, xmlMode) {
    var _a22;
    if (!elem || !isTag(elem))
      return void 0;
    (_a22 = elem.attribs) !== null && _a22 !== void 0 ? _a22 : elem.attribs = {};
    if (!name2) {
      return elem.attribs;
    }
    if (hasOwn.call(elem.attribs, name2)) {
      return !xmlMode && rboolean.test(name2) ? name2 : elem.attribs[name2];
    }
    if (elem.name === "option" && name2 === "value") {
      return text$1(elem.children);
    }
    if (elem.name === "input" && (elem.attribs["type"] === "radio" || elem.attribs["type"] === "checkbox") && name2 === "value") {
      return "on";
    }
    return void 0;
  }
  function setAttr(el, name2, value) {
    if (value === null) {
      removeAttribute(el, name2);
    } else {
      el.attribs[name2] = `${value}`;
    }
  }
  function attr(name2, value) {
    if (typeof name2 === "object" || value !== void 0) {
      if (typeof value === "function") {
        if (typeof name2 !== "string") {
          {
            throw new Error("Bad combination of arguments.");
          }
        }
        return domEach(this, (el, i) => {
          if (isTag(el))
            setAttr(el, name2, value.call(el, i, el.attribs[name2]));
        });
      }
      return domEach(this, (el) => {
        if (!isTag(el))
          return;
        if (typeof name2 === "object") {
          for (const objName of Object.keys(name2)) {
            const objValue = name2[objName];
            setAttr(el, objName, objValue);
          }
        } else {
          setAttr(el, name2, value);
        }
      });
    }
    return arguments.length > 1 ? this : getAttr(this[0], name2, this.options.xmlMode);
  }
  function getProp(el, name2, xmlMode) {
    return name2 in el ? (
      // @ts-expect-error TS doesn't like us accessing the value directly here.
      el[name2]
    ) : !xmlMode && rboolean.test(name2) ? getAttr(el, name2, false) !== void 0 : getAttr(el, name2, xmlMode);
  }
  function setProp(el, name2, value, xmlMode) {
    if (name2 in el) {
      el[name2] = value;
    } else {
      setAttr(el, name2, !xmlMode && rboolean.test(name2) ? value ? "" : null : `${value}`);
    }
  }
  function prop(name2, value) {
    var _a22;
    if (typeof name2 === "string" && value === void 0) {
      const el = this[0];
      if (!el || !isTag(el))
        return void 0;
      switch (name2) {
        case "style": {
          const property = this.css();
          const keys = Object.keys(property);
          for (let i = 0; i < keys.length; i++) {
            property[i] = keys[i];
          }
          property.length = keys.length;
          return property;
        }
        case "tagName":
        case "nodeName": {
          return el.name.toUpperCase();
        }
        case "href":
        case "src": {
          const prop2 = (_a22 = el.attribs) === null || _a22 === void 0 ? void 0 : _a22[name2];
          if (typeof URL !== "undefined" && (name2 === "href" && (el.tagName === "a" || el.tagName === "link") || name2 === "src" && (el.tagName === "img" || el.tagName === "iframe" || el.tagName === "audio" || el.tagName === "video" || el.tagName === "source")) && prop2 !== void 0 && this.options.baseURI) {
            return new URL(prop2, this.options.baseURI).href;
          }
          return prop2;
        }
        case "innerText": {
          return innerText(el);
        }
        case "textContent": {
          return textContent(el);
        }
        case "outerHTML": {
          return this.clone().wrap("<container />").parent().html();
        }
        case "innerHTML": {
          return this.html();
        }
        default: {
          return getProp(el, name2, this.options.xmlMode);
        }
      }
    }
    if (typeof name2 === "object" || value !== void 0) {
      if (typeof value === "function") {
        if (typeof name2 === "object") {
          throw new TypeError("Bad combination of arguments.");
        }
        return domEach(this, (el, i) => {
          if (isTag(el)) {
            setProp(el, name2, value.call(el, i, getProp(el, name2, this.options.xmlMode)), this.options.xmlMode);
          }
        });
      }
      return domEach(this, (el) => {
        if (!isTag(el))
          return;
        if (typeof name2 === "object") {
          for (const key of Object.keys(name2)) {
            const val2 = name2[key];
            setProp(el, key, val2, this.options.xmlMode);
          }
        } else {
          setProp(el, name2, value, this.options.xmlMode);
        }
      });
    }
    return void 0;
  }
  function setData(elem, name2, value) {
    var _a22;
    (_a22 = elem.data) !== null && _a22 !== void 0 ? _a22 : elem.data = {};
    if (typeof name2 === "object")
      Object.assign(elem.data, name2);
    else if (typeof name2 === "string" && value !== void 0) {
      elem.data[name2] = value;
    }
  }
  function readAllData(el) {
    for (const domName of Object.keys(el.attribs)) {
      if (!domName.startsWith(dataAttrPrefix)) {
        continue;
      }
      const jsName = camelCase(domName.slice(dataAttrPrefix.length));
      if (!hasOwn.call(el.data, jsName)) {
        el.data[jsName] = parseDataValue(el.attribs[domName]);
      }
    }
    return el.data;
  }
  function readData(el, name2) {
    const domName = dataAttrPrefix + cssCase(name2);
    const data2 = el.data;
    if (hasOwn.call(data2, name2)) {
      return data2[name2];
    }
    if (hasOwn.call(el.attribs, domName)) {
      return data2[name2] = parseDataValue(el.attribs[domName]);
    }
    return void 0;
  }
  function parseDataValue(value) {
    if (value === "null")
      return null;
    if (value === "true")
      return true;
    if (value === "false")
      return false;
    const num = Number(value);
    if (value === String(num))
      return num;
    if (rbrace.test(value)) {
      try {
        return JSON.parse(value);
      } catch {
      }
    }
    return value;
  }
  function data(name2, value) {
    var _a22;
    const elem = this[0];
    if (!elem || !isTag(elem))
      return;
    const dataEl = elem;
    (_a22 = dataEl.data) !== null && _a22 !== void 0 ? _a22 : dataEl.data = {};
    if (name2 == null) {
      return readAllData(dataEl);
    }
    if (typeof name2 === "object" || value !== void 0) {
      domEach(this, (el) => {
        if (isTag(el)) {
          if (typeof name2 === "object")
            setData(el, name2);
          else
            setData(el, name2, value);
        }
      });
      return this;
    }
    return readData(dataEl, name2);
  }
  function val(value) {
    const querying = arguments.length === 0;
    const element = this[0];
    if (!element || !isTag(element))
      return querying ? void 0 : this;
    switch (element.name) {
      case "textarea": {
        return this.text(value);
      }
      case "select": {
        const option = this.find("option:selected");
        if (!querying) {
          if (this.attr("multiple") == null && typeof value === "object") {
            return this;
          }
          this.find("option").removeAttr("selected");
          const values = typeof value === "object" ? value : [value];
          for (const val2 of values) {
            this.find(`option[value="${val2}"]`).attr("selected", "");
          }
          return this;
        }
        return this.attr("multiple") ? option.toArray().map((el) => text$1(el.children)) : option.attr("value");
      }
      case "input":
      case "option": {
        return querying ? this.attr("value") : this.attr("value", value);
      }
    }
    return void 0;
  }
  function removeAttribute(elem, name2) {
    if (!elem.attribs || !hasOwn.call(elem.attribs, name2))
      return;
    delete elem.attribs[name2];
  }
  function splitNames(names) {
    return names ? names.trim().split(rspace) : [];
  }
  function removeAttr(name2) {
    const attrNames = splitNames(name2);
    for (const attrName of attrNames) {
      domEach(this, (elem) => {
        if (isTag(elem))
          removeAttribute(elem, attrName);
      });
    }
    return this;
  }
  function hasClass(className) {
    return this.toArray().some((elem) => {
      const clazz = isTag(elem) && elem.attribs["class"];
      let idx = -1;
      if (clazz && className.length > 0) {
        while ((idx = clazz.indexOf(className, idx + 1)) > -1) {
          const end2 = idx + className.length;
          if ((idx === 0 || rspace.test(clazz[idx - 1])) && (end2 === clazz.length || rspace.test(clazz[end2]))) {
            return true;
          }
        }
      }
      return false;
    });
  }
  function addClass2(value) {
    if (typeof value === "function") {
      return domEach(this, (el, i) => {
        if (isTag(el)) {
          const className = el.attribs["class"] || "";
          addClass2.call([el], value.call(el, i, className));
        }
      });
    }
    if (!value || typeof value !== "string")
      return this;
    const classNames = value.split(rspace);
    const numElements = this.length;
    for (let i = 0; i < numElements; i++) {
      const el = this[i];
      if (!isTag(el))
        continue;
      const className = getAttr(el, "class", false);
      if (className) {
        let setClass = ` ${className} `;
        for (const cn of classNames) {
          const appendClass = `${cn} `;
          if (!setClass.includes(` ${appendClass}`))
            setClass += appendClass;
        }
        setAttr(el, "class", setClass.trim());
      } else {
        setAttr(el, "class", classNames.join(" ").trim());
      }
    }
    return this;
  }
  function removeClass(name2) {
    if (typeof name2 === "function") {
      return domEach(this, (el, i) => {
        if (isTag(el)) {
          removeClass.call([el], name2.call(el, i, el.attribs["class"] || ""));
        }
      });
    }
    const classes = splitNames(name2);
    const numClasses = classes.length;
    const removeAll = arguments.length === 0;
    return domEach(this, (el) => {
      if (!isTag(el))
        return;
      if (removeAll) {
        el.attribs["class"] = "";
      } else {
        const elClasses = splitNames(el.attribs["class"]);
        let changed = false;
        for (let j2 = 0; j2 < numClasses; j2++) {
          const index2 = elClasses.indexOf(classes[j2]);
          if (index2 >= 0) {
            elClasses.splice(index2, 1);
            changed = true;
            j2--;
          }
        }
        if (changed) {
          el.attribs["class"] = elClasses.join(" ");
        }
      }
    });
  }
  function toggleClass(value, stateVal) {
    if (typeof value === "function") {
      return domEach(this, (el, i) => {
        if (isTag(el)) {
          toggleClass.call([el], value.call(el, i, el.attribs["class"] || "", stateVal), stateVal);
        }
      });
    }
    if (!value || typeof value !== "string")
      return this;
    const classNames = value.split(rspace);
    const numClasses = classNames.length;
    const state = typeof stateVal === "boolean" ? stateVal ? 1 : -1 : 0;
    const numElements = this.length;
    for (let i = 0; i < numElements; i++) {
      const el = this[i];
      if (!isTag(el))
        continue;
      const elementClasses = splitNames(el.attribs["class"]);
      for (let j2 = 0; j2 < numClasses; j2++) {
        const index2 = elementClasses.indexOf(classNames[j2]);
        if (state >= 0 && index2 < 0) {
          elementClasses.push(classNames[j2]);
        } else if (state <= 0 && index2 >= 0) {
          elementClasses.splice(index2, 1);
        }
      }
      el.attribs["class"] = elementClasses.join(" ");
    }
    return this;
  }
  var Attributes = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    addClass: addClass2,
    attr,
    data,
    hasClass,
    prop,
    removeAttr,
    removeClass,
    toggleClass,
    val
  }, Symbol.toStringTag, { value: "Module" }));
  var SelectorType;
  (function(SelectorType2) {
    SelectorType2["Attribute"] = "attribute";
    SelectorType2["Pseudo"] = "pseudo";
    SelectorType2["PseudoElement"] = "pseudo-element";
    SelectorType2["Tag"] = "tag";
    SelectorType2["Universal"] = "universal";
    SelectorType2["Adjacent"] = "adjacent";
    SelectorType2["Child"] = "child";
    SelectorType2["Descendant"] = "descendant";
    SelectorType2["Parent"] = "parent";
    SelectorType2["Sibling"] = "sibling";
    SelectorType2["ColumnCombinator"] = "column-combinator";
  })(SelectorType || (SelectorType = {}));
  var AttributeAction;
  (function(AttributeAction2) {
    AttributeAction2["Any"] = "any";
    AttributeAction2["Element"] = "element";
    AttributeAction2["End"] = "end";
    AttributeAction2["Equals"] = "equals";
    AttributeAction2["Exists"] = "exists";
    AttributeAction2["Hyphen"] = "hyphen";
    AttributeAction2["Not"] = "not";
    AttributeAction2["Start"] = "start";
  })(AttributeAction || (AttributeAction = {}));
  var reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
  var reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
  var actionTypes = /* @__PURE__ */ new Map([
    [126, AttributeAction.Element],
    [94, AttributeAction.Start],
    [36, AttributeAction.End],
    [42, AttributeAction.Any],
    [33, AttributeAction.Not],
    [124, AttributeAction.Hyphen]
  ]);
  var unpackPseudos = /* @__PURE__ */ new Set([
    "has",
    "not",
    "matches",
    "is",
    "where",
    "host",
    "host-context"
  ]);
  function isTraversal$1(selector) {
    switch (selector.type) {
      case SelectorType.Adjacent:
      case SelectorType.Child:
      case SelectorType.Descendant:
      case SelectorType.Parent:
      case SelectorType.Sibling:
      case SelectorType.ColumnCombinator:
        return true;
      default:
        return false;
    }
  }
  var stripQuotesFromPseudos = /* @__PURE__ */ new Set(["contains", "icontains"]);
  function funescape(_2, escaped, escapedWhitespace) {
    const high = parseInt(escaped, 16) - 65536;
    return high !== high || escapedWhitespace ? escaped : high < 0 ? (
      // BMP codepoint
      String.fromCharCode(high + 65536)
    ) : (
      // Supplemental Plane codepoint (surrogate pair)
      String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
    );
  }
  function unescapeCSS(str) {
    return str.replace(reEscape, funescape);
  }
  function isQuote(c) {
    return c === 39 || c === 34;
  }
  function isWhitespace$1(c) {
    return c === 32 || c === 9 || c === 10 || c === 12 || c === 13;
  }
  function parse$2(selector) {
    const subselects2 = [];
    const endIndex = parseSelector(subselects2, `${selector}`, 0);
    if (endIndex < selector.length) {
      throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);
    }
    return subselects2;
  }
  function parseSelector(subselects2, selector, selectorIndex) {
    let tokens = [];
    function getName2(offset) {
      const match2 = selector.slice(selectorIndex + offset).match(reName);
      if (!match2) {
        throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);
      }
      const [name2] = match2;
      selectorIndex += offset + name2.length;
      return unescapeCSS(name2);
    }
    function stripWhitespace(offset) {
      selectorIndex += offset;
      while (selectorIndex < selector.length && isWhitespace$1(selector.charCodeAt(selectorIndex))) {
        selectorIndex++;
      }
    }
    function readValueWithParenthesis() {
      selectorIndex += 1;
      const start2 = selectorIndex;
      let counter = 1;
      for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
        if (selector.charCodeAt(selectorIndex) === 40 && !isEscaped(selectorIndex)) {
          counter++;
        } else if (selector.charCodeAt(selectorIndex) === 41 && !isEscaped(selectorIndex)) {
          counter--;
        }
      }
      if (counter) {
        throw new Error("Parenthesis not matched");
      }
      return unescapeCSS(selector.slice(start2, selectorIndex - 1));
    }
    function isEscaped(pos) {
      let slashCount = 0;
      while (selector.charCodeAt(--pos) === 92)
        slashCount++;
      return (slashCount & 1) === 1;
    }
    function ensureNotTraversal() {
      if (tokens.length > 0 && isTraversal$1(tokens[tokens.length - 1])) {
        throw new Error("Did not expect successive traversals.");
      }
    }
    function addTraversal(type2) {
      if (tokens.length > 0 && tokens[tokens.length - 1].type === SelectorType.Descendant) {
        tokens[tokens.length - 1].type = type2;
        return;
      }
      ensureNotTraversal();
      tokens.push({ type: type2 });
    }
    function addSpecialAttribute(name2, action) {
      tokens.push({
        type: SelectorType.Attribute,
        name: name2,
        action,
        value: getName2(1),
        namespace: null,
        ignoreCase: "quirks"
      });
    }
    function finalizeSubselector() {
      if (tokens.length && tokens[tokens.length - 1].type === SelectorType.Descendant) {
        tokens.pop();
      }
      if (tokens.length === 0) {
        throw new Error("Empty sub-selector");
      }
      subselects2.push(tokens);
    }
    stripWhitespace(0);
    if (selector.length === selectorIndex) {
      return selectorIndex;
    }
    loop: while (selectorIndex < selector.length) {
      const firstChar = selector.charCodeAt(selectorIndex);
      switch (firstChar) {
        case 32:
        case 9:
        case 10:
        case 12:
        case 13: {
          if (tokens.length === 0 || tokens[0].type !== SelectorType.Descendant) {
            ensureNotTraversal();
            tokens.push({ type: SelectorType.Descendant });
          }
          stripWhitespace(1);
          break;
        }
        case 62: {
          addTraversal(SelectorType.Child);
          stripWhitespace(1);
          break;
        }
        case 60: {
          addTraversal(SelectorType.Parent);
          stripWhitespace(1);
          break;
        }
        case 126: {
          addTraversal(SelectorType.Sibling);
          stripWhitespace(1);
          break;
        }
        case 43: {
          addTraversal(SelectorType.Adjacent);
          stripWhitespace(1);
          break;
        }
        case 46: {
          addSpecialAttribute("class", AttributeAction.Element);
          break;
        }
        case 35: {
          addSpecialAttribute("id", AttributeAction.Equals);
          break;
        }
        case 91: {
          stripWhitespace(1);
          let name2;
          let namespace = null;
          if (selector.charCodeAt(selectorIndex) === 124) {
            name2 = getName2(1);
          } else if (selector.startsWith("*|", selectorIndex)) {
            namespace = "*";
            name2 = getName2(2);
          } else {
            name2 = getName2(0);
            if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 61) {
              namespace = name2;
              name2 = getName2(1);
            }
          }
          stripWhitespace(0);
          let action = AttributeAction.Exists;
          const possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));
          if (possibleAction) {
            action = possibleAction;
            if (selector.charCodeAt(selectorIndex + 1) !== 61) {
              throw new Error("Expected `=`");
            }
            stripWhitespace(2);
          } else if (selector.charCodeAt(selectorIndex) === 61) {
            action = AttributeAction.Equals;
            stripWhitespace(1);
          }
          let value = "";
          let ignoreCase = null;
          if (action !== "exists") {
            if (isQuote(selector.charCodeAt(selectorIndex))) {
              const quote = selector.charCodeAt(selectorIndex);
              let sectionEnd = selectorIndex + 1;
              while (sectionEnd < selector.length && (selector.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd))) {
                sectionEnd += 1;
              }
              if (selector.charCodeAt(sectionEnd) !== quote) {
                throw new Error("Attribute value didn't end");
              }
              value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
              selectorIndex = sectionEnd + 1;
            } else {
              const valueStart = selectorIndex;
              while (selectorIndex < selector.length && (!isWhitespace$1(selector.charCodeAt(selectorIndex)) && selector.charCodeAt(selectorIndex) !== 93 || isEscaped(selectorIndex))) {
                selectorIndex += 1;
              }
              value = unescapeCSS(selector.slice(valueStart, selectorIndex));
            }
            stripWhitespace(0);
            const forceIgnore = selector.charCodeAt(selectorIndex) | 32;
            if (forceIgnore === 115) {
              ignoreCase = false;
              stripWhitespace(1);
            } else if (forceIgnore === 105) {
              ignoreCase = true;
              stripWhitespace(1);
            }
          }
          if (selector.charCodeAt(selectorIndex) !== 93) {
            throw new Error("Attribute selector didn't terminate");
          }
          selectorIndex += 1;
          const attributeSelector = {
            type: SelectorType.Attribute,
            name: name2,
            action,
            value,
            namespace,
            ignoreCase
          };
          tokens.push(attributeSelector);
          break;
        }
        case 58: {
          if (selector.charCodeAt(selectorIndex + 1) === 58) {
            tokens.push({
              type: SelectorType.PseudoElement,
              name: getName2(2).toLowerCase(),
              data: selector.charCodeAt(selectorIndex) === 40 ? readValueWithParenthesis() : null
            });
            continue;
          }
          const name2 = getName2(1).toLowerCase();
          let data2 = null;
          if (selector.charCodeAt(selectorIndex) === 40) {
            if (unpackPseudos.has(name2)) {
              if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
                throw new Error(`Pseudo-selector ${name2} cannot be quoted`);
              }
              data2 = [];
              selectorIndex = parseSelector(data2, selector, selectorIndex + 1);
              if (selector.charCodeAt(selectorIndex) !== 41) {
                throw new Error(`Missing closing parenthesis in :${name2} (${selector})`);
              }
              selectorIndex += 1;
            } else {
              data2 = readValueWithParenthesis();
              if (stripQuotesFromPseudos.has(name2)) {
                const quot = data2.charCodeAt(0);
                if (quot === data2.charCodeAt(data2.length - 1) && isQuote(quot)) {
                  data2 = data2.slice(1, -1);
                }
              }
              data2 = unescapeCSS(data2);
            }
          }
          tokens.push({ type: SelectorType.Pseudo, name: name2, data: data2 });
          break;
        }
        case 44: {
          finalizeSubselector();
          tokens = [];
          stripWhitespace(1);
          break;
        }
        default: {
          if (selector.startsWith("/*", selectorIndex)) {
            const endIndex = selector.indexOf("*/", selectorIndex + 2);
            if (endIndex < 0) {
              throw new Error("Comment was not terminated");
            }
            selectorIndex = endIndex + 2;
            if (tokens.length === 0) {
              stripWhitespace(0);
            }
            break;
          }
          let namespace = null;
          let name2;
          if (firstChar === 42) {
            selectorIndex += 1;
            name2 = "*";
          } else if (firstChar === 124) {
            name2 = "";
            if (selector.charCodeAt(selectorIndex + 1) === 124) {
              addTraversal(SelectorType.ColumnCombinator);
              stripWhitespace(2);
              break;
            }
          } else if (reName.test(selector.slice(selectorIndex))) {
            name2 = getName2(0);
          } else {
            break loop;
          }
          if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 124) {
            namespace = name2;
            if (selector.charCodeAt(selectorIndex + 1) === 42) {
              name2 = "*";
              selectorIndex += 2;
            } else {
              name2 = getName2(1);
            }
          }
          tokens.push(name2 === "*" ? { type: SelectorType.Universal, namespace } : { type: SelectorType.Tag, name: name2, namespace });
        }
      }
    }
    finalizeSubselector();
    return selectorIndex;
  }
  function getDefaultExportFromCjs(x2) {
    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
  }
  var boolbase$1;
  var hasRequiredBoolbase;
  function requireBoolbase() {
    if (hasRequiredBoolbase) return boolbase$1;
    hasRequiredBoolbase = 1;
    boolbase$1 = {
      trueFunc: function trueFunc() {
        return true;
      },
      falseFunc: function falseFunc() {
        return false;
      }
    };
    return boolbase$1;
  }
  var boolbaseExports = requireBoolbase();
  var boolbase = /* @__PURE__ */ getDefaultExportFromCjs(boolbaseExports);
  var procedure = /* @__PURE__ */ new Map([
    [SelectorType.Universal, 50],
    [SelectorType.Tag, 30],
    [SelectorType.Attribute, 1],
    [SelectorType.Pseudo, 0]
  ]);
  function isTraversal(token) {
    return !procedure.has(token.type);
  }
  var attributes = /* @__PURE__ */ new Map([
    [AttributeAction.Exists, 10],
    [AttributeAction.Equals, 8],
    [AttributeAction.Not, 7],
    [AttributeAction.Start, 6],
    [AttributeAction.End, 6],
    [AttributeAction.Any, 5]
  ]);
  function sortByProcedure(arr) {
    const procs = arr.map(getProcedure);
    for (let i = 1; i < arr.length; i++) {
      const procNew = procs[i];
      if (procNew < 0)
        continue;
      for (let j2 = i - 1; j2 >= 0 && procNew < procs[j2]; j2--) {
        const token = arr[j2 + 1];
        arr[j2 + 1] = arr[j2];
        arr[j2] = token;
        procs[j2 + 1] = procs[j2];
        procs[j2] = procNew;
      }
    }
  }
  function getProcedure(token) {
    var _a22, _b;
    let proc = (_a22 = procedure.get(token.type)) !== null && _a22 !== void 0 ? _a22 : -1;
    if (token.type === SelectorType.Attribute) {
      proc = (_b = attributes.get(token.action)) !== null && _b !== void 0 ? _b : 4;
      if (token.action === AttributeAction.Equals && token.name === "id") {
        proc = 9;
      }
      if (token.ignoreCase) {
        proc >>= 1;
      }
    } else if (token.type === SelectorType.Pseudo) {
      if (!token.data) {
        proc = 3;
      } else if (token.name === "has" || token.name === "contains") {
        proc = 0;
      } else if (Array.isArray(token.data)) {
        proc = Math.min(...token.data.map((d) => Math.min(...d.map(getProcedure))));
        if (proc < 0) {
          proc = 0;
        }
      } else {
        proc = 2;
      }
    }
    return proc;
  }
  var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
  function escapeRegex(value) {
    return value.replace(reChars, "\\$&");
  }
  var caseInsensitiveAttributes = /* @__PURE__ */ new Set([
    "accept",
    "accept-charset",
    "align",
    "alink",
    "axis",
    "bgcolor",
    "charset",
    "checked",
    "clear",
    "codetype",
    "color",
    "compact",
    "declare",
    "defer",
    "dir",
    "direction",
    "disabled",
    "enctype",
    "face",
    "frame",
    "hreflang",
    "http-equiv",
    "lang",
    "language",
    "link",
    "media",
    "method",
    "multiple",
    "nohref",
    "noresize",
    "noshade",
    "nowrap",
    "readonly",
    "rel",
    "rev",
    "rules",
    "scope",
    "scrolling",
    "selected",
    "shape",
    "target",
    "text",
    "type",
    "valign",
    "valuetype",
    "vlink"
  ]);
  function shouldIgnoreCase(selector, options) {
    return typeof selector.ignoreCase === "boolean" ? selector.ignoreCase : selector.ignoreCase === "quirks" ? !!options.quirksMode : !options.xmlMode && caseInsensitiveAttributes.has(selector.name);
  }
  var attributeRules = {
    equals(next2, data2, options) {
      const { adapter } = options;
      const { name: name2 } = data2;
      let { value } = data2;
      if (shouldIgnoreCase(data2, options)) {
        value = value.toLowerCase();
        return (elem) => {
          const attr2 = adapter.getAttributeValue(elem, name2);
          return attr2 != null && attr2.length === value.length && attr2.toLowerCase() === value && next2(elem);
        };
      }
      return (elem) => adapter.getAttributeValue(elem, name2) === value && next2(elem);
    },
    hyphen(next2, data2, options) {
      const { adapter } = options;
      const { name: name2 } = data2;
      let { value } = data2;
      const len = value.length;
      if (shouldIgnoreCase(data2, options)) {
        value = value.toLowerCase();
        return function hyphenIC(elem) {
          const attr2 = adapter.getAttributeValue(elem, name2);
          return attr2 != null && (attr2.length === len || attr2.charAt(len) === "-") && attr2.substr(0, len).toLowerCase() === value && next2(elem);
        };
      }
      return function hyphen(elem) {
        const attr2 = adapter.getAttributeValue(elem, name2);
        return attr2 != null && (attr2.length === len || attr2.charAt(len) === "-") && attr2.substr(0, len) === value && next2(elem);
      };
    },
    element(next2, data2, options) {
      const { adapter } = options;
      const { name: name2, value } = data2;
      if (/\s/.test(value)) {
        return boolbase.falseFunc;
      }
      const regex = new RegExp(`(?:^|\\s)${escapeRegex(value)}(?:$|\\s)`, shouldIgnoreCase(data2, options) ? "i" : "");
      return function element(elem) {
        const attr2 = adapter.getAttributeValue(elem, name2);
        return attr2 != null && attr2.length >= value.length && regex.test(attr2) && next2(elem);
      };
    },
    exists(next2, { name: name2 }, { adapter }) {
      return (elem) => adapter.hasAttrib(elem, name2) && next2(elem);
    },
    start(next2, data2, options) {
      const { adapter } = options;
      const { name: name2 } = data2;
      let { value } = data2;
      const len = value.length;
      if (len === 0) {
        return boolbase.falseFunc;
      }
      if (shouldIgnoreCase(data2, options)) {
        value = value.toLowerCase();
        return (elem) => {
          const attr2 = adapter.getAttributeValue(elem, name2);
          return attr2 != null && attr2.length >= len && attr2.substr(0, len).toLowerCase() === value && next2(elem);
        };
      }
      return (elem) => {
        var _a22;
        return !!((_a22 = adapter.getAttributeValue(elem, name2)) === null || _a22 === void 0 ? void 0 : _a22.startsWith(value)) && next2(elem);
      };
    },
    end(next2, data2, options) {
      const { adapter } = options;
      const { name: name2 } = data2;
      let { value } = data2;
      const len = -value.length;
      if (len === 0) {
        return boolbase.falseFunc;
      }
      if (shouldIgnoreCase(data2, options)) {
        value = value.toLowerCase();
        return (elem) => {
          var _a22;
          return ((_a22 = adapter.getAttributeValue(elem, name2)) === null || _a22 === void 0 ? void 0 : _a22.substr(len).toLowerCase()) === value && next2(elem);
        };
      }
      return (elem) => {
        var _a22;
        return !!((_a22 = adapter.getAttributeValue(elem, name2)) === null || _a22 === void 0 ? void 0 : _a22.endsWith(value)) && next2(elem);
      };
    },
    any(next2, data2, options) {
      const { adapter } = options;
      const { name: name2, value } = data2;
      if (value === "") {
        return boolbase.falseFunc;
      }
      if (shouldIgnoreCase(data2, options)) {
        const regex = new RegExp(escapeRegex(value), "i");
        return function anyIC(elem) {
          const attr2 = adapter.getAttributeValue(elem, name2);
          return attr2 != null && attr2.length >= value.length && regex.test(attr2) && next2(elem);
        };
      }
      return (elem) => {
        var _a22;
        return !!((_a22 = adapter.getAttributeValue(elem, name2)) === null || _a22 === void 0 ? void 0 : _a22.includes(value)) && next2(elem);
      };
    },
    not(next2, data2, options) {
      const { adapter } = options;
      const { name: name2 } = data2;
      let { value } = data2;
      if (value === "") {
        return (elem) => !!adapter.getAttributeValue(elem, name2) && next2(elem);
      } else if (shouldIgnoreCase(data2, options)) {
        value = value.toLowerCase();
        return (elem) => {
          const attr2 = adapter.getAttributeValue(elem, name2);
          return (attr2 == null || attr2.length !== value.length || attr2.toLowerCase() !== value) && next2(elem);
        };
      }
      return (elem) => adapter.getAttributeValue(elem, name2) !== value && next2(elem);
    }
  };
  var whitespace = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]);
  var ZERO = "0".charCodeAt(0);
  var NINE = "9".charCodeAt(0);
  function parse$1(formula) {
    formula = formula.trim().toLowerCase();
    if (formula === "even") {
      return [2, 0];
    } else if (formula === "odd") {
      return [2, 1];
    }
    let idx = 0;
    let a = 0;
    let sign = readSign();
    let number = readNumber();
    if (idx < formula.length && formula.charAt(idx) === "n") {
      idx++;
      a = sign * (number !== null && number !== void 0 ? number : 1);
      skipWhitespace();
      if (idx < formula.length) {
        sign = readSign();
        skipWhitespace();
        number = readNumber();
      } else {
        sign = number = 0;
      }
    }
    if (number === null || idx < formula.length) {
      throw new Error(`n-th rule couldn't be parsed ('${formula}')`);
    }
    return [a, sign * number];
    function readSign() {
      if (formula.charAt(idx) === "-") {
        idx++;
        return -1;
      }
      if (formula.charAt(idx) === "+") {
        idx++;
      }
      return 1;
    }
    function readNumber() {
      const start2 = idx;
      let value = 0;
      while (idx < formula.length && formula.charCodeAt(idx) >= ZERO && formula.charCodeAt(idx) <= NINE) {
        value = value * 10 + (formula.charCodeAt(idx) - ZERO);
        idx++;
      }
      return idx === start2 ? null : value;
    }
    function skipWhitespace() {
      while (idx < formula.length && whitespace.has(formula.charCodeAt(idx))) {
        idx++;
      }
    }
  }
  function compile(parsed) {
    const a = parsed[0];
    const b = parsed[1] - 1;
    if (b < 0 && a <= 0)
      return boolbase.falseFunc;
    if (a === -1)
      return (index2) => index2 <= b;
    if (a === 0)
      return (index2) => index2 === b;
    if (a === 1)
      return b < 0 ? boolbase.trueFunc : (index2) => index2 >= b;
    const absA = Math.abs(a);
    const bMod = (b % absA + absA) % absA;
    return a > 1 ? (index2) => index2 >= b && index2 % absA === bMod : (index2) => index2 <= b && index2 % absA === bMod;
  }
  function nthCheck(formula) {
    return compile(parse$1(formula));
  }
  function getChildFunc(next2, adapter) {
    return (elem) => {
      const parent2 = adapter.getParent(elem);
      return parent2 != null && adapter.isTag(parent2) && next2(elem);
    };
  }
  var filters = {
    contains(next2, text22, { adapter }) {
      return function contains2(elem) {
        return next2(elem) && adapter.getText(elem).includes(text22);
      };
    },
    icontains(next2, text22, { adapter }) {
      const itext = text22.toLowerCase();
      return function icontains(elem) {
        return next2(elem) && adapter.getText(elem).toLowerCase().includes(itext);
      };
    },
    // Location specific methods
    "nth-child"(next2, rule, { adapter, equals }) {
      const func = nthCheck(rule);
      if (func === boolbase.falseFunc)
        return boolbase.falseFunc;
      if (func === boolbase.trueFunc)
        return getChildFunc(next2, adapter);
      return function nthChild(elem) {
        const siblings2 = adapter.getSiblings(elem);
        let pos = 0;
        for (let i = 0; i < siblings2.length; i++) {
          if (equals(elem, siblings2[i]))
            break;
          if (adapter.isTag(siblings2[i])) {
            pos++;
          }
        }
        return func(pos) && next2(elem);
      };
    },
    "nth-last-child"(next2, rule, { adapter, equals }) {
      const func = nthCheck(rule);
      if (func === boolbase.falseFunc)
        return boolbase.falseFunc;
      if (func === boolbase.trueFunc)
        return getChildFunc(next2, adapter);
      return function nthLastChild(elem) {
        const siblings2 = adapter.getSiblings(elem);
        let pos = 0;
        for (let i = siblings2.length - 1; i >= 0; i--) {
          if (equals(elem, siblings2[i]))
            break;
          if (adapter.isTag(siblings2[i])) {
            pos++;
          }
        }
        return func(pos) && next2(elem);
      };
    },
    "nth-of-type"(next2, rule, { adapter, equals }) {
      const func = nthCheck(rule);
      if (func === boolbase.falseFunc)
        return boolbase.falseFunc;
      if (func === boolbase.trueFunc)
        return getChildFunc(next2, adapter);
      return function nthOfType(elem) {
        const siblings2 = adapter.getSiblings(elem);
        let pos = 0;
        for (let i = 0; i < siblings2.length; i++) {
          const currentSibling = siblings2[i];
          if (equals(elem, currentSibling))
            break;
          if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
            pos++;
          }
        }
        return func(pos) && next2(elem);
      };
    },
    "nth-last-of-type"(next2, rule, { adapter, equals }) {
      const func = nthCheck(rule);
      if (func === boolbase.falseFunc)
        return boolbase.falseFunc;
      if (func === boolbase.trueFunc)
        return getChildFunc(next2, adapter);
      return function nthLastOfType(elem) {
        const siblings2 = adapter.getSiblings(elem);
        let pos = 0;
        for (let i = siblings2.length - 1; i >= 0; i--) {
          const currentSibling = siblings2[i];
          if (equals(elem, currentSibling))
            break;
          if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
            pos++;
          }
        }
        return func(pos) && next2(elem);
      };
    },
    // TODO determine the actual root element
    root(next2, _rule, { adapter }) {
      return (elem) => {
        const parent2 = adapter.getParent(elem);
        return (parent2 == null || !adapter.isTag(parent2)) && next2(elem);
      };
    },
    scope(next2, rule, options, context) {
      const { equals } = options;
      if (!context || context.length === 0) {
        return filters["root"](next2, rule, options);
      }
      if (context.length === 1) {
        return (elem) => equals(context[0], elem) && next2(elem);
      }
      return (elem) => context.includes(elem) && next2(elem);
    },
    hover: dynamicStatePseudo("isHovered"),
    visited: dynamicStatePseudo("isVisited"),
    active: dynamicStatePseudo("isActive")
  };
  function dynamicStatePseudo(name2) {
    return function dynamicPseudo(next2, _rule, { adapter }) {
      const func = adapter[name2];
      if (typeof func !== "function") {
        return boolbase.falseFunc;
      }
      return function active(elem) {
        return func(elem) && next2(elem);
      };
    };
  }
  var pseudos = {
    empty(elem, { adapter }) {
      return !adapter.getChildren(elem).some((elem2) => (
        // FIXME: `getText` call is potentially expensive.
        adapter.isTag(elem2) || adapter.getText(elem2) !== ""
      ));
    },
    "first-child"(elem, { adapter, equals }) {
      if (adapter.prevElementSibling) {
        return adapter.prevElementSibling(elem) == null;
      }
      const firstChild = adapter.getSiblings(elem).find((elem2) => adapter.isTag(elem2));
      return firstChild != null && equals(elem, firstChild);
    },
    "last-child"(elem, { adapter, equals }) {
      const siblings2 = adapter.getSiblings(elem);
      for (let i = siblings2.length - 1; i >= 0; i--) {
        if (equals(elem, siblings2[i]))
          return true;
        if (adapter.isTag(siblings2[i]))
          break;
      }
      return false;
    },
    "first-of-type"(elem, { adapter, equals }) {
      const siblings2 = adapter.getSiblings(elem);
      const elemName = adapter.getName(elem);
      for (let i = 0; i < siblings2.length; i++) {
        const currentSibling = siblings2[i];
        if (equals(elem, currentSibling))
          return true;
        if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
          break;
        }
      }
      return false;
    },
    "last-of-type"(elem, { adapter, equals }) {
      const siblings2 = adapter.getSiblings(elem);
      const elemName = adapter.getName(elem);
      for (let i = siblings2.length - 1; i >= 0; i--) {
        const currentSibling = siblings2[i];
        if (equals(elem, currentSibling))
          return true;
        if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
          break;
        }
      }
      return false;
    },
    "only-of-type"(elem, { adapter, equals }) {
      const elemName = adapter.getName(elem);
      return adapter.getSiblings(elem).every((sibling) => equals(elem, sibling) || !adapter.isTag(sibling) || adapter.getName(sibling) !== elemName);
    },
    "only-child"(elem, { adapter, equals }) {
      return adapter.getSiblings(elem).every((sibling) => equals(elem, sibling) || !adapter.isTag(sibling));
    }
  };
  function verifyPseudoArgs(func, name2, subselect, argIndex) {
    if (subselect === null) {
      if (func.length > argIndex) {
        throw new Error(`Pseudo-class :${name2} requires an argument`);
      }
    } else if (func.length === argIndex) {
      throw new Error(`Pseudo-class :${name2} doesn't have any arguments`);
    }
  }
  var aliases = {
    // Links
    "any-link": ":is(a, area, link)[href]",
    link: ":any-link:not(:visited)",
    // Forms
    // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
    disabled: `:is(
        :is(button, input, select, textarea, optgroup, option)[disabled],
        optgroup[disabled] > option,
        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)
    )`,
    enabled: ":not(:disabled)",
    checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
    required: ":is(input, select, textarea)[required]",
    optional: ":is(input, select, textarea):not([required])",
    // JQuery extensions
    // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
    selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
    checkbox: "[type=checkbox]",
    file: "[type=file]",
    password: "[type=password]",
    radio: "[type=radio]",
    reset: "[type=reset]",
    image: "[type=image]",
    submit: "[type=submit]",
    parent: ":not(:empty)",
    header: ":is(h1, h2, h3, h4, h5, h6)",
    button: ":is(button, input[type=button])",
    input: ":is(input, textarea, select, button)",
    text: "input:is(:not([type!='']), [type=text])"
  };
  var PLACEHOLDER_ELEMENT = {};
  function ensureIsTag(next2, adapter) {
    if (next2 === boolbase.falseFunc)
      return boolbase.falseFunc;
    return (elem) => adapter.isTag(elem) && next2(elem);
  }
  function getNextSiblings(elem, adapter) {
    const siblings2 = adapter.getSiblings(elem);
    if (siblings2.length <= 1)
      return [];
    const elemIndex = siblings2.indexOf(elem);
    if (elemIndex < 0 || elemIndex === siblings2.length - 1)
      return [];
    return siblings2.slice(elemIndex + 1).filter(adapter.isTag);
  }
  function copyOptions(options) {
    return {
      xmlMode: !!options.xmlMode,
      lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,
      lowerCaseTags: !!options.lowerCaseTags,
      quirksMode: !!options.quirksMode,
      cacheResults: !!options.cacheResults,
      pseudos: options.pseudos,
      adapter: options.adapter,
      equals: options.equals
    };
  }
  var is$2 = (next2, token, options, context, compileToken2) => {
    const func = compileToken2(token, copyOptions(options), context);
    return func === boolbase.trueFunc ? next2 : func === boolbase.falseFunc ? boolbase.falseFunc : (elem) => func(elem) && next2(elem);
  };
  var subselects = {
    is: is$2,
    /**
     * `:matches` and `:where` are aliases for `:is`.
     */
    matches: is$2,
    where: is$2,
    not(next2, token, options, context, compileToken2) {
      const func = compileToken2(token, copyOptions(options), context);
      return func === boolbase.falseFunc ? next2 : func === boolbase.trueFunc ? boolbase.falseFunc : (elem) => !func(elem) && next2(elem);
    },
    has(next2, subselect, options, _context, compileToken2) {
      const { adapter } = options;
      const opts = copyOptions(options);
      opts.relativeSelector = true;
      const context = subselect.some((s) => s.some(isTraversal)) ? (
        // Used as a placeholder. Will be replaced with the actual element.
        [PLACEHOLDER_ELEMENT]
      ) : void 0;
      const compiled = compileToken2(subselect, opts, context);
      if (compiled === boolbase.falseFunc)
        return boolbase.falseFunc;
      const hasElement = ensureIsTag(compiled, adapter);
      if (context && compiled !== boolbase.trueFunc) {
        const { shouldTestNextSiblings = false } = compiled;
        return (elem) => {
          if (!next2(elem))
            return false;
          context[0] = elem;
          const childs = adapter.getChildren(elem);
          const nextElements = shouldTestNextSiblings ? [...childs, ...getNextSiblings(elem, adapter)] : childs;
          return adapter.existsOne(hasElement, nextElements);
        };
      }
      return (elem) => next2(elem) && adapter.existsOne(hasElement, adapter.getChildren(elem));
    }
  };
  function compilePseudoSelector(next2, selector, options, context, compileToken2) {
    var _a22;
    const { name: name2, data: data2 } = selector;
    if (Array.isArray(data2)) {
      if (!(name2 in subselects)) {
        throw new Error(`Unknown pseudo-class :${name2}(${data2})`);
      }
      return subselects[name2](next2, data2, options, context, compileToken2);
    }
    const userPseudo = (_a22 = options.pseudos) === null || _a22 === void 0 ? void 0 : _a22[name2];
    const stringPseudo = typeof userPseudo === "string" ? userPseudo : aliases[name2];
    if (typeof stringPseudo === "string") {
      if (data2 != null) {
        throw new Error(`Pseudo ${name2} doesn't have any arguments`);
      }
      const alias = parse$2(stringPseudo);
      return subselects["is"](next2, alias, options, context, compileToken2);
    }
    if (typeof userPseudo === "function") {
      verifyPseudoArgs(userPseudo, name2, data2, 1);
      return (elem) => userPseudo(elem, data2) && next2(elem);
    }
    if (name2 in filters) {
      return filters[name2](next2, data2, options, context);
    }
    if (name2 in pseudos) {
      const pseudo = pseudos[name2];
      verifyPseudoArgs(pseudo, name2, data2, 2);
      return (elem) => pseudo(elem, options, data2) && next2(elem);
    }
    throw new Error(`Unknown pseudo-class :${name2}`);
  }
  function getElementParent(node, adapter) {
    const parent2 = adapter.getParent(node);
    if (parent2 && adapter.isTag(parent2)) {
      return parent2;
    }
    return null;
  }
  function compileGeneralSelector(next2, selector, options, context, compileToken2) {
    const { adapter, equals } = options;
    switch (selector.type) {
      case SelectorType.PseudoElement: {
        throw new Error("Pseudo-elements are not supported by css-select");
      }
      case SelectorType.ColumnCombinator: {
        throw new Error("Column combinators are not yet supported by css-select");
      }
      case SelectorType.Attribute: {
        if (selector.namespace != null) {
          throw new Error("Namespaced attributes are not yet supported by css-select");
        }
        if (!options.xmlMode || options.lowerCaseAttributeNames) {
          selector.name = selector.name.toLowerCase();
        }
        return attributeRules[selector.action](next2, selector, options);
      }
      case SelectorType.Pseudo: {
        return compilePseudoSelector(next2, selector, options, context, compileToken2);
      }
      case SelectorType.Tag: {
        if (selector.namespace != null) {
          throw new Error("Namespaced tag names are not yet supported by css-select");
        }
        let { name: name2 } = selector;
        if (!options.xmlMode || options.lowerCaseTags) {
          name2 = name2.toLowerCase();
        }
        return function tag(elem) {
          return adapter.getName(elem) === name2 && next2(elem);
        };
      }
      case SelectorType.Descendant: {
        if (options.cacheResults === false || typeof WeakSet === "undefined") {
          return function descendant(elem) {
            let current = elem;
            while (current = getElementParent(current, adapter)) {
              if (next2(current)) {
                return true;
              }
            }
            return false;
          };
        }
        const isFalseCache = /* @__PURE__ */ new WeakSet();
        return function cachedDescendant(elem) {
          let current = elem;
          while (current = getElementParent(current, adapter)) {
            if (!isFalseCache.has(current)) {
              if (adapter.isTag(current) && next2(current)) {
                return true;
              }
              isFalseCache.add(current);
            }
          }
          return false;
        };
      }
      case "_flexibleDescendant": {
        return function flexibleDescendant(elem) {
          let current = elem;
          do {
            if (next2(current))
              return true;
          } while (current = getElementParent(current, adapter));
          return false;
        };
      }
      case SelectorType.Parent: {
        return function parent2(elem) {
          return adapter.getChildren(elem).some((elem2) => adapter.isTag(elem2) && next2(elem2));
        };
      }
      case SelectorType.Child: {
        return function child(elem) {
          const parent2 = adapter.getParent(elem);
          return parent2 != null && adapter.isTag(parent2) && next2(parent2);
        };
      }
      case SelectorType.Sibling: {
        return function sibling(elem) {
          const siblings2 = adapter.getSiblings(elem);
          for (let i = 0; i < siblings2.length; i++) {
            const currentSibling = siblings2[i];
            if (equals(elem, currentSibling))
              break;
            if (adapter.isTag(currentSibling) && next2(currentSibling)) {
              return true;
            }
          }
          return false;
        };
      }
      case SelectorType.Adjacent: {
        if (adapter.prevElementSibling) {
          return function adjacent(elem) {
            const previous = adapter.prevElementSibling(elem);
            return previous != null && next2(previous);
          };
        }
        return function adjacent(elem) {
          const siblings2 = adapter.getSiblings(elem);
          let lastElement;
          for (let i = 0; i < siblings2.length; i++) {
            const currentSibling = siblings2[i];
            if (equals(elem, currentSibling))
              break;
            if (adapter.isTag(currentSibling)) {
              lastElement = currentSibling;
            }
          }
          return !!lastElement && next2(lastElement);
        };
      }
      case SelectorType.Universal: {
        if (selector.namespace != null && selector.namespace !== "*") {
          throw new Error("Namespaced universal selectors are not yet supported by css-select");
        }
        return next2;
      }
    }
  }
  function includesScopePseudo(t) {
    return t.type === SelectorType.Pseudo && (t.name === "scope" || Array.isArray(t.data) && t.data.some((data2) => data2.some(includesScopePseudo)));
  }
  var DESCENDANT_TOKEN = { type: SelectorType.Descendant };
  var FLEXIBLE_DESCENDANT_TOKEN = {
    type: "_flexibleDescendant"
  };
  var SCOPE_TOKEN = {
    type: SelectorType.Pseudo,
    name: "scope",
    data: null
  };
  function absolutize(token, { adapter }, context) {
    const hasContext = !!(context === null || context === void 0 ? void 0 : context.every((e) => {
      const parent2 = adapter.isTag(e) && adapter.getParent(e);
      return e === PLACEHOLDER_ELEMENT || parent2 && adapter.isTag(parent2);
    }));
    for (const t of token) {
      if (t.length > 0 && isTraversal(t[0]) && t[0].type !== SelectorType.Descendant) ;
      else if (hasContext && !t.some(includesScopePseudo)) {
        t.unshift(DESCENDANT_TOKEN);
      } else {
        continue;
      }
      t.unshift(SCOPE_TOKEN);
    }
  }
  function compileToken(token, options, context) {
    var _a22;
    token.forEach(sortByProcedure);
    context = (_a22 = options.context) !== null && _a22 !== void 0 ? _a22 : context;
    const isArrayContext = Array.isArray(context);
    const finalContext = context && (Array.isArray(context) ? context : [context]);
    if (options.relativeSelector !== false) {
      absolutize(token, options, finalContext);
    } else if (token.some((t) => t.length > 0 && isTraversal(t[0]))) {
      throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");
    }
    let shouldTestNextSiblings = false;
    const query = token.map((rules) => {
      if (rules.length >= 2) {
        const [first2, second] = rules;
        if (first2.type !== SelectorType.Pseudo || first2.name !== "scope") ;
        else if (isArrayContext && second.type === SelectorType.Descendant) {
          rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
        } else if (second.type === SelectorType.Adjacent || second.type === SelectorType.Sibling) {
          shouldTestNextSiblings = true;
        }
      }
      return compileRules(rules, options, finalContext);
    }).reduce(reduceRules, boolbase.falseFunc);
    query.shouldTestNextSiblings = shouldTestNextSiblings;
    return query;
  }
  function compileRules(rules, options, context) {
    var _a22;
    return rules.reduce((previous, rule) => previous === boolbase.falseFunc ? boolbase.falseFunc : compileGeneralSelector(previous, rule, options, context, compileToken), (_a22 = options.rootFunc) !== null && _a22 !== void 0 ? _a22 : boolbase.trueFunc);
  }
  function reduceRules(a, b) {
    if (b === boolbase.falseFunc || a === boolbase.trueFunc) {
      return a;
    }
    if (a === boolbase.falseFunc || b === boolbase.trueFunc) {
      return b;
    }
    return function combine(elem) {
      return a(elem) || b(elem);
    };
  }
  var defaultEquals = (a, b) => a === b;
  var defaultOptions$1 = {
    adapter: DomUtils,
    equals: defaultEquals
  };
  function convertOptionFormats(options) {
    var _a22, _b, _c, _d;
    const opts = options !== null && options !== void 0 ? options : defaultOptions$1;
    (_a22 = opts.adapter) !== null && _a22 !== void 0 ? _a22 : opts.adapter = DomUtils;
    (_b = opts.equals) !== null && _b !== void 0 ? _b : opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals;
    return opts;
  }
  function wrapCompile(func) {
    return function addAdapter(selector, options, context) {
      const opts = convertOptionFormats(options);
      return func(selector, opts, context);
    };
  }
  var _compileToken = wrapCompile(compileToken);
  function prepareContext(elems, adapter, shouldTestNextSiblings = false) {
    if (shouldTestNextSiblings) {
      elems = appendNextSiblings(elems, adapter);
    }
    return Array.isArray(elems) ? adapter.removeSubsets(elems) : adapter.getChildren(elems);
  }
  function appendNextSiblings(elem, adapter) {
    const elems = Array.isArray(elem) ? elem.slice(0) : [elem];
    const elemsLength = elems.length;
    for (let i = 0; i < elemsLength; i++) {
      const nextSiblings = getNextSiblings(elems[i], adapter);
      elems.push(...nextSiblings);
    }
    return elems;
  }
  var filterNames = /* @__PURE__ */ new Set([
    "first",
    "last",
    "eq",
    "gt",
    "nth",
    "lt",
    "even",
    "odd"
  ]);
  function isFilter(s) {
    if (s.type !== "pseudo")
      return false;
    if (filterNames.has(s.name))
      return true;
    if (s.name === "not" && Array.isArray(s.data)) {
      return s.data.some((s2) => s2.some(isFilter));
    }
    return false;
  }
  function getLimit(filter22, data2, partLimit) {
    const num = data2 != null ? parseInt(data2, 10) : NaN;
    switch (filter22) {
      case "first":
        return 1;
      case "nth":
      case "eq":
        return isFinite(num) ? num >= 0 ? num + 1 : Infinity : 0;
      case "lt":
        return isFinite(num) ? num >= 0 ? Math.min(num, partLimit) : Infinity : 0;
      case "gt":
        return isFinite(num) ? Infinity : 0;
      case "odd":
        return 2 * partLimit;
      case "even":
        return 2 * partLimit - 1;
      case "last":
      case "not":
        return Infinity;
    }
  }
  function getDocumentRoot(node) {
    while (node.parent)
      node = node.parent;
    return node;
  }
  function groupSelectors(selectors) {
    const filteredSelectors = [];
    const plainSelectors = [];
    for (const selector of selectors) {
      if (selector.some(isFilter)) {
        filteredSelectors.push(selector);
      } else {
        plainSelectors.push(selector);
      }
    }
    return [plainSelectors, filteredSelectors];
  }
  var UNIVERSAL_SELECTOR = {
    type: SelectorType.Universal,
    namespace: null
  };
  var SCOPE_PSEUDO = {
    type: SelectorType.Pseudo,
    name: "scope",
    data: null
  };
  function is$1(element, selector, options = {}) {
    return some([element], selector, options);
  }
  function some(elements, selector, options = {}) {
    if (typeof selector === "function")
      return elements.some(selector);
    const [plain, filtered] = groupSelectors(parse$2(selector));
    return plain.length > 0 && elements.some(_compileToken(plain, options)) || filtered.some((sel) => filterBySelector(sel, elements, options).length > 0);
  }
  function filterByPosition(filter22, elems, data2, options) {
    const num = typeof data2 === "string" ? parseInt(data2, 10) : NaN;
    switch (filter22) {
      case "first":
      case "lt":
        return elems;
      case "last":
        return elems.length > 0 ? [elems[elems.length - 1]] : elems;
      case "nth":
      case "eq":
        return isFinite(num) && Math.abs(num) < elems.length ? [num < 0 ? elems[elems.length + num] : elems[num]] : [];
      case "gt":
        return isFinite(num) ? elems.slice(num + 1) : [];
      case "even":
        return elems.filter((_2, i) => i % 2 === 0);
      case "odd":
        return elems.filter((_2, i) => i % 2 === 1);
      case "not": {
        const filtered = new Set(filterParsed(data2, elems, options));
        return elems.filter((e) => !filtered.has(e));
      }
    }
  }
  function filter$1(selector, elements, options = {}) {
    return filterParsed(parse$2(selector), elements, options);
  }
  function filterParsed(selector, elements, options) {
    if (elements.length === 0)
      return [];
    const [plainSelectors, filteredSelectors] = groupSelectors(selector);
    let found;
    if (plainSelectors.length) {
      const filtered = filterElements(elements, plainSelectors, options);
      if (filteredSelectors.length === 0) {
        return filtered;
      }
      if (filtered.length) {
        found = new Set(filtered);
      }
    }
    for (let i = 0; i < filteredSelectors.length && (found === null || found === void 0 ? void 0 : found.size) !== elements.length; i++) {
      const filteredSelector = filteredSelectors[i];
      const missing = found ? elements.filter((e) => isTag(e) && !found.has(e)) : elements;
      if (missing.length === 0)
        break;
      const filtered = filterBySelector(filteredSelector, elements, options);
      if (filtered.length) {
        if (!found) {
          if (i === filteredSelectors.length - 1) {
            return filtered;
          }
          found = new Set(filtered);
        } else {
          filtered.forEach((el) => found.add(el));
        }
      }
    }
    return typeof found !== "undefined" ? found.size === elements.length ? elements : (
      // Filter elements to preserve order
      elements.filter((el) => found.has(el))
    ) : [];
  }
  function filterBySelector(selector, elements, options) {
    var _a22;
    if (selector.some(isTraversal$1)) {
      const root22 = (_a22 = options.root) !== null && _a22 !== void 0 ? _a22 : getDocumentRoot(elements[0]);
      const opts = { ...options, context: elements, relativeSelector: false };
      selector.push(SCOPE_PSEUDO);
      return findFilterElements(root22, selector, opts, true, elements.length);
    }
    return findFilterElements(elements, selector, options, false, elements.length);
  }
  function select(selector, root22, options = {}, limit = Infinity) {
    if (typeof selector === "function") {
      return find$1(root22, selector);
    }
    const [plain, filtered] = groupSelectors(parse$2(selector));
    const results = filtered.map((sel) => findFilterElements(root22, sel, options, true, limit));
    if (plain.length) {
      results.push(findElements(root22, plain, options, limit));
    }
    if (results.length === 0) {
      return [];
    }
    if (results.length === 1) {
      return results[0];
    }
    return uniqueSort(results.reduce((a, b) => [...a, ...b]));
  }
  function findFilterElements(root22, selector, options, queryForSelector, totalLimit) {
    const filterIndex = selector.findIndex(isFilter);
    const sub = selector.slice(0, filterIndex);
    const filter22 = selector[filterIndex];
    const partLimit = selector.length - 1 === filterIndex ? totalLimit : Infinity;
    const limit = getLimit(filter22.name, filter22.data, partLimit);
    if (limit === 0)
      return [];
    const elemsNoLimit = sub.length === 0 && !Array.isArray(root22) ? getChildren(root22).filter(isTag) : sub.length === 0 ? (Array.isArray(root22) ? root22 : [root22]).filter(isTag) : queryForSelector || sub.some(isTraversal$1) ? findElements(root22, [sub], options, limit) : filterElements(root22, [sub], options);
    const elems = elemsNoLimit.slice(0, limit);
    let result = filterByPosition(filter22.name, elems, filter22.data, options);
    if (result.length === 0 || selector.length === filterIndex + 1) {
      return result;
    }
    const remainingSelector = selector.slice(filterIndex + 1);
    const remainingHasTraversal = remainingSelector.some(isTraversal$1);
    if (remainingHasTraversal) {
      if (isTraversal$1(remainingSelector[0])) {
        const { type: type2 } = remainingSelector[0];
        if (type2 === SelectorType.Sibling || type2 === SelectorType.Adjacent) {
          result = prepareContext(result, DomUtils, true);
        }
        remainingSelector.unshift(UNIVERSAL_SELECTOR);
      }
      options = {
        ...options,
        // Avoid absolutizing the selector
        relativeSelector: false,
        /*
         * Add a custom root func, to make sure traversals don't match elements
         * that aren't a part of the considered tree.
         */
        rootFunc: (el) => result.includes(el)
      };
    } else if (options.rootFunc && options.rootFunc !== boolbaseExports.trueFunc) {
      options = { ...options, rootFunc: boolbaseExports.trueFunc };
    }
    return remainingSelector.some(isFilter) ? findFilterElements(result, remainingSelector, options, false, totalLimit) : remainingHasTraversal ? (
      // Query existing elements to resolve traversal.
      findElements(result, [remainingSelector], options, totalLimit)
    ) : (
      // If we don't have any more traversals, simply filter elements.
      filterElements(result, [remainingSelector], options)
    );
  }
  function findElements(root22, sel, options, limit) {
    const query = _compileToken(sel, options, root22);
    return find$1(root22, query, limit);
  }
  function find$1(root22, query, limit = Infinity) {
    const elems = prepareContext(root22, DomUtils, query.shouldTestNextSiblings);
    return find$2((node) => isTag(node) && query(node), elems, true, limit);
  }
  function filterElements(elements, sel, options) {
    const els = (Array.isArray(elements) ? elements : [elements]).filter(isTag);
    if (els.length === 0)
      return els;
    const query = _compileToken(sel, options);
    return query === boolbaseExports.trueFunc ? els : els.filter(query);
  }
  var reSiblingSelector = /^\s*[+~]/;
  function find(selectorOrHaystack) {
    if (!selectorOrHaystack) {
      return this._make([]);
    }
    if (typeof selectorOrHaystack !== "string") {
      const haystack = isCheerio(selectorOrHaystack) ? selectorOrHaystack.toArray() : [selectorOrHaystack];
      const context = this.toArray();
      return this._make(haystack.filter((elem) => context.some((node) => contains(node, elem))));
    }
    return this._findBySelector(selectorOrHaystack, Number.POSITIVE_INFINITY);
  }
  function _findBySelector(selector, limit) {
    var _a22;
    const context = this.toArray();
    const elems = reSiblingSelector.test(selector) ? context : this.children().toArray();
    const options = {
      context,
      root: (_a22 = this._root) === null || _a22 === void 0 ? void 0 : _a22[0],
      // Pass options that are recognized by `cheerio-select`
      xmlMode: this.options.xmlMode,
      lowerCaseTags: this.options.lowerCaseTags,
      lowerCaseAttributeNames: this.options.lowerCaseAttributeNames,
      pseudos: this.options.pseudos,
      quirksMode: this.options.quirksMode
    };
    return this._make(select(selector, elems, options, limit));
  }
  function _getMatcher(matchMap) {
    return function(fn, ...postFns) {
      return function(selector) {
        var _a22;
        let matched = matchMap(fn, this);
        if (selector) {
          matched = filterArray(matched, selector, this.options.xmlMode, (_a22 = this._root) === null || _a22 === void 0 ? void 0 : _a22[0]);
        }
        return this._make(
          // Post processing is only necessary if there is more than one element.
          this.length > 1 && matched.length > 1 ? postFns.reduce((elems, fn2) => fn2(elems), matched) : matched
        );
      };
    };
  }
  var _matcher = _getMatcher((fn, elems) => {
    let ret = [];
    for (let i = 0; i < elems.length; i++) {
      const value = fn(elems[i]);
      if (value.length > 0)
        ret = ret.concat(value);
    }
    return ret;
  });
  var _singleMatcher = _getMatcher((fn, elems) => {
    const ret = [];
    for (let i = 0; i < elems.length; i++) {
      const value = fn(elems[i]);
      if (value !== null) {
        ret.push(value);
      }
    }
    return ret;
  });
  function _matchUntil(nextElem, ...postFns) {
    let matches = null;
    const innerMatcher = _getMatcher((nextElem2, elems) => {
      const matched = [];
      domEach(elems, (elem) => {
        for (let next2; next2 = nextElem2(elem); elem = next2) {
          if (matches === null || matches === void 0 ? void 0 : matches(next2, matched.length))
            break;
          matched.push(next2);
        }
      });
      return matched;
    })(nextElem, ...postFns);
    return function(selector, filterSelector) {
      matches = typeof selector === "string" ? (elem) => is$1(elem, selector, this.options) : selector ? getFilterFn(selector) : null;
      const ret = innerMatcher.call(this, filterSelector);
      matches = null;
      return ret;
    };
  }
  function _removeDuplicates(elems) {
    return elems.length > 1 ? Array.from(new Set(elems)) : elems;
  }
  var parent = _singleMatcher(({ parent: parent2 }) => parent2 && !isDocument(parent2) ? parent2 : null, _removeDuplicates);
  var parents = _matcher((elem) => {
    const matched = [];
    while (elem.parent && !isDocument(elem.parent)) {
      matched.push(elem.parent);
      elem = elem.parent;
    }
    return matched;
  }, uniqueSort, (elems) => elems.reverse());
  var parentsUntil = _matchUntil(({ parent: parent2 }) => parent2 && !isDocument(parent2) ? parent2 : null, uniqueSort, (elems) => elems.reverse());
  function closest(selector) {
    var _a22;
    const set5 = [];
    if (!selector) {
      return this._make(set5);
    }
    const selectOpts = {
      xmlMode: this.options.xmlMode,
      root: (_a22 = this._root) === null || _a22 === void 0 ? void 0 : _a22[0]
    };
    const selectFn = typeof selector === "string" ? (elem) => is$1(elem, selector, selectOpts) : getFilterFn(selector);
    domEach(this, (elem) => {
      if (elem && !isDocument(elem) && !isTag(elem)) {
        elem = elem.parent;
      }
      while (elem && isTag(elem)) {
        if (selectFn(elem, 0)) {
          if (!set5.includes(elem)) {
            set5.push(elem);
          }
          break;
        }
        elem = elem.parent;
      }
    });
    return this._make(set5);
  }
  var next = _singleMatcher((elem) => nextElementSibling(elem));
  var nextAll = _matcher((elem) => {
    const matched = [];
    while (elem.next) {
      elem = elem.next;
      if (isTag(elem))
        matched.push(elem);
    }
    return matched;
  }, _removeDuplicates);
  var nextUntil = _matchUntil((el) => nextElementSibling(el), _removeDuplicates);
  var prev = _singleMatcher((elem) => prevElementSibling(elem));
  var prevAll = _matcher((elem) => {
    const matched = [];
    while (elem.prev) {
      elem = elem.prev;
      if (isTag(elem))
        matched.push(elem);
    }
    return matched;
  }, _removeDuplicates);
  var prevUntil = _matchUntil((el) => prevElementSibling(el), _removeDuplicates);
  var siblings = _matcher((elem) => getSiblings(elem).filter((el) => isTag(el) && el !== elem), uniqueSort);
  var children = _matcher((elem) => getChildren(elem).filter(isTag), _removeDuplicates);
  function contents() {
    const elems = this.toArray().reduce((newElems, elem) => hasChildren(elem) ? newElems.concat(elem.children) : newElems, []);
    return this._make(elems);
  }
  function each(fn) {
    let i = 0;
    const len = this.length;
    while (i < len && fn.call(this[i], i, this[i]) !== false)
      ++i;
    return this;
  }
  function map(fn) {
    let elems = [];
    for (let i = 0; i < this.length; i++) {
      const el = this[i];
      const val2 = fn.call(el, i, el);
      if (val2 != null) {
        elems = elems.concat(val2);
      }
    }
    return this._make(elems);
  }
  function getFilterFn(match2) {
    if (typeof match2 === "function") {
      return (el, i) => match2.call(el, i, el);
    }
    if (isCheerio(match2)) {
      return (el) => Array.prototype.includes.call(match2, el);
    }
    return function(el) {
      return match2 === el;
    };
  }
  function filter(match2) {
    var _a22;
    return this._make(filterArray(this.toArray(), match2, this.options.xmlMode, (_a22 = this._root) === null || _a22 === void 0 ? void 0 : _a22[0]));
  }
  function filterArray(nodes, match2, xmlMode, root22) {
    return typeof match2 === "string" ? filter$1(match2, nodes, { xmlMode, root: root22 }) : nodes.filter(getFilterFn(match2));
  }
  function is(selector) {
    const nodes = this.toArray();
    return typeof selector === "string" ? some(nodes.filter(isTag), selector, this.options) : selector ? nodes.some(getFilterFn(selector)) : false;
  }
  function not(match2) {
    let nodes = this.toArray();
    if (typeof match2 === "string") {
      const matches = new Set(filter$1(match2, nodes, this.options));
      nodes = nodes.filter((el) => !matches.has(el));
    } else {
      const filterFn = getFilterFn(match2);
      nodes = nodes.filter((el, i) => !filterFn(el, i));
    }
    return this._make(nodes);
  }
  function has(selectorOrHaystack) {
    return this.filter(typeof selectorOrHaystack === "string" ? (
      // Using the `:has` selector here short-circuits searches.
      `:has(${selectorOrHaystack})`
    ) : (_2, el) => this._make(el).find(selectorOrHaystack).length > 0);
  }
  function first() {
    return this.length > 1 ? this._make(this[0]) : this;
  }
  function last() {
    return this.length > 0 ? this._make(this[this.length - 1]) : this;
  }
  function eq(i) {
    var _a22;
    i = +i;
    if (i === 0 && this.length <= 1)
      return this;
    if (i < 0)
      i = this.length + i;
    return this._make((_a22 = this[i]) !== null && _a22 !== void 0 ? _a22 : []);
  }
  function get(i) {
    if (i == null) {
      return this.toArray();
    }
    return this[i < 0 ? this.length + i : i];
  }
  function toArray() {
    return Array.prototype.slice.call(this);
  }
  function index(selectorOrNeedle) {
    let $haystack;
    let needle;
    if (selectorOrNeedle == null) {
      $haystack = this.parent().children();
      needle = this[0];
    } else if (typeof selectorOrNeedle === "string") {
      $haystack = this._make(selectorOrNeedle);
      needle = this[0];
    } else {
      $haystack = this;
      needle = isCheerio(selectorOrNeedle) ? selectorOrNeedle[0] : selectorOrNeedle;
    }
    return Array.prototype.indexOf.call($haystack, needle);
  }
  function slice(start2, end2) {
    return this._make(Array.prototype.slice.call(this, start2, end2));
  }
  function end() {
    var _a22;
    return (_a22 = this.prevObject) !== null && _a22 !== void 0 ? _a22 : this._make([]);
  }
  function add(other, context) {
    const selection2 = this._make(other, context);
    const contents2 = uniqueSort([...this.get(), ...selection2.get()]);
    return this._make(contents2);
  }
  function addBack(selector) {
    return this.prevObject ? this.add(selector ? this.prevObject.filter(selector) : this.prevObject) : this;
  }
  var Traversing = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    _findBySelector,
    add,
    addBack,
    children,
    closest,
    contents,
    each,
    end,
    eq,
    filter,
    filterArray,
    find,
    first,
    get,
    has,
    index,
    is,
    last,
    map,
    next,
    nextAll,
    nextUntil,
    not,
    parent,
    parents,
    parentsUntil,
    prev,
    prevAll,
    prevUntil,
    siblings,
    slice,
    toArray
  }, Symbol.toStringTag, { value: "Module" }));
  function getParse(parser) {
    return function parse22(content, options, isDocument$1, context) {
      if (typeof Buffer !== "undefined" && Buffer.isBuffer(content)) {
        content = content.toString();
      }
      if (typeof content === "string") {
        return parser(content, options, isDocument$1, context);
      }
      const doc = content;
      if (!Array.isArray(doc) && isDocument(doc)) {
        return doc;
      }
      const root22 = new Document([]);
      update(doc, root22);
      return root22;
    };
  }
  function update(newChilds, parent2) {
    const arr = Array.isArray(newChilds) ? newChilds : [newChilds];
    if (parent2) {
      parent2.children = arr;
    } else {
      parent2 = null;
    }
    for (let i = 0; i < arr.length; i++) {
      const node = arr[i];
      if (node.parent && node.parent.children !== arr) {
        removeElement(node);
      }
      if (parent2) {
        node.prev = arr[i - 1] || null;
        node.next = arr[i + 1] || null;
      } else {
        node.prev = node.next = null;
      }
      node.parent = parent2;
    }
    return parent2;
  }
  function _makeDomArray(elem, clone2) {
    if (elem == null) {
      return [];
    }
    if (typeof elem === "string") {
      return this._parse(elem, this.options, false, null).children.slice(0);
    }
    if ("length" in elem) {
      if (elem.length === 1) {
        return this._makeDomArray(elem[0], clone2);
      }
      const result = [];
      for (let i = 0; i < elem.length; i++) {
        const el = elem[i];
        if (typeof el === "object") {
          if (el == null) {
            continue;
          }
          if (!("length" in el)) {
            result.push(clone2 ? cloneNode(el, true) : el);
            continue;
          }
        }
        result.push(...this._makeDomArray(el, clone2));
      }
      return result;
    }
    return [clone2 ? cloneNode(elem, true) : elem];
  }
  function _insert(concatenator) {
    return function(...elems) {
      const lastIdx = this.length - 1;
      return domEach(this, (el, i) => {
        if (!hasChildren(el))
          return;
        const domSrc = typeof elems[0] === "function" ? elems[0].call(el, i, this._render(el.children)) : elems;
        const dom = this._makeDomArray(domSrc, i < lastIdx);
        concatenator(dom, el.children, el);
      });
    };
  }
  function uniqueSplice(array2, spliceIdx, spliceCount, newElems, parent2) {
    var _a22, _b;
    const spliceArgs = [
      spliceIdx,
      spliceCount,
      ...newElems
    ];
    const prev2 = spliceIdx === 0 ? null : array2[spliceIdx - 1];
    const next2 = spliceIdx + spliceCount >= array2.length ? null : array2[spliceIdx + spliceCount];
    for (let idx = 0; idx < newElems.length; ++idx) {
      const node = newElems[idx];
      const oldParent = node.parent;
      if (oldParent) {
        const oldSiblings = oldParent.children;
        const prevIdx = oldSiblings.indexOf(node);
        if (prevIdx > -1) {
          oldParent.children.splice(prevIdx, 1);
          if (parent2 === oldParent && spliceIdx > prevIdx) {
            spliceArgs[0]--;
          }
        }
      }
      node.parent = parent2;
      if (node.prev) {
        node.prev.next = (_a22 = node.next) !== null && _a22 !== void 0 ? _a22 : null;
      }
      if (node.next) {
        node.next.prev = (_b = node.prev) !== null && _b !== void 0 ? _b : null;
      }
      node.prev = idx === 0 ? prev2 : newElems[idx - 1];
      node.next = idx === newElems.length - 1 ? next2 : newElems[idx + 1];
    }
    if (prev2) {
      prev2.next = newElems[0];
    }
    if (next2) {
      next2.prev = newElems[newElems.length - 1];
    }
    return array2.splice(...spliceArgs);
  }
  function appendTo(target) {
    const appendTarget = isCheerio(target) ? target : this._make(target);
    appendTarget.append(this);
    return this;
  }
  function prependTo(target) {
    const prependTarget = isCheerio(target) ? target : this._make(target);
    prependTarget.prepend(this);
    return this;
  }
  var append = _insert((dom, children22, parent2) => {
    uniqueSplice(children22, children22.length, 0, dom, parent2);
  });
  var prepend = _insert((dom, children22, parent2) => {
    uniqueSplice(children22, 0, 0, dom, parent2);
  });
  function _wrap(insert) {
    return function(wrapper) {
      const lastIdx = this.length - 1;
      const lastParent = this.parents().last();
      for (let i = 0; i < this.length; i++) {
        const el = this[i];
        const wrap2 = typeof wrapper === "function" ? wrapper.call(el, i, el) : typeof wrapper === "string" && !isHtml(wrapper) ? lastParent.find(wrapper).clone() : wrapper;
        const [wrapperDom] = this._makeDomArray(wrap2, i < lastIdx);
        if (!wrapperDom || !hasChildren(wrapperDom))
          continue;
        let elInsertLocation = wrapperDom;
        let j2 = 0;
        while (j2 < elInsertLocation.children.length) {
          const child = elInsertLocation.children[j2];
          if (isTag(child)) {
            elInsertLocation = child;
            j2 = 0;
          } else {
            j2++;
          }
        }
        insert(el, elInsertLocation, [wrapperDom]);
      }
      return this;
    };
  }
  var wrap = _wrap((el, elInsertLocation, wrapperDom) => {
    const { parent: parent2 } = el;
    if (!parent2)
      return;
    const siblings2 = parent2.children;
    const index2 = siblings2.indexOf(el);
    update([el], elInsertLocation);
    uniqueSplice(siblings2, index2, 0, wrapperDom, parent2);
  });
  var wrapInner = _wrap((el, elInsertLocation, wrapperDom) => {
    if (!hasChildren(el))
      return;
    update(el.children, elInsertLocation);
    update(wrapperDom, el);
  });
  function unwrap(selector) {
    this.parent(selector).not("body").each((_2, el) => {
      this._make(el).replaceWith(el.children);
    });
    return this;
  }
  function wrapAll(wrapper) {
    const el = this[0];
    if (el) {
      const wrap2 = this._make(typeof wrapper === "function" ? wrapper.call(el, 0, el) : wrapper).insertBefore(el);
      let elInsertLocation;
      for (let i = 0; i < wrap2.length; i++) {
        if (wrap2[i].type === "tag")
          elInsertLocation = wrap2[i];
      }
      let j2 = 0;
      while (elInsertLocation && j2 < elInsertLocation.children.length) {
        const child = elInsertLocation.children[j2];
        if (child.type === "tag") {
          elInsertLocation = child;
          j2 = 0;
        } else {
          j2++;
        }
      }
      if (elInsertLocation)
        this._make(elInsertLocation).append(this);
    }
    return this;
  }
  function after(...elems) {
    const lastIdx = this.length - 1;
    return domEach(this, (el, i) => {
      if (!hasChildren(el) || !el.parent) {
        return;
      }
      const siblings2 = el.parent.children;
      const index2 = siblings2.indexOf(el);
      if (index2 < 0)
        return;
      const domSrc = typeof elems[0] === "function" ? elems[0].call(el, i, this._render(el.children)) : elems;
      const dom = this._makeDomArray(domSrc, i < lastIdx);
      uniqueSplice(siblings2, index2 + 1, 0, dom, el.parent);
    });
  }
  function insertAfter(target) {
    if (typeof target === "string") {
      target = this._make(target);
    }
    this.remove();
    const clones = [];
    for (const el of this._makeDomArray(target)) {
      const clonedSelf = this.clone().toArray();
      const { parent: parent2 } = el;
      if (!parent2) {
        continue;
      }
      const siblings2 = parent2.children;
      const index2 = siblings2.indexOf(el);
      if (index2 < 0)
        continue;
      uniqueSplice(siblings2, index2 + 1, 0, clonedSelf, parent2);
      clones.push(...clonedSelf);
    }
    return this._make(clones);
  }
  function before(...elems) {
    const lastIdx = this.length - 1;
    return domEach(this, (el, i) => {
      if (!hasChildren(el) || !el.parent) {
        return;
      }
      const siblings2 = el.parent.children;
      const index2 = siblings2.indexOf(el);
      if (index2 < 0)
        return;
      const domSrc = typeof elems[0] === "function" ? elems[0].call(el, i, this._render(el.children)) : elems;
      const dom = this._makeDomArray(domSrc, i < lastIdx);
      uniqueSplice(siblings2, index2, 0, dom, el.parent);
    });
  }
  function insertBefore(target) {
    const targetArr = this._make(target);
    this.remove();
    const clones = [];
    domEach(targetArr, (el) => {
      const clonedSelf = this.clone().toArray();
      const { parent: parent2 } = el;
      if (!parent2) {
        return;
      }
      const siblings2 = parent2.children;
      const index2 = siblings2.indexOf(el);
      if (index2 < 0)
        return;
      uniqueSplice(siblings2, index2, 0, clonedSelf, parent2);
      clones.push(...clonedSelf);
    });
    return this._make(clones);
  }
  function remove(selector) {
    const elems = selector ? this.filter(selector) : this;
    domEach(elems, (el) => {
      removeElement(el);
      el.prev = el.next = el.parent = null;
    });
    return this;
  }
  function replaceWith(content) {
    return domEach(this, (el, i) => {
      const { parent: parent2 } = el;
      if (!parent2) {
        return;
      }
      const siblings2 = parent2.children;
      const cont = typeof content === "function" ? content.call(el, i, el) : content;
      const dom = this._makeDomArray(cont);
      update(dom, null);
      const index2 = siblings2.indexOf(el);
      uniqueSplice(siblings2, index2, 1, dom, parent2);
      if (!dom.includes(el)) {
        el.parent = el.prev = el.next = null;
      }
    });
  }
  function empty() {
    return domEach(this, (el) => {
      if (!hasChildren(el))
        return;
      for (const child of el.children) {
        child.next = child.prev = child.parent = null;
      }
      el.children.length = 0;
    });
  }
  function html(str) {
    if (str === void 0) {
      const el = this[0];
      if (!el || !hasChildren(el))
        return null;
      return this._render(el.children);
    }
    return domEach(this, (el) => {
      if (!hasChildren(el))
        return;
      for (const child of el.children) {
        child.next = child.prev = child.parent = null;
      }
      const content = isCheerio(str) ? str.toArray() : this._parse(`${str}`, this.options, false, el).children;
      update(content, el);
    });
  }
  function toString() {
    return this._render(this);
  }
  function text(str) {
    if (str === void 0) {
      return text$1(this);
    }
    if (typeof str === "function") {
      return domEach(this, (el, i) => this._make(el).text(str.call(el, i, text$1([el]))));
    }
    return domEach(this, (el) => {
      if (!hasChildren(el))
        return;
      for (const child of el.children) {
        child.next = child.prev = child.parent = null;
      }
      const textNode = new Text(`${str}`);
      update(textNode, el);
    });
  }
  function clone() {
    const clone2 = Array.prototype.map.call(this.get(), (el) => cloneNode(el, true));
    const root22 = new Document(clone2);
    for (const node of clone2) {
      node.parent = root22;
    }
    return this._make(clone2);
  }
  var Manipulation = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    _makeDomArray,
    after,
    append,
    appendTo,
    before,
    clone,
    empty,
    html,
    insertAfter,
    insertBefore,
    prepend,
    prependTo,
    remove,
    replaceWith,
    text,
    toString,
    unwrap,
    wrap,
    wrapAll,
    wrapInner
  }, Symbol.toStringTag, { value: "Module" }));
  function css(prop2, val2) {
    if (prop2 != null && val2 != null || // When `prop` is a "plain" object
    typeof prop2 === "object" && !Array.isArray(prop2)) {
      return domEach(this, (el, i) => {
        if (isTag(el)) {
          setCss(el, prop2, val2, i);
        }
      });
    }
    if (this.length === 0) {
      return void 0;
    }
    return getCss(this[0], prop2);
  }
  function setCss(el, prop2, value, idx) {
    if (typeof prop2 === "string") {
      const styles2 = getCss(el);
      const val2 = typeof value === "function" ? value.call(el, idx, styles2[prop2]) : value;
      if (val2 === "") {
        delete styles2[prop2];
      } else if (val2 != null) {
        styles2[prop2] = val2;
      }
      el.attribs["style"] = stringify(styles2);
    } else if (typeof prop2 === "object") {
      const keys = Object.keys(prop2);
      for (let i = 0; i < keys.length; i++) {
        const k = keys[i];
        setCss(el, k, prop2[k], i);
      }
    }
  }
  function getCss(el, prop2) {
    if (!el || !isTag(el))
      return;
    const styles2 = parse(el.attribs["style"]);
    if (typeof prop2 === "string") {
      return styles2[prop2];
    }
    if (Array.isArray(prop2)) {
      const newStyles = {};
      for (const item of prop2) {
        if (styles2[item] != null) {
          newStyles[item] = styles2[item];
        }
      }
      return newStyles;
    }
    return styles2;
  }
  function stringify(obj) {
    return Object.keys(obj).reduce((str, prop2) => `${str}${str ? " " : ""}${prop2}: ${obj[prop2]};`, "");
  }
  function parse(styles2) {
    styles2 = (styles2 || "").trim();
    if (!styles2)
      return {};
    const obj = {};
    let key;
    for (const str of styles2.split(";")) {
      const n = str.indexOf(":");
      if (n < 1 || n === str.length - 1) {
        const trimmed = str.trimEnd();
        if (trimmed.length > 0 && key !== void 0) {
          obj[key] += `;${trimmed}`;
        }
      } else {
        key = str.slice(0, n).trim();
        obj[key] = str.slice(n + 1).trim();
      }
    }
    return obj;
  }
  var Css = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    css
  }, Symbol.toStringTag, { value: "Module" }));
  var submittableSelector = "input,select,textarea,keygen";
  var r20 = /%20/g;
  var rCRLF = /\r?\n/g;
  function serialize() {
    const arr = this.serializeArray();
    const retArr = arr.map((data2) => `${encodeURIComponent(data2.name)}=${encodeURIComponent(data2.value)}`);
    return retArr.join("&").replace(r20, "+");
  }
  function serializeArray() {
    return this.map((_2, elem) => {
      const $elem = this._make(elem);
      if (isTag(elem) && elem.name === "form") {
        return $elem.find(submittableSelector).toArray();
      }
      return $elem.filter(submittableSelector).toArray();
    }).filter(
      // Verify elements have a name (`attr.name`) and are not disabled (`:enabled`)
      '[name!=""]:enabled:not(:submit, :button, :image, :reset, :file):matches([checked], :not(:checkbox, :radio))'
    ).map((_2, elem) => {
      var _a22;
      const $elem = this._make(elem);
      const name2 = $elem.attr("name");
      const value = (_a22 = $elem.val()) !== null && _a22 !== void 0 ? _a22 : "";
      if (Array.isArray(value)) {
        return value.map((val2) => (
          /*
           * We trim replace any line endings (e.g. `\r` or `\r\n` with `\r\n`) to guarantee consistency across platforms
           * These can occur inside of `<textarea>'s`
           */
          { name: name2, value: val2.replace(rCRLF, "\r\n") }
        ));
      }
      return { name: name2, value: value.replace(rCRLF, "\r\n") };
    }).toArray();
  }
  var Forms = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    serialize,
    serializeArray
  }, Symbol.toStringTag, { value: "Module" }));
  function getExtractDescr(descr) {
    var _a22;
    if (typeof descr === "string") {
      return { selector: descr, value: "textContent" };
    }
    return {
      selector: descr.selector,
      value: (_a22 = descr.value) !== null && _a22 !== void 0 ? _a22 : "textContent"
    };
  }
  function extract(map22) {
    const ret = {};
    for (const key in map22) {
      const descr = map22[key];
      const isArray = Array.isArray(descr);
      const { selector, value } = getExtractDescr(isArray ? descr[0] : descr);
      const fn = typeof value === "function" ? value : typeof value === "string" ? (el) => this._make(el).prop(value) : (el) => this._make(el).extract(value);
      if (isArray) {
        ret[key] = this._findBySelector(selector, Number.POSITIVE_INFINITY).map((_2, el) => fn(el, key, ret)).get();
      } else {
        const $ = this._findBySelector(selector, 1);
        ret[key] = $.length > 0 ? fn($[0], key, ret) : void 0;
      }
    }
    return ret;
  }
  var Extract = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    extract
  }, Symbol.toStringTag, { value: "Module" }));
  var Cheerio = class {
    /**
     * Instance of cheerio. Methods are specified in the modules. Usage of this
     * constructor is not recommended. Please use `$.load` instead.
     *
     * @private
     * @param elements - The new selection.
     * @param root - Sets the root node.
     * @param options - Options for the instance.
     */
    constructor(elements, root22, options) {
      this.length = 0;
      this.options = options;
      this._root = root22;
      if (elements) {
        for (let idx = 0; idx < elements.length; idx++) {
          this[idx] = elements[idx];
        }
        this.length = elements.length;
      }
    }
  };
  Cheerio.prototype.cheerio = "[cheerio object]";
  Cheerio.prototype.splice = Array.prototype.splice;
  Cheerio.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
  Object.assign(Cheerio.prototype, Attributes, Traversing, Manipulation, Css, Forms, Extract);
  function getLoad(parse22, render2) {
    return function load2(content, options, isDocument22 = true) {
      if (content == null) {
        throw new Error("cheerio.load() expects a string");
      }
      const internalOpts = flattenOptions(options);
      const initialRoot = parse22(content, internalOpts, isDocument22, null);
      class LoadedCheerio extends Cheerio {
        _make(selector, context) {
          const cheerio = initialize(selector, context);
          cheerio.prevObject = this;
          return cheerio;
        }
        _parse(content2, options2, isDocument3, context) {
          return parse22(content2, options2, isDocument3, context);
        }
        _render(dom) {
          return render2(dom, this.options);
        }
      }
      function initialize(selector, context, root22 = initialRoot, opts) {
        if (selector && isCheerio(selector))
          return selector;
        const options2 = flattenOptions(opts, internalOpts);
        const r = typeof root22 === "string" ? [parse22(root22, options2, false, null)] : "length" in root22 ? root22 : [root22];
        const rootInstance = isCheerio(r) ? r : new LoadedCheerio(r, null, options2);
        rootInstance._root = rootInstance;
        if (!selector) {
          return new LoadedCheerio(void 0, rootInstance, options2);
        }
        const elements = typeof selector === "string" && isHtml(selector) ? (
          // $(<html>)
          parse22(selector, options2, false, null).children
        ) : isNode(selector) ? (
          // $(dom)
          [selector]
        ) : Array.isArray(selector) ? (
          // $([dom])
          selector
        ) : void 0;
        const instance = new LoadedCheerio(elements, rootInstance, options2);
        if (elements) {
          return instance;
        }
        if (typeof selector !== "string") {
          throw new TypeError("Unexpected type of selector");
        }
        let search = selector;
        const searchContext = context ? (
          // If we don't have a context, maybe we have a root, from loading
          typeof context === "string" ? isHtml(context) ? (
            // $('li', '<ul>...</ul>')
            new LoadedCheerio([parse22(context, options2, false, null)], rootInstance, options2)
          ) : (
            // $('li', 'ul')
            (search = `${context} ${search}`, rootInstance)
          ) : isCheerio(context) ? (
            // $('li', $)
            context
          ) : (
            // $('li', node), $('li', [nodes])
            new LoadedCheerio(Array.isArray(context) ? context : [context], rootInstance, options2)
          )
        ) : rootInstance;
        if (!searchContext)
          return instance;
        return searchContext.find(search);
      }
      Object.assign(initialize, staticMethods, {
        load: load2,
        // `_root` and `_options` are used in static methods.
        _root: initialRoot,
        _options: internalOpts,
        // Add `fn` for plugins
        fn: LoadedCheerio.prototype,
        // Add the prototype here to maintain `instanceof` behavior.
        prototype: LoadedCheerio.prototype
      });
      return initialize;
    };
  }
  function isNode(obj) {
    return !!obj.name || obj.type === "root" || obj.type === "text" || obj.type === "comment";
  }
  var CharCodes;
  (function(CharCodes22) {
    CharCodes22[CharCodes22["Tab"] = 9] = "Tab";
    CharCodes22[CharCodes22["NewLine"] = 10] = "NewLine";
    CharCodes22[CharCodes22["FormFeed"] = 12] = "FormFeed";
    CharCodes22[CharCodes22["CarriageReturn"] = 13] = "CarriageReturn";
    CharCodes22[CharCodes22["Space"] = 32] = "Space";
    CharCodes22[CharCodes22["ExclamationMark"] = 33] = "ExclamationMark";
    CharCodes22[CharCodes22["Number"] = 35] = "Number";
    CharCodes22[CharCodes22["Amp"] = 38] = "Amp";
    CharCodes22[CharCodes22["SingleQuote"] = 39] = "SingleQuote";
    CharCodes22[CharCodes22["DoubleQuote"] = 34] = "DoubleQuote";
    CharCodes22[CharCodes22["Dash"] = 45] = "Dash";
    CharCodes22[CharCodes22["Slash"] = 47] = "Slash";
    CharCodes22[CharCodes22["Zero"] = 48] = "Zero";
    CharCodes22[CharCodes22["Nine"] = 57] = "Nine";
    CharCodes22[CharCodes22["Semi"] = 59] = "Semi";
    CharCodes22[CharCodes22["Lt"] = 60] = "Lt";
    CharCodes22[CharCodes22["Eq"] = 61] = "Eq";
    CharCodes22[CharCodes22["Gt"] = 62] = "Gt";
    CharCodes22[CharCodes22["Questionmark"] = 63] = "Questionmark";
    CharCodes22[CharCodes22["UpperA"] = 65] = "UpperA";
    CharCodes22[CharCodes22["LowerA"] = 97] = "LowerA";
    CharCodes22[CharCodes22["UpperF"] = 70] = "UpperF";
    CharCodes22[CharCodes22["LowerF"] = 102] = "LowerF";
    CharCodes22[CharCodes22["UpperZ"] = 90] = "UpperZ";
    CharCodes22[CharCodes22["LowerZ"] = 122] = "LowerZ";
    CharCodes22[CharCodes22["LowerX"] = 120] = "LowerX";
    CharCodes22[CharCodes22["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
  })(CharCodes || (CharCodes = {}));
  var State;
  (function(State2) {
    State2[State2["Text"] = 1] = "Text";
    State2[State2["BeforeTagName"] = 2] = "BeforeTagName";
    State2[State2["InTagName"] = 3] = "InTagName";
    State2[State2["InSelfClosingTag"] = 4] = "InSelfClosingTag";
    State2[State2["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
    State2[State2["InClosingTagName"] = 6] = "InClosingTagName";
    State2[State2["AfterClosingTagName"] = 7] = "AfterClosingTagName";
    State2[State2["BeforeAttributeName"] = 8] = "BeforeAttributeName";
    State2[State2["InAttributeName"] = 9] = "InAttributeName";
    State2[State2["AfterAttributeName"] = 10] = "AfterAttributeName";
    State2[State2["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
    State2[State2["InAttributeValueDq"] = 12] = "InAttributeValueDq";
    State2[State2["InAttributeValueSq"] = 13] = "InAttributeValueSq";
    State2[State2["InAttributeValueNq"] = 14] = "InAttributeValueNq";
    State2[State2["BeforeDeclaration"] = 15] = "BeforeDeclaration";
    State2[State2["InDeclaration"] = 16] = "InDeclaration";
    State2[State2["InProcessingInstruction"] = 17] = "InProcessingInstruction";
    State2[State2["BeforeComment"] = 18] = "BeforeComment";
    State2[State2["CDATASequence"] = 19] = "CDATASequence";
    State2[State2["InSpecialComment"] = 20] = "InSpecialComment";
    State2[State2["InCommentLike"] = 21] = "InCommentLike";
    State2[State2["BeforeSpecialS"] = 22] = "BeforeSpecialS";
    State2[State2["BeforeSpecialT"] = 23] = "BeforeSpecialT";
    State2[State2["SpecialStartSequence"] = 24] = "SpecialStartSequence";
    State2[State2["InSpecialTag"] = 25] = "InSpecialTag";
    State2[State2["InEntity"] = 26] = "InEntity";
  })(State || (State = {}));
  function isWhitespace(c) {
    return c === CharCodes.Space || c === CharCodes.NewLine || c === CharCodes.Tab || c === CharCodes.FormFeed || c === CharCodes.CarriageReturn;
  }
  function isEndOfTagSection(c) {
    return c === CharCodes.Slash || c === CharCodes.Gt || isWhitespace(c);
  }
  function isASCIIAlpha(c) {
    return c >= CharCodes.LowerA && c <= CharCodes.LowerZ || c >= CharCodes.UpperA && c <= CharCodes.UpperZ;
  }
  var QuoteType;
  (function(QuoteType2) {
    QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
    QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
    QuoteType2[QuoteType2["Single"] = 2] = "Single";
    QuoteType2[QuoteType2["Double"] = 3] = "Double";
  })(QuoteType || (QuoteType = {}));
  var Sequences = {
    Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
    // CDATA[
    CdataEnd: new Uint8Array([93, 93, 62]),
    // ]]>
    CommentEnd: new Uint8Array([45, 45, 62]),
    // `-->`
    ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
    // `<\/script`
    StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
    // `</style`
    TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
    // `</title`
    TextareaEnd: new Uint8Array([
      60,
      47,
      116,
      101,
      120,
      116,
      97,
      114,
      101,
      97
    ])
    // `</textarea`
  };
  var Tokenizer = class {
    constructor({ xmlMode = false, decodeEntities = true }, cbs) {
      this.cbs = cbs;
      this.state = State.Text;
      this.buffer = "";
      this.sectionStart = 0;
      this.index = 0;
      this.entityStart = 0;
      this.baseState = State.Text;
      this.isSpecial = false;
      this.running = true;
      this.offset = 0;
      this.currentSequence = void 0;
      this.sequenceIndex = 0;
      this.xmlMode = xmlMode;
      this.decodeEntities = decodeEntities;
      this.entityDecoder = new EntityDecoder(xmlMode ? xmlDecodeTree : htmlDecodeTree, (cp, consumed) => this.emitCodePoint(cp, consumed));
    }
    reset() {
      this.state = State.Text;
      this.buffer = "";
      this.sectionStart = 0;
      this.index = 0;
      this.baseState = State.Text;
      this.currentSequence = void 0;
      this.running = true;
      this.offset = 0;
    }
    write(chunk) {
      this.offset += this.buffer.length;
      this.buffer = chunk;
      this.parse();
    }
    end() {
      if (this.running)
        this.finish();
    }
    pause() {
      this.running = false;
    }
    resume() {
      this.running = true;
      if (this.index < this.buffer.length + this.offset) {
        this.parse();
      }
    }
    stateText(c) {
      if (c === CharCodes.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes.Lt)) {
        if (this.index > this.sectionStart) {
          this.cbs.ontext(this.sectionStart, this.index);
        }
        this.state = State.BeforeTagName;
        this.sectionStart = this.index;
      } else if (this.decodeEntities && c === CharCodes.Amp) {
        this.startEntity();
      }
    }
    stateSpecialStartSequence(c) {
      const isEnd = this.sequenceIndex === this.currentSequence.length;
      const isMatch = isEnd ? (
        // If we are at the end of the sequence, make sure the tag name has ended
        isEndOfTagSection(c)
      ) : (
        // Otherwise, do a case-insensitive comparison
        (c | 32) === this.currentSequence[this.sequenceIndex]
      );
      if (!isMatch) {
        this.isSpecial = false;
      } else if (!isEnd) {
        this.sequenceIndex++;
        return;
      }
      this.sequenceIndex = 0;
      this.state = State.InTagName;
      this.stateInTagName(c);
    }
    /** Look for an end tag. For <title> tags, also decode entities. */
    stateInSpecialTag(c) {
      if (this.sequenceIndex === this.currentSequence.length) {
        if (c === CharCodes.Gt || isWhitespace(c)) {
          const endOfText = this.index - this.currentSequence.length;
          if (this.sectionStart < endOfText) {
            const actualIndex = this.index;
            this.index = endOfText;
            this.cbs.ontext(this.sectionStart, endOfText);
            this.index = actualIndex;
          }
          this.isSpecial = false;
          this.sectionStart = endOfText + 2;
          this.stateInClosingTagName(c);
          return;
        }
        this.sequenceIndex = 0;
      }
      if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
        this.sequenceIndex += 1;
      } else if (this.sequenceIndex === 0) {
        if (this.currentSequence === Sequences.TitleEnd) {
          if (this.decodeEntities && c === CharCodes.Amp) {
            this.startEntity();
          }
        } else if (this.fastForwardTo(CharCodes.Lt)) {
          this.sequenceIndex = 1;
        }
      } else {
        this.sequenceIndex = Number(c === CharCodes.Lt);
      }
    }
    stateCDATASequence(c) {
      if (c === Sequences.Cdata[this.sequenceIndex]) {
        if (++this.sequenceIndex === Sequences.Cdata.length) {
          this.state = State.InCommentLike;
          this.currentSequence = Sequences.CdataEnd;
          this.sequenceIndex = 0;
          this.sectionStart = this.index + 1;
        }
      } else {
        this.sequenceIndex = 0;
        this.state = State.InDeclaration;
        this.stateInDeclaration(c);
      }
    }
    /**
     * When we wait for one specific character, we can speed things up
     * by skipping through the buffer until we find it.
     *
     * @returns Whether the character was found.
     */
    fastForwardTo(c) {
      while (++this.index < this.buffer.length + this.offset) {
        if (this.buffer.charCodeAt(this.index - this.offset) === c) {
          return true;
        }
      }
      this.index = this.buffer.length + this.offset - 1;
      return false;
    }
    /**
     * Comments and CDATA end with `-->` and `]]>`.
     *
     * Their common qualities are:
     * - Their end sequences have a distinct character they start with.
     * - That character is then repeated, so we have to check multiple repeats.
     * - All characters but the start character of the sequence can be skipped.
     */
    stateInCommentLike(c) {
      if (c === this.currentSequence[this.sequenceIndex]) {
        if (++this.sequenceIndex === this.currentSequence.length) {
          if (this.currentSequence === Sequences.CdataEnd) {
            this.cbs.oncdata(this.sectionStart, this.index, 2);
          } else {
            this.cbs.oncomment(this.sectionStart, this.index, 2);
          }
          this.sequenceIndex = 0;
          this.sectionStart = this.index + 1;
          this.state = State.Text;
        }
      } else if (this.sequenceIndex === 0) {
        if (this.fastForwardTo(this.currentSequence[0])) {
          this.sequenceIndex = 1;
        }
      } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
        this.sequenceIndex = 0;
      }
    }
    /**
     * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
     *
     * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
     * We allow anything that wouldn't end the tag.
     */
    isTagStartChar(c) {
      return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
    }
    startSpecial(sequence, offset) {
      this.isSpecial = true;
      this.currentSequence = sequence;
      this.sequenceIndex = offset;
      this.state = State.SpecialStartSequence;
    }
    stateBeforeTagName(c) {
      if (c === CharCodes.ExclamationMark) {
        this.state = State.BeforeDeclaration;
        this.sectionStart = this.index + 1;
      } else if (c === CharCodes.Questionmark) {
        this.state = State.InProcessingInstruction;
        this.sectionStart = this.index + 1;
      } else if (this.isTagStartChar(c)) {
        const lower2 = c | 32;
        this.sectionStart = this.index;
        if (this.xmlMode) {
          this.state = State.InTagName;
        } else if (lower2 === Sequences.ScriptEnd[2]) {
          this.state = State.BeforeSpecialS;
        } else if (lower2 === Sequences.TitleEnd[2]) {
          this.state = State.BeforeSpecialT;
        } else {
          this.state = State.InTagName;
        }
      } else if (c === CharCodes.Slash) {
        this.state = State.BeforeClosingTagName;
      } else {
        this.state = State.Text;
        this.stateText(c);
      }
    }
    stateInTagName(c) {
      if (isEndOfTagSection(c)) {
        this.cbs.onopentagname(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.state = State.BeforeAttributeName;
        this.stateBeforeAttributeName(c);
      }
    }
    stateBeforeClosingTagName(c) {
      if (isWhitespace(c)) ;
      else if (c === CharCodes.Gt) {
        this.state = State.Text;
      } else {
        this.state = this.isTagStartChar(c) ? State.InClosingTagName : State.InSpecialComment;
        this.sectionStart = this.index;
      }
    }
    stateInClosingTagName(c) {
      if (c === CharCodes.Gt || isWhitespace(c)) {
        this.cbs.onclosetag(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.state = State.AfterClosingTagName;
        this.stateAfterClosingTagName(c);
      }
    }
    stateAfterClosingTagName(c) {
      if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
        this.state = State.Text;
        this.sectionStart = this.index + 1;
      }
    }
    stateBeforeAttributeName(c) {
      if (c === CharCodes.Gt) {
        this.cbs.onopentagend(this.index);
        if (this.isSpecial) {
          this.state = State.InSpecialTag;
          this.sequenceIndex = 0;
        } else {
          this.state = State.Text;
        }
        this.sectionStart = this.index + 1;
      } else if (c === CharCodes.Slash) {
        this.state = State.InSelfClosingTag;
      } else if (!isWhitespace(c)) {
        this.state = State.InAttributeName;
        this.sectionStart = this.index;
      }
    }
    stateInSelfClosingTag(c) {
      if (c === CharCodes.Gt) {
        this.cbs.onselfclosingtag(this.index);
        this.state = State.Text;
        this.sectionStart = this.index + 1;
        this.isSpecial = false;
      } else if (!isWhitespace(c)) {
        this.state = State.BeforeAttributeName;
        this.stateBeforeAttributeName(c);
      }
    }
    stateInAttributeName(c) {
      if (c === CharCodes.Eq || isEndOfTagSection(c)) {
        this.cbs.onattribname(this.sectionStart, this.index);
        this.sectionStart = this.index;
        this.state = State.AfterAttributeName;
        this.stateAfterAttributeName(c);
      }
    }
    stateAfterAttributeName(c) {
      if (c === CharCodes.Eq) {
        this.state = State.BeforeAttributeValue;
      } else if (c === CharCodes.Slash || c === CharCodes.Gt) {
        this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);
        this.sectionStart = -1;
        this.state = State.BeforeAttributeName;
        this.stateBeforeAttributeName(c);
      } else if (!isWhitespace(c)) {
        this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);
        this.state = State.InAttributeName;
        this.sectionStart = this.index;
      }
    }
    stateBeforeAttributeValue(c) {
      if (c === CharCodes.DoubleQuote) {
        this.state = State.InAttributeValueDq;
        this.sectionStart = this.index + 1;
      } else if (c === CharCodes.SingleQuote) {
        this.state = State.InAttributeValueSq;
        this.sectionStart = this.index + 1;
      } else if (!isWhitespace(c)) {
        this.sectionStart = this.index;
        this.state = State.InAttributeValueNq;
        this.stateInAttributeValueNoQuotes(c);
      }
    }
    handleInAttributeValue(c, quote) {
      if (c === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.cbs.onattribend(quote === CharCodes.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index + 1);
        this.state = State.BeforeAttributeName;
      } else if (this.decodeEntities && c === CharCodes.Amp) {
        this.startEntity();
      }
    }
    stateInAttributeValueDoubleQuotes(c) {
      this.handleInAttributeValue(c, CharCodes.DoubleQuote);
    }
    stateInAttributeValueSingleQuotes(c) {
      this.handleInAttributeValue(c, CharCodes.SingleQuote);
    }
    stateInAttributeValueNoQuotes(c) {
      if (isWhitespace(c) || c === CharCodes.Gt) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.cbs.onattribend(QuoteType.Unquoted, this.index);
        this.state = State.BeforeAttributeName;
        this.stateBeforeAttributeName(c);
      } else if (this.decodeEntities && c === CharCodes.Amp) {
        this.startEntity();
      }
    }
    stateBeforeDeclaration(c) {
      if (c === CharCodes.OpeningSquareBracket) {
        this.state = State.CDATASequence;
        this.sequenceIndex = 0;
      } else {
        this.state = c === CharCodes.Dash ? State.BeforeComment : State.InDeclaration;
      }
    }
    stateInDeclaration(c) {
      if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
        this.cbs.ondeclaration(this.sectionStart, this.index);
        this.state = State.Text;
        this.sectionStart = this.index + 1;
      }
    }
    stateInProcessingInstruction(c) {
      if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
        this.cbs.onprocessinginstruction(this.sectionStart, this.index);
        this.state = State.Text;
        this.sectionStart = this.index + 1;
      }
    }
    stateBeforeComment(c) {
      if (c === CharCodes.Dash) {
        this.state = State.InCommentLike;
        this.currentSequence = Sequences.CommentEnd;
        this.sequenceIndex = 2;
        this.sectionStart = this.index + 1;
      } else {
        this.state = State.InDeclaration;
      }
    }
    stateInSpecialComment(c) {
      if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
        this.cbs.oncomment(this.sectionStart, this.index, 0);
        this.state = State.Text;
        this.sectionStart = this.index + 1;
      }
    }
    stateBeforeSpecialS(c) {
      const lower2 = c | 32;
      if (lower2 === Sequences.ScriptEnd[3]) {
        this.startSpecial(Sequences.ScriptEnd, 4);
      } else if (lower2 === Sequences.StyleEnd[3]) {
        this.startSpecial(Sequences.StyleEnd, 4);
      } else {
        this.state = State.InTagName;
        this.stateInTagName(c);
      }
    }
    stateBeforeSpecialT(c) {
      const lower2 = c | 32;
      if (lower2 === Sequences.TitleEnd[3]) {
        this.startSpecial(Sequences.TitleEnd, 4);
      } else if (lower2 === Sequences.TextareaEnd[3]) {
        this.startSpecial(Sequences.TextareaEnd, 4);
      } else {
        this.state = State.InTagName;
        this.stateInTagName(c);
      }
    }
    startEntity() {
      this.baseState = this.state;
      this.state = State.InEntity;
      this.entityStart = this.index;
      this.entityDecoder.startEntity(this.xmlMode ? DecodingMode.Strict : this.baseState === State.Text || this.baseState === State.InSpecialTag ? DecodingMode.Legacy : DecodingMode.Attribute);
    }
    stateInEntity() {
      const length = this.entityDecoder.write(this.buffer, this.index - this.offset);
      if (length >= 0) {
        this.state = this.baseState;
        if (length === 0) {
          this.index = this.entityStart;
        }
      } else {
        this.index = this.offset + this.buffer.length - 1;
      }
    }
    /**
     * Remove data that has already been consumed from the buffer.
     */
    cleanup() {
      if (this.running && this.sectionStart !== this.index) {
        if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {
          this.cbs.ontext(this.sectionStart, this.index);
          this.sectionStart = this.index;
        } else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {
          this.cbs.onattribdata(this.sectionStart, this.index);
          this.sectionStart = this.index;
        }
      }
    }
    shouldContinue() {
      return this.index < this.buffer.length + this.offset && this.running;
    }
    /**
     * Iterates through the buffer, calling the function corresponding to the current state.
     *
     * States that are more likely to be hit are higher up, as a performance improvement.
     */
    parse() {
      while (this.shouldContinue()) {
        const c = this.buffer.charCodeAt(this.index - this.offset);
        switch (this.state) {
          case State.Text: {
            this.stateText(c);
            break;
          }
          case State.SpecialStartSequence: {
            this.stateSpecialStartSequence(c);
            break;
          }
          case State.InSpecialTag: {
            this.stateInSpecialTag(c);
            break;
          }
          case State.CDATASequence: {
            this.stateCDATASequence(c);
            break;
          }
          case State.InAttributeValueDq: {
            this.stateInAttributeValueDoubleQuotes(c);
            break;
          }
          case State.InAttributeName: {
            this.stateInAttributeName(c);
            break;
          }
          case State.InCommentLike: {
            this.stateInCommentLike(c);
            break;
          }
          case State.InSpecialComment: {
            this.stateInSpecialComment(c);
            break;
          }
          case State.BeforeAttributeName: {
            this.stateBeforeAttributeName(c);
            break;
          }
          case State.InTagName: {
            this.stateInTagName(c);
            break;
          }
          case State.InClosingTagName: {
            this.stateInClosingTagName(c);
            break;
          }
          case State.BeforeTagName: {
            this.stateBeforeTagName(c);
            break;
          }
          case State.AfterAttributeName: {
            this.stateAfterAttributeName(c);
            break;
          }
          case State.InAttributeValueSq: {
            this.stateInAttributeValueSingleQuotes(c);
            break;
          }
          case State.BeforeAttributeValue: {
            this.stateBeforeAttributeValue(c);
            break;
          }
          case State.BeforeClosingTagName: {
            this.stateBeforeClosingTagName(c);
            break;
          }
          case State.AfterClosingTagName: {
            this.stateAfterClosingTagName(c);
            break;
          }
          case State.BeforeSpecialS: {
            this.stateBeforeSpecialS(c);
            break;
          }
          case State.BeforeSpecialT: {
            this.stateBeforeSpecialT(c);
            break;
          }
          case State.InAttributeValueNq: {
            this.stateInAttributeValueNoQuotes(c);
            break;
          }
          case State.InSelfClosingTag: {
            this.stateInSelfClosingTag(c);
            break;
          }
          case State.InDeclaration: {
            this.stateInDeclaration(c);
            break;
          }
          case State.BeforeDeclaration: {
            this.stateBeforeDeclaration(c);
            break;
          }
          case State.BeforeComment: {
            this.stateBeforeComment(c);
            break;
          }
          case State.InProcessingInstruction: {
            this.stateInProcessingInstruction(c);
            break;
          }
          case State.InEntity: {
            this.stateInEntity();
            break;
          }
        }
        this.index++;
      }
      this.cleanup();
    }
    finish() {
      if (this.state === State.InEntity) {
        this.entityDecoder.end();
        this.state = this.baseState;
      }
      this.handleTrailingData();
      this.cbs.onend();
    }
    /** Handle any trailing data. */
    handleTrailingData() {
      const endIndex = this.buffer.length + this.offset;
      if (this.sectionStart >= endIndex) {
        return;
      }
      if (this.state === State.InCommentLike) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, endIndex, 0);
        } else {
          this.cbs.oncomment(this.sectionStart, endIndex, 0);
        }
      } else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName) ;
      else {
        this.cbs.ontext(this.sectionStart, endIndex);
      }
    }
    emitCodePoint(cp, consumed) {
      if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
        if (this.sectionStart < this.entityStart) {
          this.cbs.onattribdata(this.sectionStart, this.entityStart);
        }
        this.sectionStart = this.entityStart + consumed;
        this.index = this.sectionStart - 1;
        this.cbs.onattribentity(cp);
      } else {
        if (this.sectionStart < this.entityStart) {
          this.cbs.ontext(this.sectionStart, this.entityStart);
        }
        this.sectionStart = this.entityStart + consumed;
        this.index = this.sectionStart - 1;
        this.cbs.ontextentity(cp, this.sectionStart);
      }
    }
  };
  var formTags = /* @__PURE__ */ new Set([
    "input",
    "option",
    "optgroup",
    "select",
    "button",
    "datalist",
    "textarea"
  ]);
  var pTag = /* @__PURE__ */ new Set(["p"]);
  var tableSectionTags = /* @__PURE__ */ new Set(["thead", "tbody"]);
  var ddtTags = /* @__PURE__ */ new Set(["dd", "dt"]);
  var rtpTags = /* @__PURE__ */ new Set(["rt", "rp"]);
  var openImpliesClose = /* @__PURE__ */ new Map([
    ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
    ["th", /* @__PURE__ */ new Set(["th"])],
    ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
    ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
    ["li", /* @__PURE__ */ new Set(["li"])],
    ["p", pTag],
    ["h1", pTag],
    ["h2", pTag],
    ["h3", pTag],
    ["h4", pTag],
    ["h5", pTag],
    ["h6", pTag],
    ["select", formTags],
    ["input", formTags],
    ["output", formTags],
    ["button", formTags],
    ["datalist", formTags],
    ["textarea", formTags],
    ["option", /* @__PURE__ */ new Set(["option"])],
    ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
    ["dd", ddtTags],
    ["dt", ddtTags],
    ["address", pTag],
    ["article", pTag],
    ["aside", pTag],
    ["blockquote", pTag],
    ["details", pTag],
    ["div", pTag],
    ["dl", pTag],
    ["fieldset", pTag],
    ["figcaption", pTag],
    ["figure", pTag],
    ["footer", pTag],
    ["form", pTag],
    ["header", pTag],
    ["hr", pTag],
    ["main", pTag],
    ["nav", pTag],
    ["ol", pTag],
    ["pre", pTag],
    ["section", pTag],
    ["table", pTag],
    ["ul", pTag],
    ["rt", rtpTags],
    ["rp", rtpTags],
    ["tbody", tableSectionTags],
    ["tfoot", tableSectionTags]
  ]);
  var voidElements = /* @__PURE__ */ new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
  var foreignContextElements = /* @__PURE__ */ new Set(["math", "svg"]);
  var htmlIntegrationElements = /* @__PURE__ */ new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignobject",
    "desc",
    "title"
  ]);
  var reNameEnd = /\s|\//;
  var Parser = class {
    constructor(cbs, options = {}) {
      var _a22, _b, _c, _d, _e, _f;
      this.options = options;
      this.startIndex = 0;
      this.endIndex = 0;
      this.openTagStart = 0;
      this.tagname = "";
      this.attribname = "";
      this.attribvalue = "";
      this.attribs = null;
      this.stack = [];
      this.buffers = [];
      this.bufferOffset = 0;
      this.writeIndex = 0;
      this.ended = false;
      this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
      this.htmlMode = !this.options.xmlMode;
      this.lowerCaseTagNames = (_a22 = options.lowerCaseTags) !== null && _a22 !== void 0 ? _a22 : this.htmlMode;
      this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : this.htmlMode;
      this.recognizeSelfClosing = (_c = options.recognizeSelfClosing) !== null && _c !== void 0 ? _c : !this.htmlMode;
      this.tokenizer = new ((_d = options.Tokenizer) !== null && _d !== void 0 ? _d : Tokenizer)(this.options, this);
      this.foreignContext = [!this.htmlMode];
      (_f = (_e = this.cbs).onparserinit) === null || _f === void 0 ? void 0 : _f.call(_e, this);
    }
    // Tokenizer event handlers
    /** @internal */
    ontext(start2, endIndex) {
      var _a22, _b;
      const data2 = this.getSlice(start2, endIndex);
      this.endIndex = endIndex - 1;
      (_b = (_a22 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a22, data2);
      this.startIndex = endIndex;
    }
    /** @internal */
    ontextentity(cp, endIndex) {
      var _a22, _b;
      this.endIndex = endIndex - 1;
      (_b = (_a22 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a22, fromCodePoint(cp));
      this.startIndex = endIndex;
    }
    /**
     * Checks if the current tag is a void element. Override this if you want
     * to specify your own additional void elements.
     */
    isVoidElement(name2) {
      return this.htmlMode && voidElements.has(name2);
    }
    /** @internal */
    onopentagname(start2, endIndex) {
      this.endIndex = endIndex;
      let name2 = this.getSlice(start2, endIndex);
      if (this.lowerCaseTagNames) {
        name2 = name2.toLowerCase();
      }
      this.emitOpenTag(name2);
    }
    emitOpenTag(name2) {
      var _a22, _b, _c, _d;
      this.openTagStart = this.startIndex;
      this.tagname = name2;
      const impliesClose = this.htmlMode && openImpliesClose.get(name2);
      if (impliesClose) {
        while (this.stack.length > 0 && impliesClose.has(this.stack[0])) {
          const element = this.stack.shift();
          (_b = (_a22 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a22, element, true);
        }
      }
      if (!this.isVoidElement(name2)) {
        this.stack.unshift(name2);
        if (this.htmlMode) {
          if (foreignContextElements.has(name2)) {
            this.foreignContext.unshift(true);
          } else if (htmlIntegrationElements.has(name2)) {
            this.foreignContext.unshift(false);
          }
        }
      }
      (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name2);
      if (this.cbs.onopentag)
        this.attribs = {};
    }
    endOpenTag(isImplied) {
      var _a22, _b;
      this.startIndex = this.openTagStart;
      if (this.attribs) {
        (_b = (_a22 = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a22, this.tagname, this.attribs, isImplied);
        this.attribs = null;
      }
      if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
        this.cbs.onclosetag(this.tagname, true);
      }
      this.tagname = "";
    }
    /** @internal */
    onopentagend(endIndex) {
      this.endIndex = endIndex;
      this.endOpenTag(false);
      this.startIndex = endIndex + 1;
    }
    /** @internal */
    onclosetag(start2, endIndex) {
      var _a22, _b, _c, _d, _e, _f, _g, _h;
      this.endIndex = endIndex;
      let name2 = this.getSlice(start2, endIndex);
      if (this.lowerCaseTagNames) {
        name2 = name2.toLowerCase();
      }
      if (this.htmlMode && (foreignContextElements.has(name2) || htmlIntegrationElements.has(name2))) {
        this.foreignContext.shift();
      }
      if (!this.isVoidElement(name2)) {
        const pos = this.stack.indexOf(name2);
        if (pos !== -1) {
          for (let index2 = 0; index2 <= pos; index2++) {
            const element = this.stack.shift();
            (_b = (_a22 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a22, element, index2 !== pos);
          }
        } else if (this.htmlMode && name2 === "p") {
          this.emitOpenTag("p");
          this.closeCurrentTag(true);
        }
      } else if (this.htmlMode && name2 === "br") {
        (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, "br");
        (_f = (_e = this.cbs).onopentag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", {}, true);
        (_h = (_g = this.cbs).onclosetag) === null || _h === void 0 ? void 0 : _h.call(_g, "br", false);
      }
      this.startIndex = endIndex + 1;
    }
    /** @internal */
    onselfclosingtag(endIndex) {
      this.endIndex = endIndex;
      if (this.recognizeSelfClosing || this.foreignContext[0]) {
        this.closeCurrentTag(false);
        this.startIndex = endIndex + 1;
      } else {
        this.onopentagend(endIndex);
      }
    }
    closeCurrentTag(isOpenImplied) {
      var _a22, _b;
      const name2 = this.tagname;
      this.endOpenTag(isOpenImplied);
      if (this.stack[0] === name2) {
        (_b = (_a22 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a22, name2, !isOpenImplied);
        this.stack.shift();
      }
    }
    /** @internal */
    onattribname(start2, endIndex) {
      this.startIndex = start2;
      const name2 = this.getSlice(start2, endIndex);
      this.attribname = this.lowerCaseAttributeNames ? name2.toLowerCase() : name2;
    }
    /** @internal */
    onattribdata(start2, endIndex) {
      this.attribvalue += this.getSlice(start2, endIndex);
    }
    /** @internal */
    onattribentity(cp) {
      this.attribvalue += fromCodePoint(cp);
    }
    /** @internal */
    onattribend(quote, endIndex) {
      var _a22, _b;
      this.endIndex = endIndex;
      (_b = (_a22 = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a22, this.attribname, this.attribvalue, quote === QuoteType.Double ? '"' : quote === QuoteType.Single ? "'" : quote === QuoteType.NoValue ? void 0 : null);
      if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
        this.attribs[this.attribname] = this.attribvalue;
      }
      this.attribvalue = "";
    }
    getInstructionName(value) {
      const index2 = value.search(reNameEnd);
      let name2 = index2 < 0 ? value : value.substr(0, index2);
      if (this.lowerCaseTagNames) {
        name2 = name2.toLowerCase();
      }
      return name2;
    }
    /** @internal */
    ondeclaration(start2, endIndex) {
      this.endIndex = endIndex;
      const value = this.getSlice(start2, endIndex);
      if (this.cbs.onprocessinginstruction) {
        const name2 = this.getInstructionName(value);
        this.cbs.onprocessinginstruction(`!${name2}`, `!${value}`);
      }
      this.startIndex = endIndex + 1;
    }
    /** @internal */
    onprocessinginstruction(start2, endIndex) {
      this.endIndex = endIndex;
      const value = this.getSlice(start2, endIndex);
      if (this.cbs.onprocessinginstruction) {
        const name2 = this.getInstructionName(value);
        this.cbs.onprocessinginstruction(`?${name2}`, `?${value}`);
      }
      this.startIndex = endIndex + 1;
    }
    /** @internal */
    oncomment(start2, endIndex, offset) {
      var _a22, _b, _c, _d;
      this.endIndex = endIndex;
      (_b = (_a22 = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a22, this.getSlice(start2, endIndex - offset));
      (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
      this.startIndex = endIndex + 1;
    }
    /** @internal */
    oncdata(start2, endIndex, offset) {
      var _a22, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      this.endIndex = endIndex;
      const value = this.getSlice(start2, endIndex - offset);
      if (!this.htmlMode || this.options.recognizeCDATA) {
        (_b = (_a22 = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a22);
        (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
        (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
      } else {
        (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, `[CDATA[${value}]]`);
        (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
      }
      this.startIndex = endIndex + 1;
    }
    /** @internal */
    onend() {
      var _a22, _b;
      if (this.cbs.onclosetag) {
        this.endIndex = this.startIndex;
        for (let index2 = 0; index2 < this.stack.length; index2++) {
          this.cbs.onclosetag(this.stack[index2], true);
        }
      }
      (_b = (_a22 = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a22);
    }
    /**
     * Resets the parser to a blank state, ready to parse a new HTML document
     */
    reset() {
      var _a22, _b, _c, _d;
      (_b = (_a22 = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a22);
      this.tokenizer.reset();
      this.tagname = "";
      this.attribname = "";
      this.attribs = null;
      this.stack.length = 0;
      this.startIndex = 0;
      this.endIndex = 0;
      (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
      this.buffers.length = 0;
      this.foreignContext.length = 0;
      this.foreignContext.unshift(!this.htmlMode);
      this.bufferOffset = 0;
      this.writeIndex = 0;
      this.ended = false;
    }
    /**
     * Resets the parser, then parses a complete document and
     * pushes it to the handler.
     *
     * @param data Document to parse.
     */
    parseComplete(data2) {
      this.reset();
      this.end(data2);
    }
    getSlice(start2, end2) {
      while (start2 - this.bufferOffset >= this.buffers[0].length) {
        this.shiftBuffer();
      }
      let slice22 = this.buffers[0].slice(start2 - this.bufferOffset, end2 - this.bufferOffset);
      while (end2 - this.bufferOffset > this.buffers[0].length) {
        this.shiftBuffer();
        slice22 += this.buffers[0].slice(0, end2 - this.bufferOffset);
      }
      return slice22;
    }
    shiftBuffer() {
      this.bufferOffset += this.buffers[0].length;
      this.writeIndex--;
      this.buffers.shift();
    }
    /**
     * Parses a chunk of data and calls the corresponding callbacks.
     *
     * @param chunk Chunk to parse.
     */
    write(chunk) {
      var _a22, _b;
      if (this.ended) {
        (_b = (_a22 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a22, new Error(".write() after done!"));
        return;
      }
      this.buffers.push(chunk);
      if (this.tokenizer.running) {
        this.tokenizer.write(chunk);
        this.writeIndex++;
      }
    }
    /**
     * Parses the end of the buffer and clears the stack, calls onend.
     *
     * @param chunk Optional final chunk to parse.
     */
    end(chunk) {
      var _a22, _b;
      if (this.ended) {
        (_b = (_a22 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a22, new Error(".end() after done!"));
        return;
      }
      if (chunk)
        this.write(chunk);
      this.ended = true;
      this.tokenizer.end();
    }
    /**
     * Pauses parsing. The parser won't emit events until `resume` is called.
     */
    pause() {
      this.tokenizer.pause();
    }
    /**
     * Resumes parsing after `pause` was called.
     */
    resume() {
      this.tokenizer.resume();
      while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
        this.tokenizer.write(this.buffers[this.writeIndex++]);
      }
      if (this.ended)
        this.tokenizer.end();
    }
    /**
     * Alias of `write`, for backwards compatibility.
     *
     * @param chunk Chunk to parse.
     * @deprecated
     */
    parseChunk(chunk) {
      this.write(chunk);
    }
    /**
     * Alias of `end`, for backwards compatibility.
     *
     * @param chunk Optional final chunk to parse.
     * @deprecated
     */
    done(chunk) {
      this.end(chunk);
    }
  };
  function parseDocument(data2, options) {
    const handler = new DomHandler(void 0, options);
    new Parser(handler, options).end(data2);
    return handler.root;
  }
  var load = getLoad(getParse(parseDocument), render$1);
  var defaultSelectorRules = {
    "div,p": ({ $node }) => ({
      queue: $node.children()
    }),
    "h1,h2,h3,h4,h5,h6": ({ $node, getContent }) => ({
      ...getContent($node.contents())
    }),
    "ul,ol": ({ $node }) => ({
      queue: $node.children(),
      nesting: true
    }),
    li: ({ $node, getContent }) => {
      const queue = $node.children().filter("ul,ol");
      let content;
      if ($node.contents().first().is("div,p")) {
        content = getContent($node.children().first());
      } else {
        let $contents = $node.contents();
        const i = $contents.index(queue);
        if (i >= 0) $contents = $contents.slice(0, i);
        content = getContent($contents);
      }
      return {
        queue,
        nesting: true,
        ...content
      };
    },
    "table,pre,p>img:only-child": ({ $node, getContent }) => ({
      ...getContent($node)
    })
  };
  var defaultOptions = {
    selector: "h1,h2,h3,h4,h5,h6,ul,ol,li,table,pre,p>img:only-child",
    selectorRules: defaultSelectorRules
  };
  var MARKMAP_COMMENT_PREFIX = "markmap: ";
  var SELECTOR_HEADING = /^h[1-6]$/;
  var SELECTOR_LIST = /^[uo]l$/;
  var SELECTOR_LIST_ITEM = /^li$/;
  function getLevel(tagName) {
    if (SELECTOR_HEADING.test(tagName)) return +tagName[1];
    if (SELECTOR_LIST.test(tagName)) return 8;
    if (SELECTOR_LIST_ITEM.test(tagName)) return 9;
    return 7;
  }
  function parseHtml(html2, opts) {
    const options = {
      ...defaultOptions,
      ...opts
    };
    const $ = load(html2);
    let $root = $("body");
    if (!$root.length) $root = $.root();
    let id2 = 0;
    const rootNode = {
      id: id2,
      tag: "",
      html: "",
      level: 0,
      parent: 0,
      childrenLevel: 0,
      children: []
    };
    const headingStack = [];
    let skippingHeading = 0;
    checkNodes($root.children());
    return rootNode;
    function addChild(props) {
      var _a22;
      const { parent: parent2 } = props;
      const node = {
        id: ++id2,
        tag: props.tagName,
        level: props.level,
        html: props.html,
        childrenLevel: 0,
        children: props.nesting ? [] : void 0,
        parent: parent2.id
      };
      if ((_a22 = props.comments) == null ? void 0 : _a22.length) {
        node.comments = props.comments;
      }
      if (Object.keys(props.data || {}).length) {
        node.data = props.data;
      }
      if (parent2.children) {
        if (parent2.childrenLevel === 0 || parent2.childrenLevel > node.level) {
          parent2.children = [];
          parent2.childrenLevel = node.level;
        }
        if (parent2.childrenLevel === node.level) {
          parent2.children.push(node);
        }
      }
      return node;
    }
    function getCurrentHeading(level) {
      let heading2;
      while ((heading2 = headingStack[headingStack.length - 1]) && heading2.level >= level) {
        headingStack.pop();
      }
      return heading2 || rootNode;
    }
    function getContent($node) {
      var _a22;
      const result = extractMagicComments($node);
      const html22 = (_a22 = $.html(result.$node)) == null ? void 0 : _a22.trimEnd();
      return { comments: result.comments, html: html22 };
    }
    function extractMagicComments($node) {
      const comments = [];
      $node = $node.filter((_2, child) => {
        if (child.type === "comment") {
          const data2 = child.data.trim();
          if (data2.startsWith(MARKMAP_COMMENT_PREFIX)) {
            comments.push(data2.slice(MARKMAP_COMMENT_PREFIX.length).trim());
            return false;
          }
        }
        return true;
      });
      return { $node, comments };
    }
    function checkNodes($els, node) {
      $els.each((_2, child) => {
        var _a22;
        const $child = $(child);
        const rule = (_a22 = Object.entries(options.selectorRules).find(
          ([selector]) => $child.is(selector)
        )) == null ? void 0 : _a22[1];
        const result = rule == null ? void 0 : rule({ $node: $child, $, getContent });
        if ((result == null ? void 0 : result.queue) && !result.nesting) {
          checkNodes(result.queue, node);
          return;
        }
        const level = getLevel(child.tagName);
        if (!result) {
          if (level <= 6) {
            skippingHeading = level;
          }
          return;
        }
        if (skippingHeading > 0 && level > skippingHeading) return;
        if (!$child.is(options.selector)) return;
        skippingHeading = 0;
        const isHeading = level <= 6;
        let data2 = {
          // If the child is an inline element and expected to be a separate node,
          // data from the closest `<p>` should be included, e.g. `<p data-lines><img /></p>`
          ...$child.closest("p").data(),
          ...$child.data()
        };
        let html22 = result.html || "";
        if ($child.is("ol>li") && (node == null ? void 0 : node.children)) {
          const start2 = +($child.parent().attr("start") || 1);
          const listIndex = start2 + node.children.length;
          html22 = `${listIndex}. ${html22}`;
          data2 = {
            ...data2,
            listIndex
          };
        }
        const childNode = addChild({
          parent: node || getCurrentHeading(level),
          nesting: !!result.queue || isHeading,
          tagName: child.tagName,
          level,
          html: html22,
          comments: result.comments,
          data: data2
        });
        if (isHeading) headingStack.push(childNode);
        if (result.queue) checkNodes(result.queue, childNode);
      });
    }
  }
  function convertNode(htmlRoot) {
    return walkTree(htmlRoot, (htmlNode, next2) => {
      const node = {
        content: htmlNode.html,
        children: next2() || []
      };
      if (htmlNode.data) {
        node.payload = {
          tag: htmlNode.tag,
          ...htmlNode.data
        };
      }
      if (htmlNode.comments) {
        if (htmlNode.comments.includes("foldAll")) {
          node.payload = { ...node.payload, fold: 2 };
        } else if (htmlNode.comments.includes("fold")) {
          node.payload = { ...node.payload, fold: 1 };
        }
      }
      return node;
    });
  }
  function buildTree(html2, opts) {
    const htmlRoot = parseHtml(html2, opts);
    return convertNode(htmlRoot);
  }

  // node_modules/markdown-it/lib/common/utils.mjs
  var utils_exports = {};
  __export(utils_exports, {
    arrayReplaceAt: () => arrayReplaceAt,
    assign: () => assign,
    escapeHtml: () => escapeHtml,
    escapeRE: () => escapeRE,
    fromCodePoint: () => fromCodePoint3,
    has: () => has2,
    isMdAsciiPunct: () => isMdAsciiPunct,
    isPunctChar: () => isPunctChar,
    isSpace: () => isSpace,
    isString: () => isString,
    isValidEntityCode: () => isValidEntityCode,
    isWhiteSpace: () => isWhiteSpace,
    lib: () => lib,
    normalizeReference: () => normalizeReference,
    unescapeAll: () => unescapeAll,
    unescapeMd: () => unescapeMd
  });

  // node_modules/mdurl/index.mjs
  var mdurl_exports = {};
  __export(mdurl_exports, {
    decode: () => decode_default,
    encode: () => encode_default,
    format: () => format,
    parse: () => parse_default
  });

  // node_modules/mdurl/lib/decode.mjs
  var decodeCache = {};
  function getDecodeCache(exclude) {
    let cache = decodeCache[exclude];
    if (cache) {
      return cache;
    }
    cache = decodeCache[exclude] = [];
    for (let i = 0; i < 128; i++) {
      const ch = String.fromCharCode(i);
      cache.push(ch);
    }
    for (let i = 0; i < exclude.length; i++) {
      const ch = exclude.charCodeAt(i);
      cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
    }
    return cache;
  }
  function decode(string2, exclude) {
    if (typeof exclude !== "string") {
      exclude = decode.defaultChars;
    }
    const cache = getDecodeCache(exclude);
    return string2.replace(/(%[a-f0-9]{2})+/gi, function(seq2) {
      let result = "";
      for (let i = 0, l = seq2.length; i < l; i += 3) {
        const b1 = parseInt(seq2.slice(i + 1, i + 3), 16);
        if (b1 < 128) {
          result += cache[b1];
          continue;
        }
        if ((b1 & 224) === 192 && i + 3 < l) {
          const b2 = parseInt(seq2.slice(i + 4, i + 6), 16);
          if ((b2 & 192) === 128) {
            const chr = b1 << 6 & 1984 | b2 & 63;
            if (chr < 128) {
              result += "\uFFFD\uFFFD";
            } else {
              result += String.fromCharCode(chr);
            }
            i += 3;
            continue;
          }
        }
        if ((b1 & 240) === 224 && i + 6 < l) {
          const b2 = parseInt(seq2.slice(i + 4, i + 6), 16);
          const b3 = parseInt(seq2.slice(i + 7, i + 9), 16);
          if ((b2 & 192) === 128 && (b3 & 192) === 128) {
            const chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
            if (chr < 2048 || chr >= 55296 && chr <= 57343) {
              result += "\uFFFD\uFFFD\uFFFD";
            } else {
              result += String.fromCharCode(chr);
            }
            i += 6;
            continue;
          }
        }
        if ((b1 & 248) === 240 && i + 9 < l) {
          const b2 = parseInt(seq2.slice(i + 4, i + 6), 16);
          const b3 = parseInt(seq2.slice(i + 7, i + 9), 16);
          const b4 = parseInt(seq2.slice(i + 10, i + 12), 16);
          if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
            let chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
            if (chr < 65536 || chr > 1114111) {
              result += "\uFFFD\uFFFD\uFFFD\uFFFD";
            } else {
              chr -= 65536;
              result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
            }
            i += 9;
            continue;
          }
        }
        result += "\uFFFD";
      }
      return result;
    });
  }
  decode.defaultChars = ";/?:@&=+$,#";
  decode.componentChars = "";
  var decode_default = decode;

  // node_modules/mdurl/lib/encode.mjs
  var encodeCache = {};
  function getEncodeCache(exclude) {
    let cache = encodeCache[exclude];
    if (cache) {
      return cache;
    }
    cache = encodeCache[exclude] = [];
    for (let i = 0; i < 128; i++) {
      const ch = String.fromCharCode(i);
      if (/^[0-9a-z]$/i.test(ch)) {
        cache.push(ch);
      } else {
        cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
      }
    }
    for (let i = 0; i < exclude.length; i++) {
      cache[exclude.charCodeAt(i)] = exclude[i];
    }
    return cache;
  }
  function encode(string2, exclude, keepEscaped) {
    if (typeof exclude !== "string") {
      keepEscaped = exclude;
      exclude = encode.defaultChars;
    }
    if (typeof keepEscaped === "undefined") {
      keepEscaped = true;
    }
    const cache = getEncodeCache(exclude);
    let result = "";
    for (let i = 0, l = string2.length; i < l; i++) {
      const code2 = string2.charCodeAt(i);
      if (keepEscaped && code2 === 37 && i + 2 < l) {
        if (/^[0-9a-f]{2}$/i.test(string2.slice(i + 1, i + 3))) {
          result += string2.slice(i, i + 3);
          i += 2;
          continue;
        }
      }
      if (code2 < 128) {
        result += cache[code2];
        continue;
      }
      if (code2 >= 55296 && code2 <= 57343) {
        if (code2 >= 55296 && code2 <= 56319 && i + 1 < l) {
          const nextCode = string2.charCodeAt(i + 1);
          if (nextCode >= 56320 && nextCode <= 57343) {
            result += encodeURIComponent(string2[i] + string2[i + 1]);
            i++;
            continue;
          }
        }
        result += "%EF%BF%BD";
        continue;
      }
      result += encodeURIComponent(string2[i]);
    }
    return result;
  }
  encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
  encode.componentChars = "-_.!~*'()";
  var encode_default = encode;

  // node_modules/mdurl/lib/format.mjs
  function format(url) {
    let result = "";
    result += url.protocol || "";
    result += url.slashes ? "//" : "";
    result += url.auth ? url.auth + "@" : "";
    if (url.hostname && url.hostname.indexOf(":") !== -1) {
      result += "[" + url.hostname + "]";
    } else {
      result += url.hostname || "";
    }
    result += url.port ? ":" + url.port : "";
    result += url.pathname || "";
    result += url.search || "";
    result += url.hash || "";
    return result;
  }

  // node_modules/mdurl/lib/parse.mjs
  function Url() {
    this.protocol = null;
    this.slashes = null;
    this.auth = null;
    this.port = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.pathname = null;
  }
  var protocolPattern = /^([a-z0-9.+-]+:)/i;
  var portPattern = /:[0-9]*$/;
  var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
  var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
  var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
  var autoEscape = ["'"].concat(unwise);
  var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
  var hostEndingChars = ["/", "?", "#"];
  var hostnameMaxLen = 255;
  var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
  var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
  var hostlessProtocol = {
    javascript: true,
    "javascript:": true
  };
  var slashedProtocol = {
    http: true,
    https: true,
    ftp: true,
    gopher: true,
    file: true,
    "http:": true,
    "https:": true,
    "ftp:": true,
    "gopher:": true,
    "file:": true
  };
  function urlParse(url, slashesDenoteHost) {
    if (url && url instanceof Url) return url;
    const u = new Url();
    u.parse(url, slashesDenoteHost);
    return u;
  }
  Url.prototype.parse = function(url, slashesDenoteHost) {
    let lowerProto, hec, slashes;
    let rest = url;
    rest = rest.trim();
    if (!slashesDenoteHost && url.split("#").length === 1) {
      const simplePath = simplePathPattern.exec(rest);
      if (simplePath) {
        this.pathname = simplePath[1];
        if (simplePath[2]) {
          this.search = simplePath[2];
        }
        return this;
      }
    }
    let proto = protocolPattern.exec(rest);
    if (proto) {
      proto = proto[0];
      lowerProto = proto.toLowerCase();
      this.protocol = proto;
      rest = rest.substr(proto.length);
    }
    if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
      slashes = rest.substr(0, 2) === "//";
      if (slashes && !(proto && hostlessProtocol[proto])) {
        rest = rest.substr(2);
        this.slashes = true;
      }
    }
    if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
      let hostEnd = -1;
      for (let i = 0; i < hostEndingChars.length; i++) {
        hec = rest.indexOf(hostEndingChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
          hostEnd = hec;
        }
      }
      let auth, atSign;
      if (hostEnd === -1) {
        atSign = rest.lastIndexOf("@");
      } else {
        atSign = rest.lastIndexOf("@", hostEnd);
      }
      if (atSign !== -1) {
        auth = rest.slice(0, atSign);
        rest = rest.slice(atSign + 1);
        this.auth = auth;
      }
      hostEnd = -1;
      for (let i = 0; i < nonHostChars.length; i++) {
        hec = rest.indexOf(nonHostChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
          hostEnd = hec;
        }
      }
      if (hostEnd === -1) {
        hostEnd = rest.length;
      }
      if (rest[hostEnd - 1] === ":") {
        hostEnd--;
      }
      const host = rest.slice(0, hostEnd);
      rest = rest.slice(hostEnd);
      this.parseHost(host);
      this.hostname = this.hostname || "";
      const ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
      if (!ipv6Hostname) {
        const hostparts = this.hostname.split(/\./);
        for (let i = 0, l = hostparts.length; i < l; i++) {
          const part = hostparts[i];
          if (!part) {
            continue;
          }
          if (!part.match(hostnamePartPattern)) {
            let newpart = "";
            for (let j2 = 0, k = part.length; j2 < k; j2++) {
              if (part.charCodeAt(j2) > 127) {
                newpart += "x";
              } else {
                newpart += part[j2];
              }
            }
            if (!newpart.match(hostnamePartPattern)) {
              const validParts = hostparts.slice(0, i);
              const notHost = hostparts.slice(i + 1);
              const bit = part.match(hostnamePartStart);
              if (bit) {
                validParts.push(bit[1]);
                notHost.unshift(bit[2]);
              }
              if (notHost.length) {
                rest = notHost.join(".") + rest;
              }
              this.hostname = validParts.join(".");
              break;
            }
          }
        }
      }
      if (this.hostname.length > hostnameMaxLen) {
        this.hostname = "";
      }
      if (ipv6Hostname) {
        this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      }
    }
    const hash = rest.indexOf("#");
    if (hash !== -1) {
      this.hash = rest.substr(hash);
      rest = rest.slice(0, hash);
    }
    const qm = rest.indexOf("?");
    if (qm !== -1) {
      this.search = rest.substr(qm);
      rest = rest.slice(0, qm);
    }
    if (rest) {
      this.pathname = rest;
    }
    if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
      this.pathname = "";
    }
    return this;
  };
  Url.prototype.parseHost = function(host) {
    let port = portPattern.exec(host);
    if (port) {
      port = port[0];
      if (port !== ":") {
        this.port = port.substr(1);
      }
      host = host.substr(0, host.length - port.length);
    }
    if (host) {
      this.hostname = host;
    }
  };
  var parse_default = urlParse;

  // node_modules/uc.micro/index.mjs
  var uc_exports = {};
  __export(uc_exports, {
    Any: () => regex_default,
    Cc: () => regex_default2,
    Cf: () => regex_default3,
    P: () => regex_default4,
    S: () => regex_default5,
    Z: () => regex_default6
  });

  // node_modules/uc.micro/properties/Any/regex.mjs
  var regex_default = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;

  // node_modules/uc.micro/categories/Cc/regex.mjs
  var regex_default2 = /[\0-\x1F\x7F-\x9F]/;

  // node_modules/uc.micro/categories/Cf/regex.mjs
  var regex_default3 = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;

  // node_modules/uc.micro/categories/P/regex.mjs
  var regex_default4 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;

  // node_modules/uc.micro/categories/S/regex.mjs
  var regex_default5 = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u31EF\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDC-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF76\uDF7B-\uDFD9\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8\uDF00-\uDF92\uDF94-\uDFCA]/;

  // node_modules/uc.micro/categories/Z/regex.mjs
  var regex_default6 = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;

  // node_modules/entities/lib/esm/generated/decode-data-html.js
  var decode_data_html_default = new Uint16Array(
    // prettier-ignore
    '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map((c) => c.charCodeAt(0))
  );

  // node_modules/entities/lib/esm/generated/decode-data-xml.js
  var decode_data_xml_default = new Uint16Array(
    // prettier-ignore
    "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map((c) => c.charCodeAt(0))
  );

  // node_modules/entities/lib/esm/decode_codepoint.js
  var _a2;
  var decodeMap2 = /* @__PURE__ */ new Map([
    [0, 65533],
    // C1 Unicode control character reference replacements
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376]
  ]);
  var fromCodePoint2 = (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
    (_a2 = String.fromCodePoint) !== null && _a2 !== void 0 ? _a2 : function(codePoint) {
      let output = "";
      if (codePoint > 65535) {
        codePoint -= 65536;
        output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      output += String.fromCharCode(codePoint);
      return output;
    }
  );
  function replaceCodePoint2(codePoint) {
    var _a3;
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
      return 65533;
    }
    return (_a3 = decodeMap2.get(codePoint)) !== null && _a3 !== void 0 ? _a3 : codePoint;
  }

  // node_modules/entities/lib/esm/decode.js
  var CharCodes2;
  (function(CharCodes3) {
    CharCodes3[CharCodes3["NUM"] = 35] = "NUM";
    CharCodes3[CharCodes3["SEMI"] = 59] = "SEMI";
    CharCodes3[CharCodes3["EQUALS"] = 61] = "EQUALS";
    CharCodes3[CharCodes3["ZERO"] = 48] = "ZERO";
    CharCodes3[CharCodes3["NINE"] = 57] = "NINE";
    CharCodes3[CharCodes3["LOWER_A"] = 97] = "LOWER_A";
    CharCodes3[CharCodes3["LOWER_F"] = 102] = "LOWER_F";
    CharCodes3[CharCodes3["LOWER_X"] = 120] = "LOWER_X";
    CharCodes3[CharCodes3["LOWER_Z"] = 122] = "LOWER_Z";
    CharCodes3[CharCodes3["UPPER_A"] = 65] = "UPPER_A";
    CharCodes3[CharCodes3["UPPER_F"] = 70] = "UPPER_F";
    CharCodes3[CharCodes3["UPPER_Z"] = 90] = "UPPER_Z";
  })(CharCodes2 || (CharCodes2 = {}));
  var TO_LOWER_BIT2 = 32;
  var BinTrieFlags2;
  (function(BinTrieFlags3) {
    BinTrieFlags3[BinTrieFlags3["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
    BinTrieFlags3[BinTrieFlags3["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
    BinTrieFlags3[BinTrieFlags3["JUMP_TABLE"] = 127] = "JUMP_TABLE";
  })(BinTrieFlags2 || (BinTrieFlags2 = {}));
  function isNumber2(code2) {
    return code2 >= CharCodes2.ZERO && code2 <= CharCodes2.NINE;
  }
  function isHexadecimalCharacter2(code2) {
    return code2 >= CharCodes2.UPPER_A && code2 <= CharCodes2.UPPER_F || code2 >= CharCodes2.LOWER_A && code2 <= CharCodes2.LOWER_F;
  }
  function isAsciiAlphaNumeric2(code2) {
    return code2 >= CharCodes2.UPPER_A && code2 <= CharCodes2.UPPER_Z || code2 >= CharCodes2.LOWER_A && code2 <= CharCodes2.LOWER_Z || isNumber2(code2);
  }
  function isEntityInAttributeInvalidEnd2(code2) {
    return code2 === CharCodes2.EQUALS || isAsciiAlphaNumeric2(code2);
  }
  var EntityDecoderState2;
  (function(EntityDecoderState3) {
    EntityDecoderState3[EntityDecoderState3["EntityStart"] = 0] = "EntityStart";
    EntityDecoderState3[EntityDecoderState3["NumericStart"] = 1] = "NumericStart";
    EntityDecoderState3[EntityDecoderState3["NumericDecimal"] = 2] = "NumericDecimal";
    EntityDecoderState3[EntityDecoderState3["NumericHex"] = 3] = "NumericHex";
    EntityDecoderState3[EntityDecoderState3["NamedEntity"] = 4] = "NamedEntity";
  })(EntityDecoderState2 || (EntityDecoderState2 = {}));
  var DecodingMode2;
  (function(DecodingMode3) {
    DecodingMode3[DecodingMode3["Legacy"] = 0] = "Legacy";
    DecodingMode3[DecodingMode3["Strict"] = 1] = "Strict";
    DecodingMode3[DecodingMode3["Attribute"] = 2] = "Attribute";
  })(DecodingMode2 || (DecodingMode2 = {}));
  var EntityDecoder2 = class {
    constructor(decodeTree, emitCodePoint, errors2) {
      this.decodeTree = decodeTree;
      this.emitCodePoint = emitCodePoint;
      this.errors = errors2;
      this.state = EntityDecoderState2.EntityStart;
      this.consumed = 1;
      this.result = 0;
      this.treeIndex = 0;
      this.excess = 1;
      this.decodeMode = DecodingMode2.Strict;
    }
    /** Resets the instance to make it reusable. */
    startEntity(decodeMode) {
      this.decodeMode = decodeMode;
      this.state = EntityDecoderState2.EntityStart;
      this.result = 0;
      this.treeIndex = 0;
      this.excess = 1;
      this.consumed = 1;
    }
    /**
     * Write an entity to the decoder. This can be called multiple times with partial entities.
     * If the entity is incomplete, the decoder will return -1.
     *
     * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
     * entity is incomplete, and resume when the next string is written.
     *
     * @param string The string containing the entity (or a continuation of the entity).
     * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    write(str, offset) {
      switch (this.state) {
        case EntityDecoderState2.EntityStart: {
          if (str.charCodeAt(offset) === CharCodes2.NUM) {
            this.state = EntityDecoderState2.NumericStart;
            this.consumed += 1;
            return this.stateNumericStart(str, offset + 1);
          }
          this.state = EntityDecoderState2.NamedEntity;
          return this.stateNamedEntity(str, offset);
        }
        case EntityDecoderState2.NumericStart: {
          return this.stateNumericStart(str, offset);
        }
        case EntityDecoderState2.NumericDecimal: {
          return this.stateNumericDecimal(str, offset);
        }
        case EntityDecoderState2.NumericHex: {
          return this.stateNumericHex(str, offset);
        }
        case EntityDecoderState2.NamedEntity: {
          return this.stateNamedEntity(str, offset);
        }
      }
    }
    /**
     * Switches between the numeric decimal and hexadecimal states.
     *
     * Equivalent to the `Numeric character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNumericStart(str, offset) {
      if (offset >= str.length) {
        return -1;
      }
      if ((str.charCodeAt(offset) | TO_LOWER_BIT2) === CharCodes2.LOWER_X) {
        this.state = EntityDecoderState2.NumericHex;
        this.consumed += 1;
        return this.stateNumericHex(str, offset + 1);
      }
      this.state = EntityDecoderState2.NumericDecimal;
      return this.stateNumericDecimal(str, offset);
    }
    addToNumericResult(str, start2, end2, base2) {
      if (start2 !== end2) {
        const digitCount = end2 - start2;
        this.result = this.result * Math.pow(base2, digitCount) + parseInt(str.substr(start2, digitCount), base2);
        this.consumed += digitCount;
      }
    }
    /**
     * Parses a hexadecimal numeric entity.
     *
     * Equivalent to the `Hexademical character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNumericHex(str, offset) {
      const startIdx = offset;
      while (offset < str.length) {
        const char = str.charCodeAt(offset);
        if (isNumber2(char) || isHexadecimalCharacter2(char)) {
          offset += 1;
        } else {
          this.addToNumericResult(str, startIdx, offset, 16);
          return this.emitNumericEntity(char, 3);
        }
      }
      this.addToNumericResult(str, startIdx, offset, 16);
      return -1;
    }
    /**
     * Parses a decimal numeric entity.
     *
     * Equivalent to the `Decimal character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNumericDecimal(str, offset) {
      const startIdx = offset;
      while (offset < str.length) {
        const char = str.charCodeAt(offset);
        if (isNumber2(char)) {
          offset += 1;
        } else {
          this.addToNumericResult(str, startIdx, offset, 10);
          return this.emitNumericEntity(char, 2);
        }
      }
      this.addToNumericResult(str, startIdx, offset, 10);
      return -1;
    }
    /**
     * Validate and emit a numeric entity.
     *
     * Implements the logic from the `Hexademical character reference start
     * state` and `Numeric character reference end state` in the HTML spec.
     *
     * @param lastCp The last code point of the entity. Used to see if the
     *               entity was terminated with a semicolon.
     * @param expectedLength The minimum number of characters that should be
     *                       consumed. Used to validate that at least one digit
     *                       was consumed.
     * @returns The number of characters that were consumed.
     */
    emitNumericEntity(lastCp, expectedLength) {
      var _a3;
      if (this.consumed <= expectedLength) {
        (_a3 = this.errors) === null || _a3 === void 0 ? void 0 : _a3.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      if (lastCp === CharCodes2.SEMI) {
        this.consumed += 1;
      } else if (this.decodeMode === DecodingMode2.Strict) {
        return 0;
      }
      this.emitCodePoint(replaceCodePoint2(this.result), this.consumed);
      if (this.errors) {
        if (lastCp !== CharCodes2.SEMI) {
          this.errors.missingSemicolonAfterCharacterReference();
        }
        this.errors.validateNumericCharacterReference(this.result);
      }
      return this.consumed;
    }
    /**
     * Parses a named entity.
     *
     * Equivalent to the `Named character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNamedEntity(str, offset) {
      const { decodeTree } = this;
      let current = decodeTree[this.treeIndex];
      let valueLength = (current & BinTrieFlags2.VALUE_LENGTH) >> 14;
      for (; offset < str.length; offset++, this.excess++) {
        const char = str.charCodeAt(offset);
        this.treeIndex = determineBranch2(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
        if (this.treeIndex < 0) {
          return this.result === 0 || // If we are parsing an attribute
          this.decodeMode === DecodingMode2.Attribute && // We shouldn't have consumed any characters after the entity,
          (valueLength === 0 || // And there should be no invalid characters.
          isEntityInAttributeInvalidEnd2(char)) ? 0 : this.emitNotTerminatedNamedEntity();
        }
        current = decodeTree[this.treeIndex];
        valueLength = (current & BinTrieFlags2.VALUE_LENGTH) >> 14;
        if (valueLength !== 0) {
          if (char === CharCodes2.SEMI) {
            return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
          }
          if (this.decodeMode !== DecodingMode2.Strict) {
            this.result = this.treeIndex;
            this.consumed += this.excess;
            this.excess = 0;
          }
        }
      }
      return -1;
    }
    /**
     * Emit a named entity that was not terminated with a semicolon.
     *
     * @returns The number of characters consumed.
     */
    emitNotTerminatedNamedEntity() {
      var _a3;
      const { result, decodeTree } = this;
      const valueLength = (decodeTree[result] & BinTrieFlags2.VALUE_LENGTH) >> 14;
      this.emitNamedEntityData(result, valueLength, this.consumed);
      (_a3 = this.errors) === null || _a3 === void 0 ? void 0 : _a3.missingSemicolonAfterCharacterReference();
      return this.consumed;
    }
    /**
     * Emit a named entity.
     *
     * @param result The index of the entity in the decode tree.
     * @param valueLength The number of bytes in the entity.
     * @param consumed The number of characters consumed.
     *
     * @returns The number of characters consumed.
     */
    emitNamedEntityData(result, valueLength, consumed) {
      const { decodeTree } = this;
      this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags2.VALUE_LENGTH : decodeTree[result + 1], consumed);
      if (valueLength === 3) {
        this.emitCodePoint(decodeTree[result + 2], consumed);
      }
      return consumed;
    }
    /**
     * Signal to the parser that the end of the input was reached.
     *
     * Remaining data will be emitted and relevant errors will be produced.
     *
     * @returns The number of characters consumed.
     */
    end() {
      var _a3;
      switch (this.state) {
        case EntityDecoderState2.NamedEntity: {
          return this.result !== 0 && (this.decodeMode !== DecodingMode2.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
        }
        case EntityDecoderState2.NumericDecimal: {
          return this.emitNumericEntity(0, 2);
        }
        case EntityDecoderState2.NumericHex: {
          return this.emitNumericEntity(0, 3);
        }
        case EntityDecoderState2.NumericStart: {
          (_a3 = this.errors) === null || _a3 === void 0 ? void 0 : _a3.absenceOfDigitsInNumericCharacterReference(this.consumed);
          return 0;
        }
        case EntityDecoderState2.EntityStart: {
          return 0;
        }
      }
    }
  };
  function getDecoder2(decodeTree) {
    let ret = "";
    const decoder = new EntityDecoder2(decodeTree, (str) => ret += fromCodePoint2(str));
    return function decodeWithTrie(str, decodeMode) {
      let lastIndex = 0;
      let offset = 0;
      while ((offset = str.indexOf("&", offset)) >= 0) {
        ret += str.slice(lastIndex, offset);
        decoder.startEntity(decodeMode);
        const len = decoder.write(
          str,
          // Skip the "&"
          offset + 1
        );
        if (len < 0) {
          lastIndex = offset + decoder.end();
          break;
        }
        lastIndex = offset + len;
        offset = len === 0 ? lastIndex + 1 : lastIndex;
      }
      const result = ret + str.slice(lastIndex);
      ret = "";
      return result;
    };
  }
  function determineBranch2(decodeTree, current, nodeIdx, char) {
    const branchCount = (current & BinTrieFlags2.BRANCH_LENGTH) >> 7;
    const jumpOffset = current & BinTrieFlags2.JUMP_TABLE;
    if (branchCount === 0) {
      return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
    }
    if (jumpOffset) {
      const value = char - jumpOffset;
      return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
    }
    let lo = nodeIdx;
    let hi = lo + branchCount - 1;
    while (lo <= hi) {
      const mid = lo + hi >>> 1;
      const midVal = decodeTree[mid];
      if (midVal < char) {
        lo = mid + 1;
      } else if (midVal > char) {
        hi = mid - 1;
      } else {
        return decodeTree[mid + branchCount];
      }
    }
    return -1;
  }
  var htmlDecoder = getDecoder2(decode_data_html_default);
  var xmlDecoder = getDecoder2(decode_data_xml_default);
  function decodeHTML(str, mode = DecodingMode2.Legacy) {
    return htmlDecoder(str, mode);
  }

  // node_modules/entities/lib/esm/generated/encode-html.js
  function restoreDiff(arr) {
    for (let i = 1; i < arr.length; i++) {
      arr[i][0] += arr[i - 1][0] + 1;
    }
    return arr;
  }
  var encode_html_default = new Map(/* @__PURE__ */ restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));

  // node_modules/entities/lib/esm/escape.js
  var xmlCodeMap2 = /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [39, "&apos;"],
    [60, "&lt;"],
    [62, "&gt;"]
  ]);
  var getCodePoint2 = (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.prototype.codePointAt != null ? (str, index2) => str.codePointAt(index2) : (
      // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      (c, index2) => (c.charCodeAt(index2) & 64512) === 55296 ? (c.charCodeAt(index2) - 55296) * 1024 + c.charCodeAt(index2 + 1) - 56320 + 65536 : c.charCodeAt(index2)
    )
  );
  function getEscaper2(regex, map4) {
    return function escape3(data2) {
      let match2;
      let lastIdx = 0;
      let result = "";
      while (match2 = regex.exec(data2)) {
        if (lastIdx !== match2.index) {
          result += data2.substring(lastIdx, match2.index);
        }
        result += map4.get(match2[0].charCodeAt(0));
        lastIdx = match2.index + 1;
      }
      return result + data2.substring(lastIdx);
    };
  }
  var escapeUTF8 = getEscaper2(/[&<>'"]/g, xmlCodeMap2);
  var escapeAttribute2 = getEscaper2(/["&\u00A0]/g, /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [160, "&nbsp;"]
  ]));
  var escapeText2 = getEscaper2(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [160, "&nbsp;"]
  ]));

  // node_modules/entities/lib/esm/index.js
  var EntityLevel;
  (function(EntityLevel2) {
    EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
    EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
  })(EntityLevel || (EntityLevel = {}));
  var EncodingMode;
  (function(EncodingMode2) {
    EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
    EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
    EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
    EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
    EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
  })(EncodingMode || (EncodingMode = {}));

  // node_modules/markdown-it/lib/common/utils.mjs
  function _class(obj) {
    return Object.prototype.toString.call(obj);
  }
  function isString(obj) {
    return _class(obj) === "[object String]";
  }
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  function has2(object, key) {
    return _hasOwnProperty.call(object, key);
  }
  function assign(obj) {
    const sources = Array.prototype.slice.call(arguments, 1);
    sources.forEach(function(source) {
      if (!source) {
        return;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be object");
      }
      Object.keys(source).forEach(function(key) {
        obj[key] = source[key];
      });
    });
    return obj;
  }
  function arrayReplaceAt(src, pos, newElements) {
    return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
  }
  function isValidEntityCode(c) {
    if (c >= 55296 && c <= 57343) {
      return false;
    }
    if (c >= 64976 && c <= 65007) {
      return false;
    }
    if ((c & 65535) === 65535 || (c & 65535) === 65534) {
      return false;
    }
    if (c >= 0 && c <= 8) {
      return false;
    }
    if (c === 11) {
      return false;
    }
    if (c >= 14 && c <= 31) {
      return false;
    }
    if (c >= 127 && c <= 159) {
      return false;
    }
    if (c > 1114111) {
      return false;
    }
    return true;
  }
  function fromCodePoint3(c) {
    if (c > 65535) {
      c -= 65536;
      const surrogate1 = 55296 + (c >> 10);
      const surrogate2 = 56320 + (c & 1023);
      return String.fromCharCode(surrogate1, surrogate2);
    }
    return String.fromCharCode(c);
  }
  var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g;
  var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
  var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
  var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
  function replaceEntityPattern(match2, name2) {
    if (name2.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name2)) {
      const code2 = name2[1].toLowerCase() === "x" ? parseInt(name2.slice(2), 16) : parseInt(name2.slice(1), 10);
      if (isValidEntityCode(code2)) {
        return fromCodePoint3(code2);
      }
      return match2;
    }
    const decoded = decodeHTML(match2);
    if (decoded !== match2) {
      return decoded;
    }
    return match2;
  }
  function unescapeMd(str) {
    if (str.indexOf("\\") < 0) {
      return str;
    }
    return str.replace(UNESCAPE_MD_RE, "$1");
  }
  function unescapeAll(str) {
    if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
      return str;
    }
    return str.replace(UNESCAPE_ALL_RE, function(match2, escaped, entity2) {
      if (escaped) {
        return escaped;
      }
      return replaceEntityPattern(match2, entity2);
    });
  }
  var HTML_ESCAPE_TEST_RE = /[&<>"]/;
  var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
  var HTML_REPLACEMENTS = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;"
  };
  function replaceUnsafeChar(ch) {
    return HTML_REPLACEMENTS[ch];
  }
  function escapeHtml(str) {
    if (HTML_ESCAPE_TEST_RE.test(str)) {
      return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
    }
    return str;
  }
  var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
  function escapeRE(str) {
    return str.replace(REGEXP_ESCAPE_RE, "\\$&");
  }
  function isSpace(code2) {
    switch (code2) {
      case 9:
      case 32:
        return true;
    }
    return false;
  }
  function isWhiteSpace(code2) {
    if (code2 >= 8192 && code2 <= 8202) {
      return true;
    }
    switch (code2) {
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 32:
      case 160:
      case 5760:
      case 8239:
      case 8287:
      case 12288:
        return true;
    }
    return false;
  }
  function isPunctChar(ch) {
    return regex_default4.test(ch) || regex_default5.test(ch);
  }
  function isMdAsciiPunct(ch) {
    switch (ch) {
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 123:
      case 124:
      case 125:
      case 126:
        return true;
      default:
        return false;
    }
  }
  function normalizeReference(str) {
    str = str.trim().replace(/\s+/g, " ");
    if ("\u1E9E".toLowerCase() === "\u1E7E") {
      str = str.replace(/ẞ/g, "\xDF");
    }
    return str.toLowerCase().toUpperCase();
  }
  var lib = { mdurl: mdurl_exports, ucmicro: uc_exports };

  // node_modules/markdown-it/lib/helpers/index.mjs
  var helpers_exports = {};
  __export(helpers_exports, {
    parseLinkDestination: () => parseLinkDestination,
    parseLinkLabel: () => parseLinkLabel,
    parseLinkTitle: () => parseLinkTitle
  });

  // node_modules/markdown-it/lib/helpers/parse_link_label.mjs
  function parseLinkLabel(state, start2, disableNested) {
    let level, found, marker, prevPos;
    const max3 = state.posMax;
    const oldPos = state.pos;
    state.pos = start2 + 1;
    level = 1;
    while (state.pos < max3) {
      marker = state.src.charCodeAt(state.pos);
      if (marker === 93) {
        level--;
        if (level === 0) {
          found = true;
          break;
        }
      }
      prevPos = state.pos;
      state.md.inline.skipToken(state);
      if (marker === 91) {
        if (prevPos === state.pos - 1) {
          level++;
        } else if (disableNested) {
          state.pos = oldPos;
          return -1;
        }
      }
    }
    let labelEnd = -1;
    if (found) {
      labelEnd = state.pos;
    }
    state.pos = oldPos;
    return labelEnd;
  }

  // node_modules/markdown-it/lib/helpers/parse_link_destination.mjs
  function parseLinkDestination(str, start2, max3) {
    let code2;
    let pos = start2;
    const result = {
      ok: false,
      pos: 0,
      str: ""
    };
    if (str.charCodeAt(pos) === 60) {
      pos++;
      while (pos < max3) {
        code2 = str.charCodeAt(pos);
        if (code2 === 10) {
          return result;
        }
        if (code2 === 60) {
          return result;
        }
        if (code2 === 62) {
          result.pos = pos + 1;
          result.str = unescapeAll(str.slice(start2 + 1, pos));
          result.ok = true;
          return result;
        }
        if (code2 === 92 && pos + 1 < max3) {
          pos += 2;
          continue;
        }
        pos++;
      }
      return result;
    }
    let level = 0;
    while (pos < max3) {
      code2 = str.charCodeAt(pos);
      if (code2 === 32) {
        break;
      }
      if (code2 < 32 || code2 === 127) {
        break;
      }
      if (code2 === 92 && pos + 1 < max3) {
        if (str.charCodeAt(pos + 1) === 32) {
          break;
        }
        pos += 2;
        continue;
      }
      if (code2 === 40) {
        level++;
        if (level > 32) {
          return result;
        }
      }
      if (code2 === 41) {
        if (level === 0) {
          break;
        }
        level--;
      }
      pos++;
    }
    if (start2 === pos) {
      return result;
    }
    if (level !== 0) {
      return result;
    }
    result.str = unescapeAll(str.slice(start2, pos));
    result.pos = pos;
    result.ok = true;
    return result;
  }

  // node_modules/markdown-it/lib/helpers/parse_link_title.mjs
  function parseLinkTitle(str, start2, max3, prev_state) {
    let code2;
    let pos = start2;
    const state = {
      // if `true`, this is a valid link title
      ok: false,
      // if `true`, this link can be continued on the next line
      can_continue: false,
      // if `ok`, it's the position of the first character after the closing marker
      pos: 0,
      // if `ok`, it's the unescaped title
      str: "",
      // expected closing marker character code
      marker: 0
    };
    if (prev_state) {
      state.str = prev_state.str;
      state.marker = prev_state.marker;
    } else {
      if (pos >= max3) {
        return state;
      }
      let marker = str.charCodeAt(pos);
      if (marker !== 34 && marker !== 39 && marker !== 40) {
        return state;
      }
      start2++;
      pos++;
      if (marker === 40) {
        marker = 41;
      }
      state.marker = marker;
    }
    while (pos < max3) {
      code2 = str.charCodeAt(pos);
      if (code2 === state.marker) {
        state.pos = pos + 1;
        state.str += unescapeAll(str.slice(start2, pos));
        state.ok = true;
        return state;
      } else if (code2 === 40 && state.marker === 41) {
        return state;
      } else if (code2 === 92 && pos + 1 < max3) {
        pos++;
      }
      pos++;
    }
    state.can_continue = true;
    state.str += unescapeAll(str.slice(start2, pos));
    return state;
  }

  // node_modules/markdown-it/lib/renderer.mjs
  var default_rules = {};
  default_rules.code_inline = function(tokens, idx, options, env, slf) {
    const token = tokens[idx];
    return "<code" + slf.renderAttrs(token) + ">" + escapeHtml(token.content) + "</code>";
  };
  default_rules.code_block = function(tokens, idx, options, env, slf) {
    const token = tokens[idx];
    return "<pre" + slf.renderAttrs(token) + "><code>" + escapeHtml(tokens[idx].content) + "</code></pre>\n";
  };
  default_rules.fence = function(tokens, idx, options, env, slf) {
    const token = tokens[idx];
    const info = token.info ? unescapeAll(token.info).trim() : "";
    let langName = "";
    let langAttrs = "";
    if (info) {
      const arr = info.split(/(\s+)/g);
      langName = arr[0];
      langAttrs = arr.slice(2).join("");
    }
    let highlighted;
    if (options.highlight) {
      highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);
    } else {
      highlighted = escapeHtml(token.content);
    }
    if (highlighted.indexOf("<pre") === 0) {
      return highlighted + "\n";
    }
    if (info) {
      const i = token.attrIndex("class");
      const tmpAttrs = token.attrs ? token.attrs.slice() : [];
      if (i < 0) {
        tmpAttrs.push(["class", options.langPrefix + langName]);
      } else {
        tmpAttrs[i] = tmpAttrs[i].slice();
        tmpAttrs[i][1] += " " + options.langPrefix + langName;
      }
      const tmpToken = {
        attrs: tmpAttrs
      };
      return `<pre><code${slf.renderAttrs(tmpToken)}>${highlighted}</code></pre>
`;
    }
    return `<pre><code${slf.renderAttrs(token)}>${highlighted}</code></pre>
`;
  };
  default_rules.image = function(tokens, idx, options, env, slf) {
    const token = tokens[idx];
    token.attrs[token.attrIndex("alt")][1] = slf.renderInlineAsText(token.children, options, env);
    return slf.renderToken(tokens, idx, options);
  };
  default_rules.hardbreak = function(tokens, idx, options) {
    return options.xhtmlOut ? "<br />\n" : "<br>\n";
  };
  default_rules.softbreak = function(tokens, idx, options) {
    return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
  };
  default_rules.text = function(tokens, idx) {
    return escapeHtml(tokens[idx].content);
  };
  default_rules.html_block = function(tokens, idx) {
    return tokens[idx].content;
  };
  default_rules.html_inline = function(tokens, idx) {
    return tokens[idx].content;
  };
  function Renderer() {
    this.rules = assign({}, default_rules);
  }
  Renderer.prototype.renderAttrs = function renderAttrs(token) {
    let i, l, result;
    if (!token.attrs) {
      return "";
    }
    result = "";
    for (i = 0, l = token.attrs.length; i < l; i++) {
      result += " " + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
    }
    return result;
  };
  Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
    const token = tokens[idx];
    let result = "";
    if (token.hidden) {
      return "";
    }
    if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
      result += "\n";
    }
    result += (token.nesting === -1 ? "</" : "<") + token.tag;
    result += this.renderAttrs(token);
    if (token.nesting === 0 && options.xhtmlOut) {
      result += " /";
    }
    let needLf = false;
    if (token.block) {
      needLf = true;
      if (token.nesting === 1) {
        if (idx + 1 < tokens.length) {
          const nextToken = tokens[idx + 1];
          if (nextToken.type === "inline" || nextToken.hidden) {
            needLf = false;
          } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
            needLf = false;
          }
        }
      }
    }
    result += needLf ? ">\n" : ">";
    return result;
  };
  Renderer.prototype.renderInline = function(tokens, options, env) {
    let result = "";
    const rules = this.rules;
    for (let i = 0, len = tokens.length; i < len; i++) {
      const type2 = tokens[i].type;
      if (typeof rules[type2] !== "undefined") {
        result += rules[type2](tokens, i, options, env, this);
      } else {
        result += this.renderToken(tokens, i, options);
      }
    }
    return result;
  };
  Renderer.prototype.renderInlineAsText = function(tokens, options, env) {
    let result = "";
    for (let i = 0, len = tokens.length; i < len; i++) {
      switch (tokens[i].type) {
        case "text":
          result += tokens[i].content;
          break;
        case "image":
          result += this.renderInlineAsText(tokens[i].children, options, env);
          break;
        case "html_inline":
        case "html_block":
          result += tokens[i].content;
          break;
        case "softbreak":
        case "hardbreak":
          result += "\n";
          break;
        default:
      }
    }
    return result;
  };
  Renderer.prototype.render = function(tokens, options, env) {
    let result = "";
    const rules = this.rules;
    for (let i = 0, len = tokens.length; i < len; i++) {
      const type2 = tokens[i].type;
      if (type2 === "inline") {
        result += this.renderInline(tokens[i].children, options, env);
      } else if (typeof rules[type2] !== "undefined") {
        result += rules[type2](tokens, i, options, env, this);
      } else {
        result += this.renderToken(tokens, i, options, env);
      }
    }
    return result;
  };
  var renderer_default = Renderer;

  // node_modules/markdown-it/lib/ruler.mjs
  function Ruler() {
    this.__rules__ = [];
    this.__cache__ = null;
  }
  Ruler.prototype.__find__ = function(name2) {
    for (let i = 0; i < this.__rules__.length; i++) {
      if (this.__rules__[i].name === name2) {
        return i;
      }
    }
    return -1;
  };
  Ruler.prototype.__compile__ = function() {
    const self2 = this;
    const chains = [""];
    self2.__rules__.forEach(function(rule) {
      if (!rule.enabled) {
        return;
      }
      rule.alt.forEach(function(altName) {
        if (chains.indexOf(altName) < 0) {
          chains.push(altName);
        }
      });
    });
    self2.__cache__ = {};
    chains.forEach(function(chain) {
      self2.__cache__[chain] = [];
      self2.__rules__.forEach(function(rule) {
        if (!rule.enabled) {
          return;
        }
        if (chain && rule.alt.indexOf(chain) < 0) {
          return;
        }
        self2.__cache__[chain].push(rule.fn);
      });
    });
  };
  Ruler.prototype.at = function(name2, fn, options) {
    const index2 = this.__find__(name2);
    const opt = options || {};
    if (index2 === -1) {
      throw new Error("Parser rule not found: " + name2);
    }
    this.__rules__[index2].fn = fn;
    this.__rules__[index2].alt = opt.alt || [];
    this.__cache__ = null;
  };
  Ruler.prototype.before = function(beforeName, ruleName, fn, options) {
    const index2 = this.__find__(beforeName);
    const opt = options || {};
    if (index2 === -1) {
      throw new Error("Parser rule not found: " + beforeName);
    }
    this.__rules__.splice(index2, 0, {
      name: ruleName,
      enabled: true,
      fn,
      alt: opt.alt || []
    });
    this.__cache__ = null;
  };
  Ruler.prototype.after = function(afterName, ruleName, fn, options) {
    const index2 = this.__find__(afterName);
    const opt = options || {};
    if (index2 === -1) {
      throw new Error("Parser rule not found: " + afterName);
    }
    this.__rules__.splice(index2 + 1, 0, {
      name: ruleName,
      enabled: true,
      fn,
      alt: opt.alt || []
    });
    this.__cache__ = null;
  };
  Ruler.prototype.push = function(ruleName, fn, options) {
    const opt = options || {};
    this.__rules__.push({
      name: ruleName,
      enabled: true,
      fn,
      alt: opt.alt || []
    });
    this.__cache__ = null;
  };
  Ruler.prototype.enable = function(list2, ignoreInvalid) {
    if (!Array.isArray(list2)) {
      list2 = [list2];
    }
    const result = [];
    list2.forEach(function(name2) {
      const idx = this.__find__(name2);
      if (idx < 0) {
        if (ignoreInvalid) {
          return;
        }
        throw new Error("Rules manager: invalid rule name " + name2);
      }
      this.__rules__[idx].enabled = true;
      result.push(name2);
    }, this);
    this.__cache__ = null;
    return result;
  };
  Ruler.prototype.enableOnly = function(list2, ignoreInvalid) {
    if (!Array.isArray(list2)) {
      list2 = [list2];
    }
    this.__rules__.forEach(function(rule) {
      rule.enabled = false;
    });
    this.enable(list2, ignoreInvalid);
  };
  Ruler.prototype.disable = function(list2, ignoreInvalid) {
    if (!Array.isArray(list2)) {
      list2 = [list2];
    }
    const result = [];
    list2.forEach(function(name2) {
      const idx = this.__find__(name2);
      if (idx < 0) {
        if (ignoreInvalid) {
          return;
        }
        throw new Error("Rules manager: invalid rule name " + name2);
      }
      this.__rules__[idx].enabled = false;
      result.push(name2);
    }, this);
    this.__cache__ = null;
    return result;
  };
  Ruler.prototype.getRules = function(chainName) {
    if (this.__cache__ === null) {
      this.__compile__();
    }
    return this.__cache__[chainName] || [];
  };
  var ruler_default = Ruler;

  // node_modules/markdown-it/lib/token.mjs
  function Token(type2, tag, nesting) {
    this.type = type2;
    this.tag = tag;
    this.attrs = null;
    this.map = null;
    this.nesting = nesting;
    this.level = 0;
    this.children = null;
    this.content = "";
    this.markup = "";
    this.info = "";
    this.meta = null;
    this.block = false;
    this.hidden = false;
  }
  Token.prototype.attrIndex = function attrIndex(name2) {
    if (!this.attrs) {
      return -1;
    }
    const attrs = this.attrs;
    for (let i = 0, len = attrs.length; i < len; i++) {
      if (attrs[i][0] === name2) {
        return i;
      }
    }
    return -1;
  };
  Token.prototype.attrPush = function attrPush(attrData) {
    if (this.attrs) {
      this.attrs.push(attrData);
    } else {
      this.attrs = [attrData];
    }
  };
  Token.prototype.attrSet = function attrSet(name2, value) {
    const idx = this.attrIndex(name2);
    const attrData = [name2, value];
    if (idx < 0) {
      this.attrPush(attrData);
    } else {
      this.attrs[idx] = attrData;
    }
  };
  Token.prototype.attrGet = function attrGet(name2) {
    const idx = this.attrIndex(name2);
    let value = null;
    if (idx >= 0) {
      value = this.attrs[idx][1];
    }
    return value;
  };
  Token.prototype.attrJoin = function attrJoin(name2, value) {
    const idx = this.attrIndex(name2);
    if (idx < 0) {
      this.attrPush([name2, value]);
    } else {
      this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
    }
  };
  var token_default = Token;

  // node_modules/markdown-it/lib/rules_core/state_core.mjs
  function StateCore(src, md, env) {
    this.src = src;
    this.env = env;
    this.tokens = [];
    this.inlineMode = false;
    this.md = md;
  }
  StateCore.prototype.Token = token_default;
  var state_core_default = StateCore;

  // node_modules/markdown-it/lib/rules_core/normalize.mjs
  var NEWLINES_RE = /\r\n?|\n/g;
  var NULL_RE = /\0/g;
  function normalize(state) {
    let str;
    str = state.src.replace(NEWLINES_RE, "\n");
    str = str.replace(NULL_RE, "\uFFFD");
    state.src = str;
  }

  // node_modules/markdown-it/lib/rules_core/block.mjs
  function block(state) {
    let token;
    if (state.inlineMode) {
      token = new state.Token("inline", "", 0);
      token.content = state.src;
      token.map = [0, 1];
      token.children = [];
      state.tokens.push(token);
    } else {
      state.md.block.parse(state.src, state.md, state.env, state.tokens);
    }
  }

  // node_modules/markdown-it/lib/rules_core/inline.mjs
  function inline(state) {
    const tokens = state.tokens;
    for (let i = 0, l = tokens.length; i < l; i++) {
      const tok = tokens[i];
      if (tok.type === "inline") {
        state.md.inline.parse(tok.content, state.md, state.env, tok.children);
      }
    }
  }

  // node_modules/markdown-it/lib/rules_core/linkify.mjs
  function isLinkOpen(str) {
    return /^<a[>\s]/i.test(str);
  }
  function isLinkClose(str) {
    return /^<\/a\s*>/i.test(str);
  }
  function linkify(state) {
    const blockTokens = state.tokens;
    if (!state.md.options.linkify) {
      return;
    }
    for (let j2 = 0, l = blockTokens.length; j2 < l; j2++) {
      if (blockTokens[j2].type !== "inline" || !state.md.linkify.pretest(blockTokens[j2].content)) {
        continue;
      }
      let tokens = blockTokens[j2].children;
      let htmlLinkLevel = 0;
      for (let i = tokens.length - 1; i >= 0; i--) {
        const currentToken = tokens[i];
        if (currentToken.type === "link_close") {
          i--;
          while (tokens[i].level !== currentToken.level && tokens[i].type !== "link_open") {
            i--;
          }
          continue;
        }
        if (currentToken.type === "html_inline") {
          if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
            htmlLinkLevel--;
          }
          if (isLinkClose(currentToken.content)) {
            htmlLinkLevel++;
          }
        }
        if (htmlLinkLevel > 0) {
          continue;
        }
        if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
          const text3 = currentToken.content;
          let links = state.md.linkify.match(text3);
          const nodes = [];
          let level = currentToken.level;
          let lastPos = 0;
          if (links.length > 0 && links[0].index === 0 && i > 0 && tokens[i - 1].type === "text_special") {
            links = links.slice(1);
          }
          for (let ln = 0; ln < links.length; ln++) {
            const url = links[ln].url;
            const fullUrl = state.md.normalizeLink(url);
            if (!state.md.validateLink(fullUrl)) {
              continue;
            }
            let urlText = links[ln].text;
            if (!links[ln].schema) {
              urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
            } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
              urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
            } else {
              urlText = state.md.normalizeLinkText(urlText);
            }
            const pos = links[ln].index;
            if (pos > lastPos) {
              const token = new state.Token("text", "", 0);
              token.content = text3.slice(lastPos, pos);
              token.level = level;
              nodes.push(token);
            }
            const token_o = new state.Token("link_open", "a", 1);
            token_o.attrs = [["href", fullUrl]];
            token_o.level = level++;
            token_o.markup = "linkify";
            token_o.info = "auto";
            nodes.push(token_o);
            const token_t = new state.Token("text", "", 0);
            token_t.content = urlText;
            token_t.level = level;
            nodes.push(token_t);
            const token_c = new state.Token("link_close", "a", -1);
            token_c.level = --level;
            token_c.markup = "linkify";
            token_c.info = "auto";
            nodes.push(token_c);
            lastPos = links[ln].lastIndex;
          }
          if (lastPos < text3.length) {
            const token = new state.Token("text", "", 0);
            token.content = text3.slice(lastPos);
            token.level = level;
            nodes.push(token);
          }
          blockTokens[j2].children = tokens = arrayReplaceAt(tokens, i, nodes);
        }
      }
    }
  }

  // node_modules/markdown-it/lib/rules_core/replacements.mjs
  var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
  var SCOPED_ABBR_TEST_RE = /\((c|tm|r)\)/i;
  var SCOPED_ABBR_RE = /\((c|tm|r)\)/ig;
  var SCOPED_ABBR = {
    c: "\xA9",
    r: "\xAE",
    tm: "\u2122"
  };
  function replaceFn(match2, name2) {
    return SCOPED_ABBR[name2.toLowerCase()];
  }
  function replace_scoped(inlineTokens) {
    let inside_autolink = 0;
    for (let i = inlineTokens.length - 1; i >= 0; i--) {
      const token = inlineTokens[i];
      if (token.type === "text" && !inside_autolink) {
        token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
      }
      if (token.type === "link_open" && token.info === "auto") {
        inside_autolink--;
      }
      if (token.type === "link_close" && token.info === "auto") {
        inside_autolink++;
      }
    }
  }
  function replace_rare(inlineTokens) {
    let inside_autolink = 0;
    for (let i = inlineTokens.length - 1; i >= 0; i--) {
      const token = inlineTokens[i];
      if (token.type === "text" && !inside_autolink) {
        if (RARE_RE.test(token.content)) {
          token.content = token.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013");
        }
      }
      if (token.type === "link_open" && token.info === "auto") {
        inside_autolink--;
      }
      if (token.type === "link_close" && token.info === "auto") {
        inside_autolink++;
      }
    }
  }
  function replace(state) {
    let blkIdx;
    if (!state.md.options.typographer) {
      return;
    }
    for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
      if (state.tokens[blkIdx].type !== "inline") {
        continue;
      }
      if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
        replace_scoped(state.tokens[blkIdx].children);
      }
      if (RARE_RE.test(state.tokens[blkIdx].content)) {
        replace_rare(state.tokens[blkIdx].children);
      }
    }
  }

  // node_modules/markdown-it/lib/rules_core/smartquotes.mjs
  var QUOTE_TEST_RE = /['"]/;
  var QUOTE_RE = /['"]/g;
  var APOSTROPHE = "\u2019";
  function replaceAt(str, index2, ch) {
    return str.slice(0, index2) + ch + str.slice(index2 + 1);
  }
  function process_inlines(tokens, state) {
    let j2;
    const stack = [];
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      const thisLevel = tokens[i].level;
      for (j2 = stack.length - 1; j2 >= 0; j2--) {
        if (stack[j2].level <= thisLevel) {
          break;
        }
      }
      stack.length = j2 + 1;
      if (token.type !== "text") {
        continue;
      }
      let text3 = token.content;
      let pos = 0;
      let max3 = text3.length;
      OUTER:
        while (pos < max3) {
          QUOTE_RE.lastIndex = pos;
          const t = QUOTE_RE.exec(text3);
          if (!t) {
            break;
          }
          let canOpen = true;
          let canClose = true;
          pos = t.index + 1;
          const isSingle = t[0] === "'";
          let lastChar = 32;
          if (t.index - 1 >= 0) {
            lastChar = text3.charCodeAt(t.index - 1);
          } else {
            for (j2 = i - 1; j2 >= 0; j2--) {
              if (tokens[j2].type === "softbreak" || tokens[j2].type === "hardbreak") break;
              if (!tokens[j2].content) continue;
              lastChar = tokens[j2].content.charCodeAt(tokens[j2].content.length - 1);
              break;
            }
          }
          let nextChar = 32;
          if (pos < max3) {
            nextChar = text3.charCodeAt(pos);
          } else {
            for (j2 = i + 1; j2 < tokens.length; j2++) {
              if (tokens[j2].type === "softbreak" || tokens[j2].type === "hardbreak") break;
              if (!tokens[j2].content) continue;
              nextChar = tokens[j2].content.charCodeAt(0);
              break;
            }
          }
          const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
          const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
          const isLastWhiteSpace = isWhiteSpace(lastChar);
          const isNextWhiteSpace = isWhiteSpace(nextChar);
          if (isNextWhiteSpace) {
            canOpen = false;
          } else if (isNextPunctChar) {
            if (!(isLastWhiteSpace || isLastPunctChar)) {
              canOpen = false;
            }
          }
          if (isLastWhiteSpace) {
            canClose = false;
          } else if (isLastPunctChar) {
            if (!(isNextWhiteSpace || isNextPunctChar)) {
              canClose = false;
            }
          }
          if (nextChar === 34 && t[0] === '"') {
            if (lastChar >= 48 && lastChar <= 57) {
              canClose = canOpen = false;
            }
          }
          if (canOpen && canClose) {
            canOpen = isLastPunctChar;
            canClose = isNextPunctChar;
          }
          if (!canOpen && !canClose) {
            if (isSingle) {
              token.content = replaceAt(token.content, t.index, APOSTROPHE);
            }
            continue;
          }
          if (canClose) {
            for (j2 = stack.length - 1; j2 >= 0; j2--) {
              let item = stack[j2];
              if (stack[j2].level < thisLevel) {
                break;
              }
              if (item.single === isSingle && stack[j2].level === thisLevel) {
                item = stack[j2];
                let openQuote;
                let closeQuote;
                if (isSingle) {
                  openQuote = state.md.options.quotes[2];
                  closeQuote = state.md.options.quotes[3];
                } else {
                  openQuote = state.md.options.quotes[0];
                  closeQuote = state.md.options.quotes[1];
                }
                token.content = replaceAt(token.content, t.index, closeQuote);
                tokens[item.token].content = replaceAt(
                  tokens[item.token].content,
                  item.pos,
                  openQuote
                );
                pos += closeQuote.length - 1;
                if (item.token === i) {
                  pos += openQuote.length - 1;
                }
                text3 = token.content;
                max3 = text3.length;
                stack.length = j2;
                continue OUTER;
              }
            }
          }
          if (canOpen) {
            stack.push({
              token: i,
              pos: t.index,
              single: isSingle,
              level: thisLevel
            });
          } else if (canClose && isSingle) {
            token.content = replaceAt(token.content, t.index, APOSTROPHE);
          }
        }
    }
  }
  function smartquotes(state) {
    if (!state.md.options.typographer) {
      return;
    }
    for (let blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
      if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
        continue;
      }
      process_inlines(state.tokens[blkIdx].children, state);
    }
  }

  // node_modules/markdown-it/lib/rules_core/text_join.mjs
  function text_join(state) {
    let curr, last2;
    const blockTokens = state.tokens;
    const l = blockTokens.length;
    for (let j2 = 0; j2 < l; j2++) {
      if (blockTokens[j2].type !== "inline") continue;
      const tokens = blockTokens[j2].children;
      const max3 = tokens.length;
      for (curr = 0; curr < max3; curr++) {
        if (tokens[curr].type === "text_special") {
          tokens[curr].type = "text";
        }
      }
      for (curr = last2 = 0; curr < max3; curr++) {
        if (tokens[curr].type === "text" && curr + 1 < max3 && tokens[curr + 1].type === "text") {
          tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
        } else {
          if (curr !== last2) {
            tokens[last2] = tokens[curr];
          }
          last2++;
        }
      }
      if (curr !== last2) {
        tokens.length = last2;
      }
    }
  }

  // node_modules/markdown-it/lib/parser_core.mjs
  var _rules = [
    ["normalize", normalize],
    ["block", block],
    ["inline", inline],
    ["linkify", linkify],
    ["replacements", replace],
    ["smartquotes", smartquotes],
    // `text_join` finds `text_special` tokens (for escape sequences)
    // and joins them with the rest of the text
    ["text_join", text_join]
  ];
  function Core() {
    this.ruler = new ruler_default();
    for (let i = 0; i < _rules.length; i++) {
      this.ruler.push(_rules[i][0], _rules[i][1]);
    }
  }
  Core.prototype.process = function(state) {
    const rules = this.ruler.getRules("");
    for (let i = 0, l = rules.length; i < l; i++) {
      rules[i](state);
    }
  };
  Core.prototype.State = state_core_default;
  var parser_core_default = Core;

  // node_modules/markdown-it/lib/rules_block/state_block.mjs
  function StateBlock(src, md, env, tokens) {
    this.src = src;
    this.md = md;
    this.env = env;
    this.tokens = tokens;
    this.bMarks = [];
    this.eMarks = [];
    this.tShift = [];
    this.sCount = [];
    this.bsCount = [];
    this.blkIndent = 0;
    this.line = 0;
    this.lineMax = 0;
    this.tight = false;
    this.ddIndent = -1;
    this.listIndent = -1;
    this.parentType = "root";
    this.level = 0;
    const s = this.src;
    for (let start2 = 0, pos = 0, indent = 0, offset = 0, len = s.length, indent_found = false; pos < len; pos++) {
      const ch = s.charCodeAt(pos);
      if (!indent_found) {
        if (isSpace(ch)) {
          indent++;
          if (ch === 9) {
            offset += 4 - offset % 4;
          } else {
            offset++;
          }
          continue;
        } else {
          indent_found = true;
        }
      }
      if (ch === 10 || pos === len - 1) {
        if (ch !== 10) {
          pos++;
        }
        this.bMarks.push(start2);
        this.eMarks.push(pos);
        this.tShift.push(indent);
        this.sCount.push(offset);
        this.bsCount.push(0);
        indent_found = false;
        indent = 0;
        offset = 0;
        start2 = pos + 1;
      }
    }
    this.bMarks.push(s.length);
    this.eMarks.push(s.length);
    this.tShift.push(0);
    this.sCount.push(0);
    this.bsCount.push(0);
    this.lineMax = this.bMarks.length - 1;
  }
  StateBlock.prototype.push = function(type2, tag, nesting) {
    const token = new token_default(type2, tag, nesting);
    token.block = true;
    if (nesting < 0) this.level--;
    token.level = this.level;
    if (nesting > 0) this.level++;
    this.tokens.push(token);
    return token;
  };
  StateBlock.prototype.isEmpty = function isEmpty(line) {
    return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
  };
  StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
    for (let max3 = this.lineMax; from < max3; from++) {
      if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
        break;
      }
    }
    return from;
  };
  StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
    for (let max3 = this.src.length; pos < max3; pos++) {
      const ch = this.src.charCodeAt(pos);
      if (!isSpace(ch)) {
        break;
      }
    }
    return pos;
  };
  StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min3) {
    if (pos <= min3) {
      return pos;
    }
    while (pos > min3) {
      if (!isSpace(this.src.charCodeAt(--pos))) {
        return pos + 1;
      }
    }
    return pos;
  };
  StateBlock.prototype.skipChars = function skipChars(pos, code2) {
    for (let max3 = this.src.length; pos < max3; pos++) {
      if (this.src.charCodeAt(pos) !== code2) {
        break;
      }
    }
    return pos;
  };
  StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code2, min3) {
    if (pos <= min3) {
      return pos;
    }
    while (pos > min3) {
      if (code2 !== this.src.charCodeAt(--pos)) {
        return pos + 1;
      }
    }
    return pos;
  };
  StateBlock.prototype.getLines = function getLines(begin, end2, indent, keepLastLF) {
    if (begin >= end2) {
      return "";
    }
    const queue = new Array(end2 - begin);
    for (let i = 0, line = begin; line < end2; line++, i++) {
      let lineIndent = 0;
      const lineStart = this.bMarks[line];
      let first2 = lineStart;
      let last2;
      if (line + 1 < end2 || keepLastLF) {
        last2 = this.eMarks[line] + 1;
      } else {
        last2 = this.eMarks[line];
      }
      while (first2 < last2 && lineIndent < indent) {
        const ch = this.src.charCodeAt(first2);
        if (isSpace(ch)) {
          if (ch === 9) {
            lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
          } else {
            lineIndent++;
          }
        } else if (first2 - lineStart < this.tShift[line]) {
          lineIndent++;
        } else {
          break;
        }
        first2++;
      }
      if (lineIndent > indent) {
        queue[i] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first2, last2);
      } else {
        queue[i] = this.src.slice(first2, last2);
      }
    }
    return queue.join("");
  };
  StateBlock.prototype.Token = token_default;
  var state_block_default = StateBlock;

  // node_modules/markdown-it/lib/rules_block/table.mjs
  var MAX_AUTOCOMPLETED_CELLS = 65536;
  function getLine(state, line) {
    const pos = state.bMarks[line] + state.tShift[line];
    const max3 = state.eMarks[line];
    return state.src.slice(pos, max3);
  }
  function escapedSplit(str) {
    const result = [];
    const max3 = str.length;
    let pos = 0;
    let ch = str.charCodeAt(pos);
    let isEscaped = false;
    let lastPos = 0;
    let current = "";
    while (pos < max3) {
      if (ch === 124) {
        if (!isEscaped) {
          result.push(current + str.substring(lastPos, pos));
          current = "";
          lastPos = pos + 1;
        } else {
          current += str.substring(lastPos, pos - 1);
          lastPos = pos;
        }
      }
      isEscaped = ch === 92;
      pos++;
      ch = str.charCodeAt(pos);
    }
    result.push(current + str.substring(lastPos));
    return result;
  }
  function table(state, startLine, endLine, silent) {
    if (startLine + 2 > endLine) {
      return false;
    }
    let nextLine = startLine + 1;
    if (state.sCount[nextLine] < state.blkIndent) {
      return false;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      return false;
    }
    let pos = state.bMarks[nextLine] + state.tShift[nextLine];
    if (pos >= state.eMarks[nextLine]) {
      return false;
    }
    const firstCh = state.src.charCodeAt(pos++);
    if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
      return false;
    }
    if (pos >= state.eMarks[nextLine]) {
      return false;
    }
    const secondCh = state.src.charCodeAt(pos++);
    if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace(secondCh)) {
      return false;
    }
    if (firstCh === 45 && isSpace(secondCh)) {
      return false;
    }
    while (pos < state.eMarks[nextLine]) {
      const ch = state.src.charCodeAt(pos);
      if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace(ch)) {
        return false;
      }
      pos++;
    }
    let lineText = getLine(state, startLine + 1);
    let columns = lineText.split("|");
    const aligns = [];
    for (let i = 0; i < columns.length; i++) {
      const t = columns[i].trim();
      if (!t) {
        if (i === 0 || i === columns.length - 1) {
          continue;
        } else {
          return false;
        }
      }
      if (!/^:?-+:?$/.test(t)) {
        return false;
      }
      if (t.charCodeAt(t.length - 1) === 58) {
        aligns.push(t.charCodeAt(0) === 58 ? "center" : "right");
      } else if (t.charCodeAt(0) === 58) {
        aligns.push("left");
      } else {
        aligns.push("");
      }
    }
    lineText = getLine(state, startLine).trim();
    if (lineText.indexOf("|") === -1) {
      return false;
    }
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    columns = escapedSplit(lineText);
    if (columns.length && columns[0] === "") columns.shift();
    if (columns.length && columns[columns.length - 1] === "") columns.pop();
    const columnCount = columns.length;
    if (columnCount === 0 || columnCount !== aligns.length) {
      return false;
    }
    if (silent) {
      return true;
    }
    const oldParentType = state.parentType;
    state.parentType = "table";
    const terminatorRules = state.md.block.ruler.getRules("blockquote");
    const token_to = state.push("table_open", "table", 1);
    const tableLines = [startLine, 0];
    token_to.map = tableLines;
    const token_tho = state.push("thead_open", "thead", 1);
    token_tho.map = [startLine, startLine + 1];
    const token_htro = state.push("tr_open", "tr", 1);
    token_htro.map = [startLine, startLine + 1];
    for (let i = 0; i < columns.length; i++) {
      const token_ho = state.push("th_open", "th", 1);
      if (aligns[i]) {
        token_ho.attrs = [["style", "text-align:" + aligns[i]]];
      }
      const token_il = state.push("inline", "", 0);
      token_il.content = columns[i].trim();
      token_il.children = [];
      state.push("th_close", "th", -1);
    }
    state.push("tr_close", "tr", -1);
    state.push("thead_close", "thead", -1);
    let tbodyLines;
    let autocompletedCells = 0;
    for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }
      let terminate = false;
      for (let i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) {
        break;
      }
      lineText = getLine(state, nextLine).trim();
      if (!lineText) {
        break;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        break;
      }
      columns = escapedSplit(lineText);
      if (columns.length && columns[0] === "") columns.shift();
      if (columns.length && columns[columns.length - 1] === "") columns.pop();
      autocompletedCells += columnCount - columns.length;
      if (autocompletedCells > MAX_AUTOCOMPLETED_CELLS) {
        break;
      }
      if (nextLine === startLine + 2) {
        const token_tbo = state.push("tbody_open", "tbody", 1);
        token_tbo.map = tbodyLines = [startLine + 2, 0];
      }
      const token_tro = state.push("tr_open", "tr", 1);
      token_tro.map = [nextLine, nextLine + 1];
      for (let i = 0; i < columnCount; i++) {
        const token_tdo = state.push("td_open", "td", 1);
        if (aligns[i]) {
          token_tdo.attrs = [["style", "text-align:" + aligns[i]]];
        }
        const token_il = state.push("inline", "", 0);
        token_il.content = columns[i] ? columns[i].trim() : "";
        token_il.children = [];
        state.push("td_close", "td", -1);
      }
      state.push("tr_close", "tr", -1);
    }
    if (tbodyLines) {
      state.push("tbody_close", "tbody", -1);
      tbodyLines[1] = nextLine;
    }
    state.push("table_close", "table", -1);
    tableLines[1] = nextLine;
    state.parentType = oldParentType;
    state.line = nextLine;
    return true;
  }

  // node_modules/markdown-it/lib/rules_block/code.mjs
  function code(state, startLine, endLine) {
    if (state.sCount[startLine] - state.blkIndent < 4) {
      return false;
    }
    let nextLine = startLine + 1;
    let last2 = nextLine;
    while (nextLine < endLine) {
      if (state.isEmpty(nextLine)) {
        nextLine++;
        continue;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        nextLine++;
        last2 = nextLine;
        continue;
      }
      break;
    }
    state.line = last2;
    const token = state.push("code_block", "code", 0);
    token.content = state.getLines(startLine, last2, 4 + state.blkIndent, false) + "\n";
    token.map = [startLine, state.line];
    return true;
  }

  // node_modules/markdown-it/lib/rules_block/fence.mjs
  function fence(state, startLine, endLine, silent) {
    let pos = state.bMarks[startLine] + state.tShift[startLine];
    let max3 = state.eMarks[startLine];
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    if (pos + 3 > max3) {
      return false;
    }
    const marker = state.src.charCodeAt(pos);
    if (marker !== 126 && marker !== 96) {
      return false;
    }
    let mem = pos;
    pos = state.skipChars(pos, marker);
    let len = pos - mem;
    if (len < 3) {
      return false;
    }
    const markup = state.src.slice(mem, pos);
    const params = state.src.slice(pos, max3);
    if (marker === 96) {
      if (params.indexOf(String.fromCharCode(marker)) >= 0) {
        return false;
      }
    }
    if (silent) {
      return true;
    }
    let nextLine = startLine;
    let haveEndMarker = false;
    for (; ; ) {
      nextLine++;
      if (nextLine >= endLine) {
        break;
      }
      pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
      max3 = state.eMarks[nextLine];
      if (pos < max3 && state.sCount[nextLine] < state.blkIndent) {
        break;
      }
      if (state.src.charCodeAt(pos) !== marker) {
        continue;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        continue;
      }
      pos = state.skipChars(pos, marker);
      if (pos - mem < len) {
        continue;
      }
      pos = state.skipSpaces(pos);
      if (pos < max3) {
        continue;
      }
      haveEndMarker = true;
      break;
    }
    len = state.sCount[startLine];
    state.line = nextLine + (haveEndMarker ? 1 : 0);
    const token = state.push("fence", "code", 0);
    token.info = params;
    token.content = state.getLines(startLine + 1, nextLine, len, true);
    token.markup = markup;
    token.map = [startLine, state.line];
    return true;
  }

  // node_modules/markdown-it/lib/rules_block/blockquote.mjs
  function blockquote(state, startLine, endLine, silent) {
    let pos = state.bMarks[startLine] + state.tShift[startLine];
    let max3 = state.eMarks[startLine];
    const oldLineMax = state.lineMax;
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    if (state.src.charCodeAt(pos) !== 62) {
      return false;
    }
    if (silent) {
      return true;
    }
    const oldBMarks = [];
    const oldBSCount = [];
    const oldSCount = [];
    const oldTShift = [];
    const terminatorRules = state.md.block.ruler.getRules("blockquote");
    const oldParentType = state.parentType;
    state.parentType = "blockquote";
    let lastLineEmpty = false;
    let nextLine;
    for (nextLine = startLine; nextLine < endLine; nextLine++) {
      const isOutdented = state.sCount[nextLine] < state.blkIndent;
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max3 = state.eMarks[nextLine];
      if (pos >= max3) {
        break;
      }
      if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
        let initial = state.sCount[nextLine] + 1;
        let spaceAfterMarker;
        let adjustTab;
        if (state.src.charCodeAt(pos) === 32) {
          pos++;
          initial++;
          adjustTab = false;
          spaceAfterMarker = true;
        } else if (state.src.charCodeAt(pos) === 9) {
          spaceAfterMarker = true;
          if ((state.bsCount[nextLine] + initial) % 4 === 3) {
            pos++;
            initial++;
            adjustTab = false;
          } else {
            adjustTab = true;
          }
        } else {
          spaceAfterMarker = false;
        }
        let offset = initial;
        oldBMarks.push(state.bMarks[nextLine]);
        state.bMarks[nextLine] = pos;
        while (pos < max3) {
          const ch = state.src.charCodeAt(pos);
          if (isSpace(ch)) {
            if (ch === 9) {
              offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
            } else {
              offset++;
            }
          } else {
            break;
          }
          pos++;
        }
        lastLineEmpty = pos >= max3;
        oldBSCount.push(state.bsCount[nextLine]);
        state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] = offset - initial;
        oldTShift.push(state.tShift[nextLine]);
        state.tShift[nextLine] = pos - state.bMarks[nextLine];
        continue;
      }
      if (lastLineEmpty) {
        break;
      }
      let terminate = false;
      for (let i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) {
        state.lineMax = nextLine;
        if (state.blkIndent !== 0) {
          oldBMarks.push(state.bMarks[nextLine]);
          oldBSCount.push(state.bsCount[nextLine]);
          oldTShift.push(state.tShift[nextLine]);
          oldSCount.push(state.sCount[nextLine]);
          state.sCount[nextLine] -= state.blkIndent;
        }
        break;
      }
      oldBMarks.push(state.bMarks[nextLine]);
      oldBSCount.push(state.bsCount[nextLine]);
      oldTShift.push(state.tShift[nextLine]);
      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = -1;
    }
    const oldIndent = state.blkIndent;
    state.blkIndent = 0;
    const token_o = state.push("blockquote_open", "blockquote", 1);
    token_o.markup = ">";
    const lines = [startLine, 0];
    token_o.map = lines;
    state.md.block.tokenize(state, startLine, nextLine);
    const token_c = state.push("blockquote_close", "blockquote", -1);
    token_c.markup = ">";
    state.lineMax = oldLineMax;
    state.parentType = oldParentType;
    lines[1] = state.line;
    for (let i = 0; i < oldTShift.length; i++) {
      state.bMarks[i + startLine] = oldBMarks[i];
      state.tShift[i + startLine] = oldTShift[i];
      state.sCount[i + startLine] = oldSCount[i];
      state.bsCount[i + startLine] = oldBSCount[i];
    }
    state.blkIndent = oldIndent;
    return true;
  }

  // node_modules/markdown-it/lib/rules_block/hr.mjs
  function hr(state, startLine, endLine, silent) {
    const max3 = state.eMarks[startLine];
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    let pos = state.bMarks[startLine] + state.tShift[startLine];
    const marker = state.src.charCodeAt(pos++);
    if (marker !== 42 && marker !== 45 && marker !== 95) {
      return false;
    }
    let cnt = 1;
    while (pos < max3) {
      const ch = state.src.charCodeAt(pos++);
      if (ch !== marker && !isSpace(ch)) {
        return false;
      }
      if (ch === marker) {
        cnt++;
      }
    }
    if (cnt < 3) {
      return false;
    }
    if (silent) {
      return true;
    }
    state.line = startLine + 1;
    const token = state.push("hr", "hr", 0);
    token.map = [startLine, state.line];
    token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
    return true;
  }

  // node_modules/markdown-it/lib/rules_block/list.mjs
  function skipBulletListMarker(state, startLine) {
    const max3 = state.eMarks[startLine];
    let pos = state.bMarks[startLine] + state.tShift[startLine];
    const marker = state.src.charCodeAt(pos++);
    if (marker !== 42 && marker !== 45 && marker !== 43) {
      return -1;
    }
    if (pos < max3) {
      const ch = state.src.charCodeAt(pos);
      if (!isSpace(ch)) {
        return -1;
      }
    }
    return pos;
  }
  function skipOrderedListMarker(state, startLine) {
    const start2 = state.bMarks[startLine] + state.tShift[startLine];
    const max3 = state.eMarks[startLine];
    let pos = start2;
    if (pos + 1 >= max3) {
      return -1;
    }
    let ch = state.src.charCodeAt(pos++);
    if (ch < 48 || ch > 57) {
      return -1;
    }
    for (; ; ) {
      if (pos >= max3) {
        return -1;
      }
      ch = state.src.charCodeAt(pos++);
      if (ch >= 48 && ch <= 57) {
        if (pos - start2 >= 10) {
          return -1;
        }
        continue;
      }
      if (ch === 41 || ch === 46) {
        break;
      }
      return -1;
    }
    if (pos < max3) {
      ch = state.src.charCodeAt(pos);
      if (!isSpace(ch)) {
        return -1;
      }
    }
    return pos;
  }
  function markTightParagraphs(state, idx) {
    const level = state.level + 2;
    for (let i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
      if (state.tokens[i].level === level && state.tokens[i].type === "paragraph_open") {
        state.tokens[i + 2].hidden = true;
        state.tokens[i].hidden = true;
        i += 2;
      }
    }
  }
  function list(state, startLine, endLine, silent) {
    let max3, pos, start2, token;
    let nextLine = startLine;
    let tight = true;
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      return false;
    }
    if (state.listIndent >= 0 && state.sCount[nextLine] - state.listIndent >= 4 && state.sCount[nextLine] < state.blkIndent) {
      return false;
    }
    let isTerminatingParagraph = false;
    if (silent && state.parentType === "paragraph") {
      if (state.sCount[nextLine] >= state.blkIndent) {
        isTerminatingParagraph = true;
      }
    }
    let isOrdered;
    let markerValue;
    let posAfterMarker;
    if ((posAfterMarker = skipOrderedListMarker(state, nextLine)) >= 0) {
      isOrdered = true;
      start2 = state.bMarks[nextLine] + state.tShift[nextLine];
      markerValue = Number(state.src.slice(start2, posAfterMarker - 1));
      if (isTerminatingParagraph && markerValue !== 1) return false;
    } else if ((posAfterMarker = skipBulletListMarker(state, nextLine)) >= 0) {
      isOrdered = false;
    } else {
      return false;
    }
    if (isTerminatingParagraph) {
      if (state.skipSpaces(posAfterMarker) >= state.eMarks[nextLine]) return false;
    }
    if (silent) {
      return true;
    }
    const markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
    const listTokIdx = state.tokens.length;
    if (isOrdered) {
      token = state.push("ordered_list_open", "ol", 1);
      if (markerValue !== 1) {
        token.attrs = [["start", markerValue]];
      }
    } else {
      token = state.push("bullet_list_open", "ul", 1);
    }
    const listLines = [nextLine, 0];
    token.map = listLines;
    token.markup = String.fromCharCode(markerCharCode);
    let prevEmptyEnd = false;
    const terminatorRules = state.md.block.ruler.getRules("list");
    const oldParentType = state.parentType;
    state.parentType = "list";
    while (nextLine < endLine) {
      pos = posAfterMarker;
      max3 = state.eMarks[nextLine];
      const initial = state.sCount[nextLine] + posAfterMarker - (state.bMarks[nextLine] + state.tShift[nextLine]);
      let offset = initial;
      while (pos < max3) {
        const ch = state.src.charCodeAt(pos);
        if (ch === 9) {
          offset += 4 - (offset + state.bsCount[nextLine]) % 4;
        } else if (ch === 32) {
          offset++;
        } else {
          break;
        }
        pos++;
      }
      const contentStart = pos;
      let indentAfterMarker;
      if (contentStart >= max3) {
        indentAfterMarker = 1;
      } else {
        indentAfterMarker = offset - initial;
      }
      if (indentAfterMarker > 4) {
        indentAfterMarker = 1;
      }
      const indent = initial + indentAfterMarker;
      token = state.push("list_item_open", "li", 1);
      token.markup = String.fromCharCode(markerCharCode);
      const itemLines = [nextLine, 0];
      token.map = itemLines;
      if (isOrdered) {
        token.info = state.src.slice(start2, posAfterMarker - 1);
      }
      const oldTight = state.tight;
      const oldTShift = state.tShift[nextLine];
      const oldSCount = state.sCount[nextLine];
      const oldListIndent = state.listIndent;
      state.listIndent = state.blkIndent;
      state.blkIndent = indent;
      state.tight = true;
      state.tShift[nextLine] = contentStart - state.bMarks[nextLine];
      state.sCount[nextLine] = offset;
      if (contentStart >= max3 && state.isEmpty(nextLine + 1)) {
        state.line = Math.min(state.line + 2, endLine);
      } else {
        state.md.block.tokenize(state, nextLine, endLine, true);
      }
      if (!state.tight || prevEmptyEnd) {
        tight = false;
      }
      prevEmptyEnd = state.line - nextLine > 1 && state.isEmpty(state.line - 1);
      state.blkIndent = state.listIndent;
      state.listIndent = oldListIndent;
      state.tShift[nextLine] = oldTShift;
      state.sCount[nextLine] = oldSCount;
      state.tight = oldTight;
      token = state.push("list_item_close", "li", -1);
      token.markup = String.fromCharCode(markerCharCode);
      nextLine = state.line;
      itemLines[1] = nextLine;
      if (nextLine >= endLine) {
        break;
      }
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        break;
      }
      let terminate = false;
      for (let i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) {
        break;
      }
      if (isOrdered) {
        posAfterMarker = skipOrderedListMarker(state, nextLine);
        if (posAfterMarker < 0) {
          break;
        }
        start2 = state.bMarks[nextLine] + state.tShift[nextLine];
      } else {
        posAfterMarker = skipBulletListMarker(state, nextLine);
        if (posAfterMarker < 0) {
          break;
        }
      }
      if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
        break;
      }
    }
    if (isOrdered) {
      token = state.push("ordered_list_close", "ol", -1);
    } else {
      token = state.push("bullet_list_close", "ul", -1);
    }
    token.markup = String.fromCharCode(markerCharCode);
    listLines[1] = nextLine;
    state.line = nextLine;
    state.parentType = oldParentType;
    if (tight) {
      markTightParagraphs(state, listTokIdx);
    }
    return true;
  }

  // node_modules/markdown-it/lib/rules_block/reference.mjs
  function reference(state, startLine, _endLine, silent) {
    let pos = state.bMarks[startLine] + state.tShift[startLine];
    let max3 = state.eMarks[startLine];
    let nextLine = startLine + 1;
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    if (state.src.charCodeAt(pos) !== 91) {
      return false;
    }
    function getNextLine(nextLine2) {
      const endLine = state.lineMax;
      if (nextLine2 >= endLine || state.isEmpty(nextLine2)) {
        return null;
      }
      let isContinuation = false;
      if (state.sCount[nextLine2] - state.blkIndent > 3) {
        isContinuation = true;
      }
      if (state.sCount[nextLine2] < 0) {
        isContinuation = true;
      }
      if (!isContinuation) {
        const terminatorRules = state.md.block.ruler.getRules("reference");
        const oldParentType = state.parentType;
        state.parentType = "reference";
        let terminate = false;
        for (let i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine2, endLine, true)) {
            terminate = true;
            break;
          }
        }
        state.parentType = oldParentType;
        if (terminate) {
          return null;
        }
      }
      const pos2 = state.bMarks[nextLine2] + state.tShift[nextLine2];
      const max4 = state.eMarks[nextLine2];
      return state.src.slice(pos2, max4 + 1);
    }
    let str = state.src.slice(pos, max3 + 1);
    max3 = str.length;
    let labelEnd = -1;
    for (pos = 1; pos < max3; pos++) {
      const ch = str.charCodeAt(pos);
      if (ch === 91) {
        return false;
      } else if (ch === 93) {
        labelEnd = pos;
        break;
      } else if (ch === 10) {
        const lineContent = getNextLine(nextLine);
        if (lineContent !== null) {
          str += lineContent;
          max3 = str.length;
          nextLine++;
        }
      } else if (ch === 92) {
        pos++;
        if (pos < max3 && str.charCodeAt(pos) === 10) {
          const lineContent = getNextLine(nextLine);
          if (lineContent !== null) {
            str += lineContent;
            max3 = str.length;
            nextLine++;
          }
        }
      }
    }
    if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
      return false;
    }
    for (pos = labelEnd + 2; pos < max3; pos++) {
      const ch = str.charCodeAt(pos);
      if (ch === 10) {
        const lineContent = getNextLine(nextLine);
        if (lineContent !== null) {
          str += lineContent;
          max3 = str.length;
          nextLine++;
        }
      } else if (isSpace(ch)) {
      } else {
        break;
      }
    }
    const destRes = state.md.helpers.parseLinkDestination(str, pos, max3);
    if (!destRes.ok) {
      return false;
    }
    const href = state.md.normalizeLink(destRes.str);
    if (!state.md.validateLink(href)) {
      return false;
    }
    pos = destRes.pos;
    const destEndPos = pos;
    const destEndLineNo = nextLine;
    const start2 = pos;
    for (; pos < max3; pos++) {
      const ch = str.charCodeAt(pos);
      if (ch === 10) {
        const lineContent = getNextLine(nextLine);
        if (lineContent !== null) {
          str += lineContent;
          max3 = str.length;
          nextLine++;
        }
      } else if (isSpace(ch)) {
      } else {
        break;
      }
    }
    let titleRes = state.md.helpers.parseLinkTitle(str, pos, max3);
    while (titleRes.can_continue) {
      const lineContent = getNextLine(nextLine);
      if (lineContent === null) break;
      str += lineContent;
      pos = max3;
      max3 = str.length;
      nextLine++;
      titleRes = state.md.helpers.parseLinkTitle(str, pos, max3, titleRes);
    }
    let title;
    if (pos < max3 && start2 !== pos && titleRes.ok) {
      title = titleRes.str;
      pos = titleRes.pos;
    } else {
      title = "";
      pos = destEndPos;
      nextLine = destEndLineNo;
    }
    while (pos < max3) {
      const ch = str.charCodeAt(pos);
      if (!isSpace(ch)) {
        break;
      }
      pos++;
    }
    if (pos < max3 && str.charCodeAt(pos) !== 10) {
      if (title) {
        title = "";
        pos = destEndPos;
        nextLine = destEndLineNo;
        while (pos < max3) {
          const ch = str.charCodeAt(pos);
          if (!isSpace(ch)) {
            break;
          }
          pos++;
        }
      }
    }
    if (pos < max3 && str.charCodeAt(pos) !== 10) {
      return false;
    }
    const label = normalizeReference(str.slice(1, labelEnd));
    if (!label) {
      return false;
    }
    if (silent) {
      return true;
    }
    if (typeof state.env.references === "undefined") {
      state.env.references = {};
    }
    if (typeof state.env.references[label] === "undefined") {
      state.env.references[label] = { title, href };
    }
    state.line = nextLine;
    return true;
  }

  // node_modules/markdown-it/lib/common/html_blocks.mjs
  var html_blocks_default = [
    "address",
    "article",
    "aside",
    "base",
    "basefont",
    "blockquote",
    "body",
    "caption",
    "center",
    "col",
    "colgroup",
    "dd",
    "details",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "frame",
    "frameset",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hr",
    "html",
    "iframe",
    "legend",
    "li",
    "link",
    "main",
    "menu",
    "menuitem",
    "nav",
    "noframes",
    "ol",
    "optgroup",
    "option",
    "p",
    "param",
    "search",
    "section",
    "summary",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "title",
    "tr",
    "track",
    "ul"
  ];

  // node_modules/markdown-it/lib/common/html_re.mjs
  var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
  var unquoted = "[^\"'=<>`\\x00-\\x20]+";
  var single_quoted = "'[^']*'";
  var double_quoted = '"[^"]*"';
  var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
  var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
  var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
  var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
  var comment = "<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->";
  var processing = "<[?][\\s\\S]*?[?]>";
  var declaration = "<![A-Za-z][^>]*>";
  var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
  var HTML_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
  var HTML_OPEN_CLOSE_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");

  // node_modules/markdown-it/lib/rules_block/html_block.mjs
  var HTML_SEQUENCES = [
    [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
    [/^<!--/, /-->/, true],
    [/^<\?/, /\?>/, true],
    [/^<![A-Z]/, />/, true],
    [/^<!\[CDATA\[/, /\]\]>/, true],
    [new RegExp("^</?(" + html_blocks_default.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
    [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
  ];
  function html_block(state, startLine, endLine, silent) {
    let pos = state.bMarks[startLine] + state.tShift[startLine];
    let max3 = state.eMarks[startLine];
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    if (!state.md.options.html) {
      return false;
    }
    if (state.src.charCodeAt(pos) !== 60) {
      return false;
    }
    let lineText = state.src.slice(pos, max3);
    let i = 0;
    for (; i < HTML_SEQUENCES.length; i++) {
      if (HTML_SEQUENCES[i][0].test(lineText)) {
        break;
      }
    }
    if (i === HTML_SEQUENCES.length) {
      return false;
    }
    if (silent) {
      return HTML_SEQUENCES[i][2];
    }
    let nextLine = startLine + 1;
    if (!HTML_SEQUENCES[i][1].test(lineText)) {
      for (; nextLine < endLine; nextLine++) {
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max3 = state.eMarks[nextLine];
        lineText = state.src.slice(pos, max3);
        if (HTML_SEQUENCES[i][1].test(lineText)) {
          if (lineText.length !== 0) {
            nextLine++;
          }
          break;
        }
      }
    }
    state.line = nextLine;
    const token = state.push("html_block", "", 0);
    token.map = [startLine, nextLine];
    token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
    return true;
  }

  // node_modules/markdown-it/lib/rules_block/heading.mjs
  function heading(state, startLine, endLine, silent) {
    let pos = state.bMarks[startLine] + state.tShift[startLine];
    let max3 = state.eMarks[startLine];
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    let ch = state.src.charCodeAt(pos);
    if (ch !== 35 || pos >= max3) {
      return false;
    }
    let level = 1;
    ch = state.src.charCodeAt(++pos);
    while (ch === 35 && pos < max3 && level <= 6) {
      level++;
      ch = state.src.charCodeAt(++pos);
    }
    if (level > 6 || pos < max3 && !isSpace(ch)) {
      return false;
    }
    if (silent) {
      return true;
    }
    max3 = state.skipSpacesBack(max3, pos);
    const tmp = state.skipCharsBack(max3, 35, pos);
    if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
      max3 = tmp;
    }
    state.line = startLine + 1;
    const token_o = state.push("heading_open", "h" + String(level), 1);
    token_o.markup = "########".slice(0, level);
    token_o.map = [startLine, state.line];
    const token_i = state.push("inline", "", 0);
    token_i.content = state.src.slice(pos, max3).trim();
    token_i.map = [startLine, state.line];
    token_i.children = [];
    const token_c = state.push("heading_close", "h" + String(level), -1);
    token_c.markup = "########".slice(0, level);
    return true;
  }

  // node_modules/markdown-it/lib/rules_block/lheading.mjs
  function lheading(state, startLine, endLine) {
    const terminatorRules = state.md.block.ruler.getRules("paragraph");
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    const oldParentType = state.parentType;
    state.parentType = "paragraph";
    let level = 0;
    let marker;
    let nextLine = startLine + 1;
    for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
      if (state.sCount[nextLine] - state.blkIndent > 3) {
        continue;
      }
      if (state.sCount[nextLine] >= state.blkIndent) {
        let pos = state.bMarks[nextLine] + state.tShift[nextLine];
        const max3 = state.eMarks[nextLine];
        if (pos < max3) {
          marker = state.src.charCodeAt(pos);
          if (marker === 45 || marker === 61) {
            pos = state.skipChars(pos, marker);
            pos = state.skipSpaces(pos);
            if (pos >= max3) {
              level = marker === 61 ? 1 : 2;
              break;
            }
          }
        }
      }
      if (state.sCount[nextLine] < 0) {
        continue;
      }
      let terminate = false;
      for (let i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) {
        break;
      }
    }
    if (!level) {
      return false;
    }
    const content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
    state.line = nextLine + 1;
    const token_o = state.push("heading_open", "h" + String(level), 1);
    token_o.markup = String.fromCharCode(marker);
    token_o.map = [startLine, state.line];
    const token_i = state.push("inline", "", 0);
    token_i.content = content;
    token_i.map = [startLine, state.line - 1];
    token_i.children = [];
    const token_c = state.push("heading_close", "h" + String(level), -1);
    token_c.markup = String.fromCharCode(marker);
    state.parentType = oldParentType;
    return true;
  }

  // node_modules/markdown-it/lib/rules_block/paragraph.mjs
  function paragraph(state, startLine, endLine) {
    const terminatorRules = state.md.block.ruler.getRules("paragraph");
    const oldParentType = state.parentType;
    let nextLine = startLine + 1;
    state.parentType = "paragraph";
    for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
      if (state.sCount[nextLine] - state.blkIndent > 3) {
        continue;
      }
      if (state.sCount[nextLine] < 0) {
        continue;
      }
      let terminate = false;
      for (let i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) {
        break;
      }
    }
    const content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
    state.line = nextLine;
    const token_o = state.push("paragraph_open", "p", 1);
    token_o.map = [startLine, state.line];
    const token_i = state.push("inline", "", 0);
    token_i.content = content;
    token_i.map = [startLine, state.line];
    token_i.children = [];
    state.push("paragraph_close", "p", -1);
    state.parentType = oldParentType;
    return true;
  }

  // node_modules/markdown-it/lib/parser_block.mjs
  var _rules2 = [
    // First 2 params - rule name & source. Secondary array - list of rules,
    // which can be terminated by this one.
    ["table", table, ["paragraph", "reference"]],
    ["code", code],
    ["fence", fence, ["paragraph", "reference", "blockquote", "list"]],
    ["blockquote", blockquote, ["paragraph", "reference", "blockquote", "list"]],
    ["hr", hr, ["paragraph", "reference", "blockquote", "list"]],
    ["list", list, ["paragraph", "reference", "blockquote"]],
    ["reference", reference],
    ["html_block", html_block, ["paragraph", "reference", "blockquote"]],
    ["heading", heading, ["paragraph", "reference", "blockquote"]],
    ["lheading", lheading],
    ["paragraph", paragraph]
  ];
  function ParserBlock() {
    this.ruler = new ruler_default();
    for (let i = 0; i < _rules2.length; i++) {
      this.ruler.push(_rules2[i][0], _rules2[i][1], { alt: (_rules2[i][2] || []).slice() });
    }
  }
  ParserBlock.prototype.tokenize = function(state, startLine, endLine) {
    const rules = this.ruler.getRules("");
    const len = rules.length;
    const maxNesting = state.md.options.maxNesting;
    let line = startLine;
    let hasEmptyLines = false;
    while (line < endLine) {
      state.line = line = state.skipEmptyLines(line);
      if (line >= endLine) {
        break;
      }
      if (state.sCount[line] < state.blkIndent) {
        break;
      }
      if (state.level >= maxNesting) {
        state.line = endLine;
        break;
      }
      const prevLine = state.line;
      let ok = false;
      for (let i = 0; i < len; i++) {
        ok = rules[i](state, line, endLine, false);
        if (ok) {
          if (prevLine >= state.line) {
            throw new Error("block rule didn't increment state.line");
          }
          break;
        }
      }
      if (!ok) throw new Error("none of the block rules matched");
      state.tight = !hasEmptyLines;
      if (state.isEmpty(state.line - 1)) {
        hasEmptyLines = true;
      }
      line = state.line;
      if (line < endLine && state.isEmpty(line)) {
        hasEmptyLines = true;
        line++;
        state.line = line;
      }
    }
  };
  ParserBlock.prototype.parse = function(src, md, env, outTokens) {
    if (!src) {
      return;
    }
    const state = new this.State(src, md, env, outTokens);
    this.tokenize(state, state.line, state.lineMax);
  };
  ParserBlock.prototype.State = state_block_default;
  var parser_block_default = ParserBlock;

  // node_modules/markdown-it/lib/rules_inline/state_inline.mjs
  function StateInline(src, md, env, outTokens) {
    this.src = src;
    this.env = env;
    this.md = md;
    this.tokens = outTokens;
    this.tokens_meta = Array(outTokens.length);
    this.pos = 0;
    this.posMax = this.src.length;
    this.level = 0;
    this.pending = "";
    this.pendingLevel = 0;
    this.cache = {};
    this.delimiters = [];
    this._prev_delimiters = [];
    this.backticks = {};
    this.backticksScanned = false;
    this.linkLevel = 0;
  }
  StateInline.prototype.pushPending = function() {
    const token = new token_default("text", "", 0);
    token.content = this.pending;
    token.level = this.pendingLevel;
    this.tokens.push(token);
    this.pending = "";
    return token;
  };
  StateInline.prototype.push = function(type2, tag, nesting) {
    if (this.pending) {
      this.pushPending();
    }
    const token = new token_default(type2, tag, nesting);
    let token_meta = null;
    if (nesting < 0) {
      this.level--;
      this.delimiters = this._prev_delimiters.pop();
    }
    token.level = this.level;
    if (nesting > 0) {
      this.level++;
      this._prev_delimiters.push(this.delimiters);
      this.delimiters = [];
      token_meta = { delimiters: this.delimiters };
    }
    this.pendingLevel = this.level;
    this.tokens.push(token);
    this.tokens_meta.push(token_meta);
    return token;
  };
  StateInline.prototype.scanDelims = function(start2, canSplitWord) {
    const max3 = this.posMax;
    const marker = this.src.charCodeAt(start2);
    const lastChar = start2 > 0 ? this.src.charCodeAt(start2 - 1) : 32;
    let pos = start2;
    while (pos < max3 && this.src.charCodeAt(pos) === marker) {
      pos++;
    }
    const count = pos - start2;
    const nextChar = pos < max3 ? this.src.charCodeAt(pos) : 32;
    const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
    const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
    const isLastWhiteSpace = isWhiteSpace(lastChar);
    const isNextWhiteSpace = isWhiteSpace(nextChar);
    const left_flanking = !isNextWhiteSpace && (!isNextPunctChar || isLastWhiteSpace || isLastPunctChar);
    const right_flanking = !isLastWhiteSpace && (!isLastPunctChar || isNextWhiteSpace || isNextPunctChar);
    const can_open = left_flanking && (canSplitWord || !right_flanking || isLastPunctChar);
    const can_close = right_flanking && (canSplitWord || !left_flanking || isNextPunctChar);
    return { can_open, can_close, length: count };
  };
  StateInline.prototype.Token = token_default;
  var state_inline_default = StateInline;

  // node_modules/markdown-it/lib/rules_inline/text.mjs
  function isTerminatorChar(ch) {
    switch (ch) {
      case 10:
      case 33:
      case 35:
      case 36:
      case 37:
      case 38:
      case 42:
      case 43:
      case 45:
      case 58:
      case 60:
      case 61:
      case 62:
      case 64:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 123:
      case 125:
      case 126:
        return true;
      default:
        return false;
    }
  }
  function text2(state, silent) {
    let pos = state.pos;
    while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
      pos++;
    }
    if (pos === state.pos) {
      return false;
    }
    if (!silent) {
      state.pending += state.src.slice(state.pos, pos);
    }
    state.pos = pos;
    return true;
  }

  // node_modules/markdown-it/lib/rules_inline/linkify.mjs
  var SCHEME_RE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
  function linkify2(state, silent) {
    if (!state.md.options.linkify) return false;
    if (state.linkLevel > 0) return false;
    const pos = state.pos;
    const max3 = state.posMax;
    if (pos + 3 > max3) return false;
    if (state.src.charCodeAt(pos) !== 58) return false;
    if (state.src.charCodeAt(pos + 1) !== 47) return false;
    if (state.src.charCodeAt(pos + 2) !== 47) return false;
    const match2 = state.pending.match(SCHEME_RE);
    if (!match2) return false;
    const proto = match2[1];
    const link3 = state.md.linkify.matchAtStart(state.src.slice(pos - proto.length));
    if (!link3) return false;
    let url = link3.url;
    if (url.length <= proto.length) return false;
    url = url.replace(/\*+$/, "");
    const fullUrl = state.md.normalizeLink(url);
    if (!state.md.validateLink(fullUrl)) return false;
    if (!silent) {
      state.pending = state.pending.slice(0, -proto.length);
      const token_o = state.push("link_open", "a", 1);
      token_o.attrs = [["href", fullUrl]];
      token_o.markup = "linkify";
      token_o.info = "auto";
      const token_t = state.push("text", "", 0);
      token_t.content = state.md.normalizeLinkText(url);
      const token_c = state.push("link_close", "a", -1);
      token_c.markup = "linkify";
      token_c.info = "auto";
    }
    state.pos += url.length - proto.length;
    return true;
  }

  // node_modules/markdown-it/lib/rules_inline/newline.mjs
  function newline(state, silent) {
    let pos = state.pos;
    if (state.src.charCodeAt(pos) !== 10) {
      return false;
    }
    const pmax = state.pending.length - 1;
    const max3 = state.posMax;
    if (!silent) {
      if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
        if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
          let ws = pmax - 1;
          while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32) ws--;
          state.pending = state.pending.slice(0, ws);
          state.push("hardbreak", "br", 0);
        } else {
          state.pending = state.pending.slice(0, -1);
          state.push("softbreak", "br", 0);
        }
      } else {
        state.push("softbreak", "br", 0);
      }
    }
    pos++;
    while (pos < max3 && isSpace(state.src.charCodeAt(pos))) {
      pos++;
    }
    state.pos = pos;
    return true;
  }

  // node_modules/markdown-it/lib/rules_inline/escape.mjs
  var ESCAPED = [];
  for (let i = 0; i < 256; i++) {
    ESCAPED.push(0);
  }
  "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
    ESCAPED[ch.charCodeAt(0)] = 1;
  });
  function escape2(state, silent) {
    let pos = state.pos;
    const max3 = state.posMax;
    if (state.src.charCodeAt(pos) !== 92) return false;
    pos++;
    if (pos >= max3) return false;
    let ch1 = state.src.charCodeAt(pos);
    if (ch1 === 10) {
      if (!silent) {
        state.push("hardbreak", "br", 0);
      }
      pos++;
      while (pos < max3) {
        ch1 = state.src.charCodeAt(pos);
        if (!isSpace(ch1)) break;
        pos++;
      }
      state.pos = pos;
      return true;
    }
    let escapedStr = state.src[pos];
    if (ch1 >= 55296 && ch1 <= 56319 && pos + 1 < max3) {
      const ch2 = state.src.charCodeAt(pos + 1);
      if (ch2 >= 56320 && ch2 <= 57343) {
        escapedStr += state.src[pos + 1];
        pos++;
      }
    }
    const origStr = "\\" + escapedStr;
    if (!silent) {
      const token = state.push("text_special", "", 0);
      if (ch1 < 256 && ESCAPED[ch1] !== 0) {
        token.content = escapedStr;
      } else {
        token.content = origStr;
      }
      token.markup = origStr;
      token.info = "escape";
    }
    state.pos = pos + 1;
    return true;
  }

  // node_modules/markdown-it/lib/rules_inline/backticks.mjs
  function backtick(state, silent) {
    let pos = state.pos;
    const ch = state.src.charCodeAt(pos);
    if (ch !== 96) {
      return false;
    }
    const start2 = pos;
    pos++;
    const max3 = state.posMax;
    while (pos < max3 && state.src.charCodeAt(pos) === 96) {
      pos++;
    }
    const marker = state.src.slice(start2, pos);
    const openerLength = marker.length;
    if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start2) {
      if (!silent) state.pending += marker;
      state.pos += openerLength;
      return true;
    }
    let matchEnd = pos;
    let matchStart;
    while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
      matchEnd = matchStart + 1;
      while (matchEnd < max3 && state.src.charCodeAt(matchEnd) === 96) {
        matchEnd++;
      }
      const closerLength = matchEnd - matchStart;
      if (closerLength === openerLength) {
        if (!silent) {
          const token = state.push("code_inline", "code", 0);
          token.markup = marker;
          token.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
        }
        state.pos = matchEnd;
        return true;
      }
      state.backticks[closerLength] = matchStart;
    }
    state.backticksScanned = true;
    if (!silent) state.pending += marker;
    state.pos += openerLength;
    return true;
  }

  // node_modules/markdown-it/lib/rules_inline/strikethrough.mjs
  function strikethrough_tokenize(state, silent) {
    const start2 = state.pos;
    const marker = state.src.charCodeAt(start2);
    if (silent) {
      return false;
    }
    if (marker !== 126) {
      return false;
    }
    const scanned = state.scanDelims(state.pos, true);
    let len = scanned.length;
    const ch = String.fromCharCode(marker);
    if (len < 2) {
      return false;
    }
    let token;
    if (len % 2) {
      token = state.push("text", "", 0);
      token.content = ch;
      len--;
    }
    for (let i = 0; i < len; i += 2) {
      token = state.push("text", "", 0);
      token.content = ch + ch;
      state.delimiters.push({
        marker,
        length: 0,
        // disable "rule of 3" length checks meant for emphasis
        token: state.tokens.length - 1,
        end: -1,
        open: scanned.can_open,
        close: scanned.can_close
      });
    }
    state.pos += scanned.length;
    return true;
  }
  function postProcess(state, delimiters) {
    let token;
    const loneMarkers = [];
    const max3 = delimiters.length;
    for (let i = 0; i < max3; i++) {
      const startDelim = delimiters[i];
      if (startDelim.marker !== 126) {
        continue;
      }
      if (startDelim.end === -1) {
        continue;
      }
      const endDelim = delimiters[startDelim.end];
      token = state.tokens[startDelim.token];
      token.type = "s_open";
      token.tag = "s";
      token.nesting = 1;
      token.markup = "~~";
      token.content = "";
      token = state.tokens[endDelim.token];
      token.type = "s_close";
      token.tag = "s";
      token.nesting = -1;
      token.markup = "~~";
      token.content = "";
      if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
        loneMarkers.push(endDelim.token - 1);
      }
    }
    while (loneMarkers.length) {
      const i = loneMarkers.pop();
      let j2 = i + 1;
      while (j2 < state.tokens.length && state.tokens[j2].type === "s_close") {
        j2++;
      }
      j2--;
      if (i !== j2) {
        token = state.tokens[j2];
        state.tokens[j2] = state.tokens[i];
        state.tokens[i] = token;
      }
    }
  }
  function strikethrough_postProcess(state) {
    const tokens_meta = state.tokens_meta;
    const max3 = state.tokens_meta.length;
    postProcess(state, state.delimiters);
    for (let curr = 0; curr < max3; curr++) {
      if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
        postProcess(state, tokens_meta[curr].delimiters);
      }
    }
  }
  var strikethrough_default = {
    tokenize: strikethrough_tokenize,
    postProcess: strikethrough_postProcess
  };

  // node_modules/markdown-it/lib/rules_inline/emphasis.mjs
  function emphasis_tokenize(state, silent) {
    const start2 = state.pos;
    const marker = state.src.charCodeAt(start2);
    if (silent) {
      return false;
    }
    if (marker !== 95 && marker !== 42) {
      return false;
    }
    const scanned = state.scanDelims(state.pos, marker === 42);
    for (let i = 0; i < scanned.length; i++) {
      const token = state.push("text", "", 0);
      token.content = String.fromCharCode(marker);
      state.delimiters.push({
        // Char code of the starting marker (number).
        //
        marker,
        // Total length of these series of delimiters.
        //
        length: scanned.length,
        // A position of the token this delimiter corresponds to.
        //
        token: state.tokens.length - 1,
        // If this delimiter is matched as a valid opener, `end` will be
        // equal to its position, otherwise it's `-1`.
        //
        end: -1,
        // Boolean flags that determine if this delimiter could open or close
        // an emphasis.
        //
        open: scanned.can_open,
        close: scanned.can_close
      });
    }
    state.pos += scanned.length;
    return true;
  }
  function postProcess2(state, delimiters) {
    const max3 = delimiters.length;
    for (let i = max3 - 1; i >= 0; i--) {
      const startDelim = delimiters[i];
      if (startDelim.marker !== 95 && startDelim.marker !== 42) {
        continue;
      }
      if (startDelim.end === -1) {
        continue;
      }
      const endDelim = delimiters[startDelim.end];
      const isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && // check that first two markers match and adjacent
      delimiters[i - 1].marker === startDelim.marker && delimiters[i - 1].token === startDelim.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
      delimiters[startDelim.end + 1].token === endDelim.token + 1;
      const ch = String.fromCharCode(startDelim.marker);
      const token_o = state.tokens[startDelim.token];
      token_o.type = isStrong ? "strong_open" : "em_open";
      token_o.tag = isStrong ? "strong" : "em";
      token_o.nesting = 1;
      token_o.markup = isStrong ? ch + ch : ch;
      token_o.content = "";
      const token_c = state.tokens[endDelim.token];
      token_c.type = isStrong ? "strong_close" : "em_close";
      token_c.tag = isStrong ? "strong" : "em";
      token_c.nesting = -1;
      token_c.markup = isStrong ? ch + ch : ch;
      token_c.content = "";
      if (isStrong) {
        state.tokens[delimiters[i - 1].token].content = "";
        state.tokens[delimiters[startDelim.end + 1].token].content = "";
        i--;
      }
    }
  }
  function emphasis_post_process(state) {
    const tokens_meta = state.tokens_meta;
    const max3 = state.tokens_meta.length;
    postProcess2(state, state.delimiters);
    for (let curr = 0; curr < max3; curr++) {
      if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
        postProcess2(state, tokens_meta[curr].delimiters);
      }
    }
  }
  var emphasis_default = {
    tokenize: emphasis_tokenize,
    postProcess: emphasis_post_process
  };

  // node_modules/markdown-it/lib/rules_inline/link.mjs
  function link(state, silent) {
    let code2, label, res, ref;
    let href = "";
    let title = "";
    let start2 = state.pos;
    let parseReference = true;
    if (state.src.charCodeAt(state.pos) !== 91) {
      return false;
    }
    const oldPos = state.pos;
    const max3 = state.posMax;
    const labelStart = state.pos + 1;
    const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
    if (labelEnd < 0) {
      return false;
    }
    let pos = labelEnd + 1;
    if (pos < max3 && state.src.charCodeAt(pos) === 40) {
      parseReference = false;
      pos++;
      for (; pos < max3; pos++) {
        code2 = state.src.charCodeAt(pos);
        if (!isSpace(code2) && code2 !== 10) {
          break;
        }
      }
      if (pos >= max3) {
        return false;
      }
      start2 = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = "";
        }
        start2 = pos;
        for (; pos < max3; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
        if (pos < max3 && start2 !== pos && res.ok) {
          title = res.str;
          pos = res.pos;
          for (; pos < max3; pos++) {
            code2 = state.src.charCodeAt(pos);
            if (!isSpace(code2) && code2 !== 10) {
              break;
            }
          }
        }
      }
      if (pos >= max3 || state.src.charCodeAt(pos) !== 41) {
        parseReference = true;
      }
      pos++;
    }
    if (parseReference) {
      if (typeof state.env.references === "undefined") {
        return false;
      }
      if (pos < max3 && state.src.charCodeAt(pos) === 91) {
        start2 = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start2, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
        pos = labelEnd + 1;
      }
      if (!label) {
        label = state.src.slice(labelStart, labelEnd);
      }
      ref = state.env.references[normalizeReference(label)];
      if (!ref) {
        state.pos = oldPos;
        return false;
      }
      href = ref.href;
      title = ref.title;
    }
    if (!silent) {
      state.pos = labelStart;
      state.posMax = labelEnd;
      const token_o = state.push("link_open", "a", 1);
      const attrs = [["href", href]];
      token_o.attrs = attrs;
      if (title) {
        attrs.push(["title", title]);
      }
      state.linkLevel++;
      state.md.inline.tokenize(state);
      state.linkLevel--;
      state.push("link_close", "a", -1);
    }
    state.pos = pos;
    state.posMax = max3;
    return true;
  }

  // node_modules/markdown-it/lib/rules_inline/image.mjs
  function image(state, silent) {
    let code2, content, label, pos, ref, res, title, start2;
    let href = "";
    const oldPos = state.pos;
    const max3 = state.posMax;
    if (state.src.charCodeAt(state.pos) !== 33) {
      return false;
    }
    if (state.src.charCodeAt(state.pos + 1) !== 91) {
      return false;
    }
    const labelStart = state.pos + 2;
    const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
    if (labelEnd < 0) {
      return false;
    }
    pos = labelEnd + 1;
    if (pos < max3 && state.src.charCodeAt(pos) === 40) {
      pos++;
      for (; pos < max3; pos++) {
        code2 = state.src.charCodeAt(pos);
        if (!isSpace(code2) && code2 !== 10) {
          break;
        }
      }
      if (pos >= max3) {
        return false;
      }
      start2 = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = "";
        }
      }
      start2 = pos;
      for (; pos < max3; pos++) {
        code2 = state.src.charCodeAt(pos);
        if (!isSpace(code2) && code2 !== 10) {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max3 && start2 !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        for (; pos < max3; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
      } else {
        title = "";
      }
      if (pos >= max3 || state.src.charCodeAt(pos) !== 41) {
        state.pos = oldPos;
        return false;
      }
      pos++;
    } else {
      if (typeof state.env.references === "undefined") {
        return false;
      }
      if (pos < max3 && state.src.charCodeAt(pos) === 91) {
        start2 = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start2, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
        pos = labelEnd + 1;
      }
      if (!label) {
        label = state.src.slice(labelStart, labelEnd);
      }
      ref = state.env.references[normalizeReference(label)];
      if (!ref) {
        state.pos = oldPos;
        return false;
      }
      href = ref.href;
      title = ref.title;
    }
    if (!silent) {
      content = state.src.slice(labelStart, labelEnd);
      const tokens = [];
      state.md.inline.parse(
        content,
        state.md,
        state.env,
        tokens
      );
      const token = state.push("image", "img", 0);
      const attrs = [["src", href], ["alt", ""]];
      token.attrs = attrs;
      token.children = tokens;
      token.content = content;
      if (title) {
        attrs.push(["title", title]);
      }
    }
    state.pos = pos;
    state.posMax = max3;
    return true;
  }

  // node_modules/markdown-it/lib/rules_inline/autolink.mjs
  var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
  var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
  function autolink(state, silent) {
    let pos = state.pos;
    if (state.src.charCodeAt(pos) !== 60) {
      return false;
    }
    const start2 = state.pos;
    const max3 = state.posMax;
    for (; ; ) {
      if (++pos >= max3) return false;
      const ch = state.src.charCodeAt(pos);
      if (ch === 60) return false;
      if (ch === 62) break;
    }
    const url = state.src.slice(start2 + 1, pos);
    if (AUTOLINK_RE.test(url)) {
      const fullUrl = state.md.normalizeLink(url);
      if (!state.md.validateLink(fullUrl)) {
        return false;
      }
      if (!silent) {
        const token_o = state.push("link_open", "a", 1);
        token_o.attrs = [["href", fullUrl]];
        token_o.markup = "autolink";
        token_o.info = "auto";
        const token_t = state.push("text", "", 0);
        token_t.content = state.md.normalizeLinkText(url);
        const token_c = state.push("link_close", "a", -1);
        token_c.markup = "autolink";
        token_c.info = "auto";
      }
      state.pos += url.length + 2;
      return true;
    }
    if (EMAIL_RE.test(url)) {
      const fullUrl = state.md.normalizeLink("mailto:" + url);
      if (!state.md.validateLink(fullUrl)) {
        return false;
      }
      if (!silent) {
        const token_o = state.push("link_open", "a", 1);
        token_o.attrs = [["href", fullUrl]];
        token_o.markup = "autolink";
        token_o.info = "auto";
        const token_t = state.push("text", "", 0);
        token_t.content = state.md.normalizeLinkText(url);
        const token_c = state.push("link_close", "a", -1);
        token_c.markup = "autolink";
        token_c.info = "auto";
      }
      state.pos += url.length + 2;
      return true;
    }
    return false;
  }

  // node_modules/markdown-it/lib/rules_inline/html_inline.mjs
  function isLinkOpen2(str) {
    return /^<a[>\s]/i.test(str);
  }
  function isLinkClose2(str) {
    return /^<\/a\s*>/i.test(str);
  }
  function isLetter(ch) {
    const lc = ch | 32;
    return lc >= 97 && lc <= 122;
  }
  function html_inline(state, silent) {
    if (!state.md.options.html) {
      return false;
    }
    const max3 = state.posMax;
    const pos = state.pos;
    if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max3) {
      return false;
    }
    const ch = state.src.charCodeAt(pos + 1);
    if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
      return false;
    }
    const match2 = state.src.slice(pos).match(HTML_TAG_RE);
    if (!match2) {
      return false;
    }
    if (!silent) {
      const token = state.push("html_inline", "", 0);
      token.content = match2[0];
      if (isLinkOpen2(token.content)) state.linkLevel++;
      if (isLinkClose2(token.content)) state.linkLevel--;
    }
    state.pos += match2[0].length;
    return true;
  }

  // node_modules/markdown-it/lib/rules_inline/entity.mjs
  var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
  var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
  function entity(state, silent) {
    const pos = state.pos;
    const max3 = state.posMax;
    if (state.src.charCodeAt(pos) !== 38) return false;
    if (pos + 1 >= max3) return false;
    const ch = state.src.charCodeAt(pos + 1);
    if (ch === 35) {
      const match2 = state.src.slice(pos).match(DIGITAL_RE);
      if (match2) {
        if (!silent) {
          const code2 = match2[1][0].toLowerCase() === "x" ? parseInt(match2[1].slice(1), 16) : parseInt(match2[1], 10);
          const token = state.push("text_special", "", 0);
          token.content = isValidEntityCode(code2) ? fromCodePoint3(code2) : fromCodePoint3(65533);
          token.markup = match2[0];
          token.info = "entity";
        }
        state.pos += match2[0].length;
        return true;
      }
    } else {
      const match2 = state.src.slice(pos).match(NAMED_RE);
      if (match2) {
        const decoded = decodeHTML(match2[0]);
        if (decoded !== match2[0]) {
          if (!silent) {
            const token = state.push("text_special", "", 0);
            token.content = decoded;
            token.markup = match2[0];
            token.info = "entity";
          }
          state.pos += match2[0].length;
          return true;
        }
      }
    }
    return false;
  }

  // node_modules/markdown-it/lib/rules_inline/balance_pairs.mjs
  function processDelimiters(delimiters) {
    const openersBottom = {};
    const max3 = delimiters.length;
    if (!max3) return;
    let headerIdx = 0;
    let lastTokenIdx = -2;
    const jumps = [];
    for (let closerIdx = 0; closerIdx < max3; closerIdx++) {
      const closer = delimiters[closerIdx];
      jumps.push(0);
      if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
        headerIdx = closerIdx;
      }
      lastTokenIdx = closer.token;
      closer.length = closer.length || 0;
      if (!closer.close) continue;
      if (!openersBottom.hasOwnProperty(closer.marker)) {
        openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
      }
      const minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
      let openerIdx = headerIdx - jumps[headerIdx] - 1;
      let newMinOpenerIdx = openerIdx;
      for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
        const opener = delimiters[openerIdx];
        if (opener.marker !== closer.marker) continue;
        if (opener.open && opener.end < 0) {
          let isOddMatch = false;
          if (opener.close || closer.open) {
            if ((opener.length + closer.length) % 3 === 0) {
              if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
                isOddMatch = true;
              }
            }
          }
          if (!isOddMatch) {
            const lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
            jumps[closerIdx] = closerIdx - openerIdx + lastJump;
            jumps[openerIdx] = lastJump;
            closer.open = false;
            opener.end = closerIdx;
            opener.close = false;
            newMinOpenerIdx = -1;
            lastTokenIdx = -2;
            break;
          }
        }
      }
      if (newMinOpenerIdx !== -1) {
        openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
      }
    }
  }
  function link_pairs(state) {
    const tokens_meta = state.tokens_meta;
    const max3 = state.tokens_meta.length;
    processDelimiters(state.delimiters);
    for (let curr = 0; curr < max3; curr++) {
      if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
        processDelimiters(tokens_meta[curr].delimiters);
      }
    }
  }

  // node_modules/markdown-it/lib/rules_inline/fragments_join.mjs
  function fragments_join(state) {
    let curr, last2;
    let level = 0;
    const tokens = state.tokens;
    const max3 = state.tokens.length;
    for (curr = last2 = 0; curr < max3; curr++) {
      if (tokens[curr].nesting < 0) level--;
      tokens[curr].level = level;
      if (tokens[curr].nesting > 0) level++;
      if (tokens[curr].type === "text" && curr + 1 < max3 && tokens[curr + 1].type === "text") {
        tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
      } else {
        if (curr !== last2) {
          tokens[last2] = tokens[curr];
        }
        last2++;
      }
    }
    if (curr !== last2) {
      tokens.length = last2;
    }
  }

  // node_modules/markdown-it/lib/parser_inline.mjs
  var _rules3 = [
    ["text", text2],
    ["linkify", linkify2],
    ["newline", newline],
    ["escape", escape2],
    ["backticks", backtick],
    ["strikethrough", strikethrough_default.tokenize],
    ["emphasis", emphasis_default.tokenize],
    ["link", link],
    ["image", image],
    ["autolink", autolink],
    ["html_inline", html_inline],
    ["entity", entity]
  ];
  var _rules22 = [
    ["balance_pairs", link_pairs],
    ["strikethrough", strikethrough_default.postProcess],
    ["emphasis", emphasis_default.postProcess],
    // rules for pairs separate '**' into its own text tokens, which may be left unused,
    // rule below merges unused segments back with the rest of the text
    ["fragments_join", fragments_join]
  ];
  function ParserInline() {
    this.ruler = new ruler_default();
    for (let i = 0; i < _rules3.length; i++) {
      this.ruler.push(_rules3[i][0], _rules3[i][1]);
    }
    this.ruler2 = new ruler_default();
    for (let i = 0; i < _rules22.length; i++) {
      this.ruler2.push(_rules22[i][0], _rules22[i][1]);
    }
  }
  ParserInline.prototype.skipToken = function(state) {
    const pos = state.pos;
    const rules = this.ruler.getRules("");
    const len = rules.length;
    const maxNesting = state.md.options.maxNesting;
    const cache = state.cache;
    if (typeof cache[pos] !== "undefined") {
      state.pos = cache[pos];
      return;
    }
    let ok = false;
    if (state.level < maxNesting) {
      for (let i = 0; i < len; i++) {
        state.level++;
        ok = rules[i](state, true);
        state.level--;
        if (ok) {
          if (pos >= state.pos) {
            throw new Error("inline rule didn't increment state.pos");
          }
          break;
        }
      }
    } else {
      state.pos = state.posMax;
    }
    if (!ok) {
      state.pos++;
    }
    cache[pos] = state.pos;
  };
  ParserInline.prototype.tokenize = function(state) {
    const rules = this.ruler.getRules("");
    const len = rules.length;
    const end2 = state.posMax;
    const maxNesting = state.md.options.maxNesting;
    while (state.pos < end2) {
      const prevPos = state.pos;
      let ok = false;
      if (state.level < maxNesting) {
        for (let i = 0; i < len; i++) {
          ok = rules[i](state, false);
          if (ok) {
            if (prevPos >= state.pos) {
              throw new Error("inline rule didn't increment state.pos");
            }
            break;
          }
        }
      }
      if (ok) {
        if (state.pos >= end2) {
          break;
        }
        continue;
      }
      state.pending += state.src[state.pos++];
    }
    if (state.pending) {
      state.pushPending();
    }
  };
  ParserInline.prototype.parse = function(str, md, env, outTokens) {
    const state = new this.State(str, md, env, outTokens);
    this.tokenize(state);
    const rules = this.ruler2.getRules("");
    const len = rules.length;
    for (let i = 0; i < len; i++) {
      rules[i](state);
    }
  };
  ParserInline.prototype.State = state_inline_default;
  var parser_inline_default = ParserInline;

  // node_modules/linkify-it/lib/re.mjs
  function re_default(opts) {
    const re2 = {};
    opts = opts || {};
    re2.src_Any = regex_default.source;
    re2.src_Cc = regex_default2.source;
    re2.src_Z = regex_default6.source;
    re2.src_P = regex_default4.source;
    re2.src_ZPCc = [re2.src_Z, re2.src_P, re2.src_Cc].join("|");
    re2.src_ZCc = [re2.src_Z, re2.src_Cc].join("|");
    const text_separators = "[><\uFF5C]";
    re2.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re2.src_ZPCc + ")" + re2.src_Any + ")";
    re2.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
    re2.src_auth = "(?:(?:(?!" + re2.src_ZCc + "|[@/\\[\\]()]).)+@)?";
    re2.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
    re2.src_host_terminator = "(?=$|" + text_separators + "|" + re2.src_ZPCc + ")(?!" + (opts["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + re2.src_ZPCc + "))";
    re2.src_path = "(?:[/?#](?:(?!" + re2.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re2.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re2.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re2.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re2.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re2.src_ZCc + "|[']).)+\\'|\\'(?=" + re2.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re2.src_ZCc + "|[.]|$)|" + (opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + // allow `,,,` in paths
    ",(?!" + re2.src_ZCc + "|$)|;(?!" + re2.src_ZCc + "|$)|\\!+(?!" + re2.src_ZCc + "|[!]|$)|\\?(?!" + re2.src_ZCc + "|[?]|$))+|\\/)?";
    re2.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
    re2.src_xn = "xn--[a-z0-9\\-]{1,59}";
    re2.src_domain_root = // Allow letters & digits (http://test1)
    "(?:" + re2.src_xn + "|" + re2.src_pseudo_letter + "{1,63})";
    re2.src_domain = "(?:" + re2.src_xn + "|(?:" + re2.src_pseudo_letter + ")|(?:" + re2.src_pseudo_letter + "(?:-|" + re2.src_pseudo_letter + "){0,61}" + re2.src_pseudo_letter + "))";
    re2.src_host = "(?:(?:(?:(?:" + re2.src_domain + ")\\.)*" + re2.src_domain + "))";
    re2.tpl_host_fuzzy = "(?:" + re2.src_ip4 + "|(?:(?:(?:" + re2.src_domain + ")\\.)+(?:%TLDS%)))";
    re2.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re2.src_domain + ")\\.)+(?:%TLDS%))";
    re2.src_host_strict = re2.src_host + re2.src_host_terminator;
    re2.tpl_host_fuzzy_strict = re2.tpl_host_fuzzy + re2.src_host_terminator;
    re2.src_host_port_strict = re2.src_host + re2.src_port + re2.src_host_terminator;
    re2.tpl_host_port_fuzzy_strict = re2.tpl_host_fuzzy + re2.src_port + re2.src_host_terminator;
    re2.tpl_host_port_no_ip_fuzzy_strict = re2.tpl_host_no_ip_fuzzy + re2.src_port + re2.src_host_terminator;
    re2.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re2.src_ZPCc + "|>|$))";
    re2.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re2.src_ZCc + ")(" + re2.src_email_name + "@" + re2.tpl_host_fuzzy_strict + ")";
    re2.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re2.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re2.tpl_host_port_fuzzy_strict + re2.src_path + ")";
    re2.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re2.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re2.tpl_host_port_no_ip_fuzzy_strict + re2.src_path + ")";
    return re2;
  }

  // node_modules/linkify-it/index.mjs
  function assign2(obj) {
    const sources = Array.prototype.slice.call(arguments, 1);
    sources.forEach(function(source) {
      if (!source) {
        return;
      }
      Object.keys(source).forEach(function(key) {
        obj[key] = source[key];
      });
    });
    return obj;
  }
  function _class2(obj) {
    return Object.prototype.toString.call(obj);
  }
  function isString2(obj) {
    return _class2(obj) === "[object String]";
  }
  function isObject(obj) {
    return _class2(obj) === "[object Object]";
  }
  function isRegExp(obj) {
    return _class2(obj) === "[object RegExp]";
  }
  function isFunction(obj) {
    return _class2(obj) === "[object Function]";
  }
  function escapeRE2(str) {
    return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
  }
  var defaultOptions2 = {
    fuzzyLink: true,
    fuzzyEmail: true,
    fuzzyIP: false
  };
  function isOptionsObj(obj) {
    return Object.keys(obj || {}).reduce(function(acc, k) {
      return acc || defaultOptions2.hasOwnProperty(k);
    }, false);
  }
  var defaultSchemas = {
    "http:": {
      validate: function(text3, pos, self2) {
        const tail = text3.slice(pos);
        if (!self2.re.http) {
          self2.re.http = new RegExp(
            "^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path,
            "i"
          );
        }
        if (self2.re.http.test(tail)) {
          return tail.match(self2.re.http)[0].length;
        }
        return 0;
      }
    },
    "https:": "http:",
    "ftp:": "http:",
    "//": {
      validate: function(text3, pos, self2) {
        const tail = text3.slice(pos);
        if (!self2.re.no_http) {
          self2.re.no_http = new RegExp(
            "^" + self2.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
            // with code comments
            "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path,
            "i"
          );
        }
        if (self2.re.no_http.test(tail)) {
          if (pos >= 3 && text3[pos - 3] === ":") {
            return 0;
          }
          if (pos >= 3 && text3[pos - 3] === "/") {
            return 0;
          }
          return tail.match(self2.re.no_http)[0].length;
        }
        return 0;
      }
    },
    "mailto:": {
      validate: function(text3, pos, self2) {
        const tail = text3.slice(pos);
        if (!self2.re.mailto) {
          self2.re.mailto = new RegExp(
            "^" + self2.re.src_email_name + "@" + self2.re.src_host_strict,
            "i"
          );
        }
        if (self2.re.mailto.test(tail)) {
          return tail.match(self2.re.mailto)[0].length;
        }
        return 0;
      }
    }
  };
  var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
  var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
  function resetScanCache(self2) {
    self2.__index__ = -1;
    self2.__text_cache__ = "";
  }
  function createValidator(re2) {
    return function(text3, pos) {
      const tail = text3.slice(pos);
      if (re2.test(tail)) {
        return tail.match(re2)[0].length;
      }
      return 0;
    };
  }
  function createNormalizer() {
    return function(match2, self2) {
      self2.normalize(match2);
    };
  }
  function compile2(self2) {
    const re2 = self2.re = re_default(self2.__opts__);
    const tlds2 = self2.__tlds__.slice();
    self2.onCompile();
    if (!self2.__tlds_replaced__) {
      tlds2.push(tlds_2ch_src_re);
    }
    tlds2.push(re2.src_xn);
    re2.src_tlds = tlds2.join("|");
    function untpl(tpl) {
      return tpl.replace("%TLDS%", re2.src_tlds);
    }
    re2.email_fuzzy = RegExp(untpl(re2.tpl_email_fuzzy), "i");
    re2.link_fuzzy = RegExp(untpl(re2.tpl_link_fuzzy), "i");
    re2.link_no_ip_fuzzy = RegExp(untpl(re2.tpl_link_no_ip_fuzzy), "i");
    re2.host_fuzzy_test = RegExp(untpl(re2.tpl_host_fuzzy_test), "i");
    const aliases2 = [];
    self2.__compiled__ = {};
    function schemaError(name2, val2) {
      throw new Error('(LinkifyIt) Invalid schema "' + name2 + '": ' + val2);
    }
    Object.keys(self2.__schemas__).forEach(function(name2) {
      const val2 = self2.__schemas__[name2];
      if (val2 === null) {
        return;
      }
      const compiled = { validate: null, link: null };
      self2.__compiled__[name2] = compiled;
      if (isObject(val2)) {
        if (isRegExp(val2.validate)) {
          compiled.validate = createValidator(val2.validate);
        } else if (isFunction(val2.validate)) {
          compiled.validate = val2.validate;
        } else {
          schemaError(name2, val2);
        }
        if (isFunction(val2.normalize)) {
          compiled.normalize = val2.normalize;
        } else if (!val2.normalize) {
          compiled.normalize = createNormalizer();
        } else {
          schemaError(name2, val2);
        }
        return;
      }
      if (isString2(val2)) {
        aliases2.push(name2);
        return;
      }
      schemaError(name2, val2);
    });
    aliases2.forEach(function(alias) {
      if (!self2.__compiled__[self2.__schemas__[alias]]) {
        return;
      }
      self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;
      self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;
    });
    self2.__compiled__[""] = { validate: null, normalize: createNormalizer() };
    const slist = Object.keys(self2.__compiled__).filter(function(name2) {
      return name2.length > 0 && self2.__compiled__[name2];
    }).map(escapeRE2).join("|");
    self2.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re2.src_ZPCc + "))(" + slist + ")", "i");
    self2.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re2.src_ZPCc + "))(" + slist + ")", "ig");
    self2.re.schema_at_start = RegExp("^" + self2.re.schema_search.source, "i");
    self2.re.pretest = RegExp(
      "(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@",
      "i"
    );
    resetScanCache(self2);
  }
  function Match(self2, shift) {
    const start2 = self2.__index__;
    const end2 = self2.__last_index__;
    const text3 = self2.__text_cache__.slice(start2, end2);
    this.schema = self2.__schema__.toLowerCase();
    this.index = start2 + shift;
    this.lastIndex = end2 + shift;
    this.raw = text3;
    this.text = text3;
    this.url = text3;
  }
  function createMatch(self2, shift) {
    const match2 = new Match(self2, shift);
    self2.__compiled__[match2.schema].normalize(match2, self2);
    return match2;
  }
  function LinkifyIt(schemas2, options) {
    if (!(this instanceof LinkifyIt)) {
      return new LinkifyIt(schemas2, options);
    }
    if (!options) {
      if (isOptionsObj(schemas2)) {
        options = schemas2;
        schemas2 = {};
      }
    }
    this.__opts__ = assign2({}, defaultOptions2, options);
    this.__index__ = -1;
    this.__last_index__ = -1;
    this.__schema__ = "";
    this.__text_cache__ = "";
    this.__schemas__ = assign2({}, defaultSchemas, schemas2);
    this.__compiled__ = {};
    this.__tlds__ = tlds_default;
    this.__tlds_replaced__ = false;
    this.re = {};
    compile2(this);
  }
  LinkifyIt.prototype.add = function add2(schema4, definition) {
    this.__schemas__[schema4] = definition;
    compile2(this);
    return this;
  };
  LinkifyIt.prototype.set = function set(options) {
    this.__opts__ = assign2(this.__opts__, options);
    return this;
  };
  LinkifyIt.prototype.test = function test(text3) {
    this.__text_cache__ = text3;
    this.__index__ = -1;
    if (!text3.length) {
      return false;
    }
    let m, ml, me, len, shift, next2, re2, tld_pos, at_pos;
    if (this.re.schema_test.test(text3)) {
      re2 = this.re.schema_search;
      re2.lastIndex = 0;
      while ((m = re2.exec(text3)) !== null) {
        len = this.testSchemaAt(text3, m[2], re2.lastIndex);
        if (len) {
          this.__schema__ = m[2];
          this.__index__ = m.index + m[1].length;
          this.__last_index__ = m.index + m[0].length + len;
          break;
        }
      }
    }
    if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
      tld_pos = text3.search(this.re.host_fuzzy_test);
      if (tld_pos >= 0) {
        if (this.__index__ < 0 || tld_pos < this.__index__) {
          if ((ml = text3.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
            shift = ml.index + ml[1].length;
            if (this.__index__ < 0 || shift < this.__index__) {
              this.__schema__ = "";
              this.__index__ = shift;
              this.__last_index__ = ml.index + ml[0].length;
            }
          }
        }
      }
    }
    if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
      at_pos = text3.indexOf("@");
      if (at_pos >= 0) {
        if ((me = text3.match(this.re.email_fuzzy)) !== null) {
          shift = me.index + me[1].length;
          next2 = me.index + me[0].length;
          if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next2 > this.__last_index__) {
            this.__schema__ = "mailto:";
            this.__index__ = shift;
            this.__last_index__ = next2;
          }
        }
      }
    }
    return this.__index__ >= 0;
  };
  LinkifyIt.prototype.pretest = function pretest(text3) {
    return this.re.pretest.test(text3);
  };
  LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text3, schema4, pos) {
    if (!this.__compiled__[schema4.toLowerCase()]) {
      return 0;
    }
    return this.__compiled__[schema4.toLowerCase()].validate(text3, pos, this);
  };
  LinkifyIt.prototype.match = function match(text3) {
    const result = [];
    let shift = 0;
    if (this.__index__ >= 0 && this.__text_cache__ === text3) {
      result.push(createMatch(this, shift));
      shift = this.__last_index__;
    }
    let tail = shift ? text3.slice(shift) : text3;
    while (this.test(tail)) {
      result.push(createMatch(this, shift));
      tail = tail.slice(this.__last_index__);
      shift += this.__last_index__;
    }
    if (result.length) {
      return result;
    }
    return null;
  };
  LinkifyIt.prototype.matchAtStart = function matchAtStart(text3) {
    this.__text_cache__ = text3;
    this.__index__ = -1;
    if (!text3.length) return null;
    const m = this.re.schema_at_start.exec(text3);
    if (!m) return null;
    const len = this.testSchemaAt(text3, m[2], m[0].length);
    if (!len) return null;
    this.__schema__ = m[2];
    this.__index__ = m.index + m[1].length;
    this.__last_index__ = m.index + m[0].length + len;
    return createMatch(this, 0);
  };
  LinkifyIt.prototype.tlds = function tlds(list2, keepOld) {
    list2 = Array.isArray(list2) ? list2 : [list2];
    if (!keepOld) {
      this.__tlds__ = list2.slice();
      this.__tlds_replaced__ = true;
      compile2(this);
      return this;
    }
    this.__tlds__ = this.__tlds__.concat(list2).sort().filter(function(el, idx, arr) {
      return el !== arr[idx - 1];
    }).reverse();
    compile2(this);
    return this;
  };
  LinkifyIt.prototype.normalize = function normalize2(match2) {
    if (!match2.schema) {
      match2.url = "http://" + match2.url;
    }
    if (match2.schema === "mailto:" && !/^mailto:/i.test(match2.url)) {
      match2.url = "mailto:" + match2.url;
    }
  };
  LinkifyIt.prototype.onCompile = function onCompile() {
  };
  var linkify_it_default = LinkifyIt;

  // node_modules/punycode.js/punycode.es6.js
  var maxInt = 2147483647;
  var base = 36;
  var tMin = 1;
  var tMax = 26;
  var skew = 38;
  var damp = 700;
  var initialBias = 72;
  var initialN = 128;
  var delimiter = "-";
  var regexPunycode = /^xn--/;
  var regexNonASCII = /[^\0-\x7F]/;
  var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
  var errors = {
    "overflow": "Overflow: input needs wider integers to process",
    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
    "invalid-input": "Invalid input"
  };
  var baseMinusTMin = base - tMin;
  var floor = Math.floor;
  var stringFromCharCode = String.fromCharCode;
  function error(type2) {
    throw new RangeError(errors[type2]);
  }
  function map2(array2, callback) {
    const result = [];
    let length = array2.length;
    while (length--) {
      result[length] = callback(array2[length]);
    }
    return result;
  }
  function mapDomain(domain, callback) {
    const parts = domain.split("@");
    let result = "";
    if (parts.length > 1) {
      result = parts[0] + "@";
      domain = parts[1];
    }
    domain = domain.replace(regexSeparators, ".");
    const labels = domain.split(".");
    const encoded = map2(labels, callback).join(".");
    return result + encoded;
  }
  function ucs2decode(string2) {
    const output = [];
    let counter = 0;
    const length = string2.length;
    while (counter < length) {
      const value = string2.charCodeAt(counter++);
      if (value >= 55296 && value <= 56319 && counter < length) {
        const extra = string2.charCodeAt(counter++);
        if ((extra & 64512) == 56320) {
          output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
        } else {
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }
    return output;
  }
  var ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
  var basicToDigit = function(codePoint) {
    if (codePoint >= 48 && codePoint < 58) {
      return 26 + (codePoint - 48);
    }
    if (codePoint >= 65 && codePoint < 91) {
      return codePoint - 65;
    }
    if (codePoint >= 97 && codePoint < 123) {
      return codePoint - 97;
    }
    return base;
  };
  var digitToBasic = function(digit, flag) {
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  };
  var adapt = function(delta, numPoints, firstTime) {
    let k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);
    for (; delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin);
    }
    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  };
  var decode2 = function(input) {
    const output = [];
    const inputLength = input.length;
    let i = 0;
    let n = initialN;
    let bias = initialBias;
    let basic = input.lastIndexOf(delimiter);
    if (basic < 0) {
      basic = 0;
    }
    for (let j2 = 0; j2 < basic; ++j2) {
      if (input.charCodeAt(j2) >= 128) {
        error("not-basic");
      }
      output.push(input.charCodeAt(j2));
    }
    for (let index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
      const oldi = i;
      for (let w = 1, k = base; ; k += base) {
        if (index2 >= inputLength) {
          error("invalid-input");
        }
        const digit = basicToDigit(input.charCodeAt(index2++));
        if (digit >= base) {
          error("invalid-input");
        }
        if (digit > floor((maxInt - i) / w)) {
          error("overflow");
        }
        i += digit * w;
        const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
        if (digit < t) {
          break;
        }
        const baseMinusT = base - t;
        if (w > floor(maxInt / baseMinusT)) {
          error("overflow");
        }
        w *= baseMinusT;
      }
      const out = output.length + 1;
      bias = adapt(i - oldi, out, oldi == 0);
      if (floor(i / out) > maxInt - n) {
        error("overflow");
      }
      n += floor(i / out);
      i %= out;
      output.splice(i++, 0, n);
    }
    return String.fromCodePoint(...output);
  };
  var encode2 = function(input) {
    const output = [];
    input = ucs2decode(input);
    const inputLength = input.length;
    let n = initialN;
    let delta = 0;
    let bias = initialBias;
    for (const currentValue of input) {
      if (currentValue < 128) {
        output.push(stringFromCharCode(currentValue));
      }
    }
    const basicLength = output.length;
    let handledCPCount = basicLength;
    if (basicLength) {
      output.push(delimiter);
    }
    while (handledCPCount < inputLength) {
      let m = maxInt;
      for (const currentValue of input) {
        if (currentValue >= n && currentValue < m) {
          m = currentValue;
        }
      }
      const handledCPCountPlusOne = handledCPCount + 1;
      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error("overflow");
      }
      delta += (m - n) * handledCPCountPlusOne;
      n = m;
      for (const currentValue of input) {
        if (currentValue < n && ++delta > maxInt) {
          error("overflow");
        }
        if (currentValue === n) {
          let q2 = delta;
          for (let k = base; ; k += base) {
            const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (q2 < t) {
              break;
            }
            const qMinusT = q2 - t;
            const baseMinusT = base - t;
            output.push(
              stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
            );
            q2 = floor(qMinusT / baseMinusT);
          }
          output.push(stringFromCharCode(digitToBasic(q2, 0)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }
      ++delta;
      ++n;
    }
    return output.join("");
  };
  var toUnicode = function(input) {
    return mapDomain(input, function(string2) {
      return regexPunycode.test(string2) ? decode2(string2.slice(4).toLowerCase()) : string2;
    });
  };
  var toASCII = function(input) {
    return mapDomain(input, function(string2) {
      return regexNonASCII.test(string2) ? "xn--" + encode2(string2) : string2;
    });
  };
  var punycode = {
    /**
     * A string representing the current Punycode.js version number.
     * @memberOf punycode
     * @type String
     */
    "version": "2.3.1",
    /**
     * An object of methods to convert from JavaScript's internal character
     * representation (UCS-2) to Unicode code points, and back.
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode
     * @type Object
     */
    "ucs2": {
      "decode": ucs2decode,
      "encode": ucs2encode
    },
    "decode": decode2,
    "encode": encode2,
    "toASCII": toASCII,
    "toUnicode": toUnicode
  };
  var punycode_es6_default = punycode;

  // node_modules/markdown-it/lib/presets/default.mjs
  var default_default = {
    options: {
      // Enable HTML tags in source
      html: false,
      // Use '/' to close single tags (<br />)
      xhtmlOut: false,
      // Convert '\n' in paragraphs into <br>
      breaks: false,
      // CSS language prefix for fenced blocks
      langPrefix: "language-",
      // autoconvert URL-like texts to links
      linkify: false,
      // Enable some language-neutral replacements + quotes beautification
      typographer: false,
      // Double + single quotes replacement pairs, when typographer enabled,
      // and smartquotes on. Could be either a String or an Array.
      //
      // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
      // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
      quotes: "\u201C\u201D\u2018\u2019",
      /* “”‘’ */
      // Highlighter function. Should return escaped HTML,
      // or '' if the source string is not changed and should be escaped externaly.
      // If result starts with <pre... internal wrapper is skipped.
      //
      // function (/*str, lang*/) { return ''; }
      //
      highlight: null,
      // Internal protection, recursion limit
      maxNesting: 100
    },
    components: {
      core: {},
      block: {},
      inline: {}
    }
  };

  // node_modules/markdown-it/lib/presets/zero.mjs
  var zero_default = {
    options: {
      // Enable HTML tags in source
      html: false,
      // Use '/' to close single tags (<br />)
      xhtmlOut: false,
      // Convert '\n' in paragraphs into <br>
      breaks: false,
      // CSS language prefix for fenced blocks
      langPrefix: "language-",
      // autoconvert URL-like texts to links
      linkify: false,
      // Enable some language-neutral replacements + quotes beautification
      typographer: false,
      // Double + single quotes replacement pairs, when typographer enabled,
      // and smartquotes on. Could be either a String or an Array.
      //
      // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
      // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
      quotes: "\u201C\u201D\u2018\u2019",
      /* “”‘’ */
      // Highlighter function. Should return escaped HTML,
      // or '' if the source string is not changed and should be escaped externaly.
      // If result starts with <pre... internal wrapper is skipped.
      //
      // function (/*str, lang*/) { return ''; }
      //
      highlight: null,
      // Internal protection, recursion limit
      maxNesting: 20
    },
    components: {
      core: {
        rules: [
          "normalize",
          "block",
          "inline",
          "text_join"
        ]
      },
      block: {
        rules: [
          "paragraph"
        ]
      },
      inline: {
        rules: [
          "text"
        ],
        rules2: [
          "balance_pairs",
          "fragments_join"
        ]
      }
    }
  };

  // node_modules/markdown-it/lib/presets/commonmark.mjs
  var commonmark_default = {
    options: {
      // Enable HTML tags in source
      html: true,
      // Use '/' to close single tags (<br />)
      xhtmlOut: true,
      // Convert '\n' in paragraphs into <br>
      breaks: false,
      // CSS language prefix for fenced blocks
      langPrefix: "language-",
      // autoconvert URL-like texts to links
      linkify: false,
      // Enable some language-neutral replacements + quotes beautification
      typographer: false,
      // Double + single quotes replacement pairs, when typographer enabled,
      // and smartquotes on. Could be either a String or an Array.
      //
      // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
      // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
      quotes: "\u201C\u201D\u2018\u2019",
      /* “”‘’ */
      // Highlighter function. Should return escaped HTML,
      // or '' if the source string is not changed and should be escaped externaly.
      // If result starts with <pre... internal wrapper is skipped.
      //
      // function (/*str, lang*/) { return ''; }
      //
      highlight: null,
      // Internal protection, recursion limit
      maxNesting: 20
    },
    components: {
      core: {
        rules: [
          "normalize",
          "block",
          "inline",
          "text_join"
        ]
      },
      block: {
        rules: [
          "blockquote",
          "code",
          "fence",
          "heading",
          "hr",
          "html_block",
          "lheading",
          "list",
          "reference",
          "paragraph"
        ]
      },
      inline: {
        rules: [
          "autolink",
          "backticks",
          "emphasis",
          "entity",
          "escape",
          "html_inline",
          "image",
          "link",
          "newline",
          "text"
        ],
        rules2: [
          "balance_pairs",
          "emphasis",
          "fragments_join"
        ]
      }
    }
  };

  // node_modules/markdown-it/lib/index.mjs
  var config = {
    default: default_default,
    zero: zero_default,
    commonmark: commonmark_default
  };
  var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
  var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
  function validateLink(url) {
    const str = url.trim().toLowerCase();
    return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) : true;
  }
  var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
  function normalizeLink(url) {
    const parsed = parse_default(url, true);
    if (parsed.hostname) {
      if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
        try {
          parsed.hostname = punycode_es6_default.toASCII(parsed.hostname);
        } catch (er) {
        }
      }
    }
    return encode_default(format(parsed));
  }
  function normalizeLinkText(url) {
    const parsed = parse_default(url, true);
    if (parsed.hostname) {
      if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
        try {
          parsed.hostname = punycode_es6_default.toUnicode(parsed.hostname);
        } catch (er) {
        }
      }
    }
    return decode_default(format(parsed), decode_default.defaultChars + "%");
  }
  function MarkdownIt(presetName, options) {
    if (!(this instanceof MarkdownIt)) {
      return new MarkdownIt(presetName, options);
    }
    if (!options) {
      if (!isString(presetName)) {
        options = presetName || {};
        presetName = "default";
      }
    }
    this.inline = new parser_inline_default();
    this.block = new parser_block_default();
    this.core = new parser_core_default();
    this.renderer = new renderer_default();
    this.linkify = new linkify_it_default();
    this.validateLink = validateLink;
    this.normalizeLink = normalizeLink;
    this.normalizeLinkText = normalizeLinkText;
    this.utils = utils_exports;
    this.helpers = assign({}, helpers_exports);
    this.options = {};
    this.configure(presetName);
    if (options) {
      this.set(options);
    }
  }
  MarkdownIt.prototype.set = function(options) {
    assign(this.options, options);
    return this;
  };
  MarkdownIt.prototype.configure = function(presets) {
    const self2 = this;
    if (isString(presets)) {
      const presetName = presets;
      presets = config[presetName];
      if (!presets) {
        throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
      }
    }
    if (!presets) {
      throw new Error("Wrong `markdown-it` preset, can't be empty");
    }
    if (presets.options) {
      self2.set(presets.options);
    }
    if (presets.components) {
      Object.keys(presets.components).forEach(function(name2) {
        if (presets.components[name2].rules) {
          self2[name2].ruler.enableOnly(presets.components[name2].rules);
        }
        if (presets.components[name2].rules2) {
          self2[name2].ruler2.enableOnly(presets.components[name2].rules2);
        }
      });
    }
    return this;
  };
  MarkdownIt.prototype.enable = function(list2, ignoreInvalid) {
    let result = [];
    if (!Array.isArray(list2)) {
      list2 = [list2];
    }
    ["core", "block", "inline"].forEach(function(chain) {
      result = result.concat(this[chain].ruler.enable(list2, true));
    }, this);
    result = result.concat(this.inline.ruler2.enable(list2, true));
    const missed = list2.filter(function(name2) {
      return result.indexOf(name2) < 0;
    });
    if (missed.length && !ignoreInvalid) {
      throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
    }
    return this;
  };
  MarkdownIt.prototype.disable = function(list2, ignoreInvalid) {
    let result = [];
    if (!Array.isArray(list2)) {
      list2 = [list2];
    }
    ["core", "block", "inline"].forEach(function(chain) {
      result = result.concat(this[chain].ruler.disable(list2, true));
    }, this);
    result = result.concat(this.inline.ruler2.disable(list2, true));
    const missed = list2.filter(function(name2) {
      return result.indexOf(name2) < 0;
    });
    if (missed.length && !ignoreInvalid) {
      throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
    }
    return this;
  };
  MarkdownIt.prototype.use = function(plugin2) {
    const args = [this].concat(Array.prototype.slice.call(arguments, 1));
    plugin2.apply(plugin2, args);
    return this;
  };
  MarkdownIt.prototype.parse = function(src, env) {
    if (typeof src !== "string") {
      throw new Error("Input data should be a String");
    }
    const state = new this.core.State(src, this, env);
    this.core.process(state);
    return state.tokens;
  };
  MarkdownIt.prototype.render = function(src, env) {
    env = env || {};
    return this.renderer.render(this.parse(src, env), this.options, env);
  };
  MarkdownIt.prototype.parseInline = function(src, env) {
    const state = new this.core.State(src, this, env);
    state.inlineMode = true;
    this.core.process(state);
    return state.tokens;
  };
  MarkdownIt.prototype.renderInline = function(src, env) {
    env = env || {};
    return this.renderer.render(this.parseInline(src, env), this.options, env);
  };
  var lib_default = MarkdownIt;

  // node_modules/markdown-it-ins/index.mjs
  function ins_plugin(md) {
    function tokenize(state, silent) {
      const start2 = state.pos;
      const marker = state.src.charCodeAt(start2);
      if (silent) {
        return false;
      }
      if (marker !== 43) {
        return false;
      }
      const scanned = state.scanDelims(state.pos, true);
      let len = scanned.length;
      const ch = String.fromCharCode(marker);
      if (len < 2) {
        return false;
      }
      if (len % 2) {
        const token = state.push("text", "", 0);
        token.content = ch;
        len--;
      }
      for (let i = 0; i < len; i += 2) {
        const token = state.push("text", "", 0);
        token.content = ch + ch;
        if (!scanned.can_open && !scanned.can_close) {
          continue;
        }
        state.delimiters.push({
          marker,
          length: 0,
          // disable "rule of 3" length checks meant for emphasis
          jump: i / 2,
          // 1 delimiter = 2 characters
          token: state.tokens.length - 1,
          end: -1,
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    }
    function postProcess3(state, delimiters) {
      let token;
      const loneMarkers = [];
      const max3 = delimiters.length;
      for (let i = 0; i < max3; i++) {
        const startDelim = delimiters[i];
        if (startDelim.marker !== 43) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        const endDelim = delimiters[startDelim.end];
        token = state.tokens[startDelim.token];
        token.type = "ins_open";
        token.tag = "ins";
        token.nesting = 1;
        token.markup = "++";
        token.content = "";
        token = state.tokens[endDelim.token];
        token.type = "ins_close";
        token.tag = "ins";
        token.nesting = -1;
        token.markup = "++";
        token.content = "";
        if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "+") {
          loneMarkers.push(endDelim.token - 1);
        }
      }
      while (loneMarkers.length) {
        const i = loneMarkers.pop();
        let j2 = i + 1;
        while (j2 < state.tokens.length && state.tokens[j2].type === "ins_close") {
          j2++;
        }
        j2--;
        if (i !== j2) {
          token = state.tokens[j2];
          state.tokens[j2] = state.tokens[i];
          state.tokens[i] = token;
        }
      }
    }
    md.inline.ruler.before("emphasis", "ins", tokenize);
    md.inline.ruler2.before("emphasis", "ins", function(state) {
      const tokens_meta = state.tokens_meta;
      const max3 = (state.tokens_meta || []).length;
      postProcess3(state, state.delimiters);
      for (let curr = 0; curr < max3; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess3(state, tokens_meta[curr].delimiters);
        }
      }
    });
  }

  // node_modules/markdown-it-mark/index.mjs
  function ins_plugin2(md) {
    function tokenize(state, silent) {
      const start2 = state.pos;
      const marker = state.src.charCodeAt(start2);
      if (silent) {
        return false;
      }
      if (marker !== 61) {
        return false;
      }
      const scanned = state.scanDelims(state.pos, true);
      let len = scanned.length;
      const ch = String.fromCharCode(marker);
      if (len < 2) {
        return false;
      }
      if (len % 2) {
        const token = state.push("text", "", 0);
        token.content = ch;
        len--;
      }
      for (let i = 0; i < len; i += 2) {
        const token = state.push("text", "", 0);
        token.content = ch + ch;
        if (!scanned.can_open && !scanned.can_close) {
          continue;
        }
        state.delimiters.push({
          marker,
          length: 0,
          // disable "rule of 3" length checks meant for emphasis
          jump: i / 2,
          // 1 delimiter = 2 characters
          token: state.tokens.length - 1,
          end: -1,
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    }
    function postProcess3(state, delimiters) {
      const loneMarkers = [];
      const max3 = delimiters.length;
      for (let i = 0; i < max3; i++) {
        const startDelim = delimiters[i];
        if (startDelim.marker !== 61) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        const endDelim = delimiters[startDelim.end];
        const token_o = state.tokens[startDelim.token];
        token_o.type = "mark_open";
        token_o.tag = "mark";
        token_o.nesting = 1;
        token_o.markup = "==";
        token_o.content = "";
        const token_c = state.tokens[endDelim.token];
        token_c.type = "mark_close";
        token_c.tag = "mark";
        token_c.nesting = -1;
        token_c.markup = "==";
        token_c.content = "";
        if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "=") {
          loneMarkers.push(endDelim.token - 1);
        }
      }
      while (loneMarkers.length) {
        const i = loneMarkers.pop();
        let j2 = i + 1;
        while (j2 < state.tokens.length && state.tokens[j2].type === "mark_close") {
          j2++;
        }
        j2--;
        if (i !== j2) {
          const token = state.tokens[j2];
          state.tokens[j2] = state.tokens[i];
          state.tokens[i] = token;
        }
      }
    }
    md.inline.ruler.before("emphasis", "mark", tokenize);
    md.inline.ruler2.before("emphasis", "mark", function(state) {
      let curr;
      const tokens_meta = state.tokens_meta;
      const max3 = (state.tokens_meta || []).length;
      postProcess3(state, state.delimiters);
      for (curr = 0; curr < max3; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess3(state, tokens_meta[curr].delimiters);
        }
      }
    });
  }

  // node_modules/markdown-it-sub/index.mjs
  var UNESCAPE_RE = /\\([ \\!"#$%&'()*+,./:;<=>?@[\]^_`{|}~-])/g;
  function subscript(state, silent) {
    const max3 = state.posMax;
    const start2 = state.pos;
    if (state.src.charCodeAt(start2) !== 126) {
      return false;
    }
    if (silent) {
      return false;
    }
    if (start2 + 2 >= max3) {
      return false;
    }
    state.pos = start2 + 1;
    let found = false;
    while (state.pos < max3) {
      if (state.src.charCodeAt(state.pos) === 126) {
        found = true;
        break;
      }
      state.md.inline.skipToken(state);
    }
    if (!found || start2 + 1 === state.pos) {
      state.pos = start2;
      return false;
    }
    const content = state.src.slice(start2 + 1, state.pos);
    if (content.match(/(^|[^\\])(\\\\)*\s/)) {
      state.pos = start2;
      return false;
    }
    state.posMax = state.pos;
    state.pos = start2 + 1;
    const token_so = state.push("sub_open", "sub", 1);
    token_so.markup = "~";
    const token_t = state.push("text", "", 0);
    token_t.content = content.replace(UNESCAPE_RE, "$1");
    const token_sc = state.push("sub_close", "sub", -1);
    token_sc.markup = "~";
    state.pos = state.posMax + 1;
    state.posMax = max3;
    return true;
  }
  function sub_plugin(md) {
    md.inline.ruler.after("emphasis", "sub", subscript);
  }

  // node_modules/markdown-it-sup/index.mjs
  var UNESCAPE_RE2 = /\\([ \\!"#$%&'()*+,./:;<=>?@[\]^_`{|}~-])/g;
  function superscript(state, silent) {
    const max3 = state.posMax;
    const start2 = state.pos;
    if (state.src.charCodeAt(start2) !== 94) {
      return false;
    }
    if (silent) {
      return false;
    }
    if (start2 + 2 >= max3) {
      return false;
    }
    state.pos = start2 + 1;
    let found = false;
    while (state.pos < max3) {
      if (state.src.charCodeAt(state.pos) === 94) {
        found = true;
        break;
      }
      state.md.inline.skipToken(state);
    }
    if (!found || start2 + 1 === state.pos) {
      state.pos = start2;
      return false;
    }
    const content = state.src.slice(start2 + 1, state.pos);
    if (content.match(/(^|[^\\])(\\\\)*\s/)) {
      state.pos = start2;
      return false;
    }
    state.posMax = state.pos;
    state.pos = start2 + 1;
    const token_so = state.push("sup_open", "sup", 1);
    token_so.markup = "^";
    const token_t = state.push("text", "", 0);
    token_t.content = content.replace(UNESCAPE_RE2, "$1");
    const token_sc = state.push("sup_close", "sup", -1);
    token_sc.markup = "^";
    state.pos = state.posMax + 1;
    state.posMax = max3;
    return true;
  }
  function sup_plugin(md) {
    md.inline.ruler.after("emphasis", "sup", superscript);
  }

  // node_modules/yaml/browser/dist/nodes/identity.js
  var ALIAS = Symbol.for("yaml.alias");
  var DOC = Symbol.for("yaml.document");
  var MAP = Symbol.for("yaml.map");
  var PAIR = Symbol.for("yaml.pair");
  var SCALAR = Symbol.for("yaml.scalar");
  var SEQ = Symbol.for("yaml.seq");
  var NODE_TYPE = Symbol.for("yaml.node.type");
  var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
  var isDocument2 = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
  var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
  var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
  var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
  var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
  function isCollection(node) {
    if (node && typeof node === "object")
      switch (node[NODE_TYPE]) {
        case MAP:
        case SEQ:
          return true;
      }
    return false;
  }
  function isNode2(node) {
    if (node && typeof node === "object")
      switch (node[NODE_TYPE]) {
        case ALIAS:
        case MAP:
        case SCALAR:
        case SEQ:
          return true;
      }
    return false;
  }
  var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;

  // node_modules/yaml/browser/dist/visit.js
  var BREAK = Symbol("break visit");
  var SKIP = Symbol("skip children");
  var REMOVE = Symbol("remove node");
  function visit(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (isDocument2(node)) {
      const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
      if (cd === REMOVE)
        node.contents = null;
    } else
      visit_(null, node, visitor_, Object.freeze([]));
  }
  visit.BREAK = BREAK;
  visit.SKIP = SKIP;
  visit.REMOVE = REMOVE;
  function visit_(key, node, visitor, path2) {
    const ctrl = callVisitor(key, node, visitor, path2);
    if (isNode2(ctrl) || isPair(ctrl)) {
      replaceNode(key, path2, ctrl);
      return visit_(key, ctrl, visitor, path2);
    }
    if (typeof ctrl !== "symbol") {
      if (isCollection(node)) {
        path2 = Object.freeze(path2.concat(node));
        for (let i = 0; i < node.items.length; ++i) {
          const ci = visit_(i, node.items[i], visitor, path2);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            node.items.splice(i, 1);
            i -= 1;
          }
        }
      } else if (isPair(node)) {
        path2 = Object.freeze(path2.concat(node));
        const ck = visit_("key", node.key, visitor, path2);
        if (ck === BREAK)
          return BREAK;
        else if (ck === REMOVE)
          node.key = null;
        const cv = visit_("value", node.value, visitor, path2);
        if (cv === BREAK)
          return BREAK;
        else if (cv === REMOVE)
          node.value = null;
      }
    }
    return ctrl;
  }
  async function visitAsync(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (isDocument2(node)) {
      const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
      if (cd === REMOVE)
        node.contents = null;
    } else
      await visitAsync_(null, node, visitor_, Object.freeze([]));
  }
  visitAsync.BREAK = BREAK;
  visitAsync.SKIP = SKIP;
  visitAsync.REMOVE = REMOVE;
  async function visitAsync_(key, node, visitor, path2) {
    const ctrl = await callVisitor(key, node, visitor, path2);
    if (isNode2(ctrl) || isPair(ctrl)) {
      replaceNode(key, path2, ctrl);
      return visitAsync_(key, ctrl, visitor, path2);
    }
    if (typeof ctrl !== "symbol") {
      if (isCollection(node)) {
        path2 = Object.freeze(path2.concat(node));
        for (let i = 0; i < node.items.length; ++i) {
          const ci = await visitAsync_(i, node.items[i], visitor, path2);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            node.items.splice(i, 1);
            i -= 1;
          }
        }
      } else if (isPair(node)) {
        path2 = Object.freeze(path2.concat(node));
        const ck = await visitAsync_("key", node.key, visitor, path2);
        if (ck === BREAK)
          return BREAK;
        else if (ck === REMOVE)
          node.key = null;
        const cv = await visitAsync_("value", node.value, visitor, path2);
        if (cv === BREAK)
          return BREAK;
        else if (cv === REMOVE)
          node.value = null;
      }
    }
    return ctrl;
  }
  function initVisitor(visitor) {
    if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
      return Object.assign({
        Alias: visitor.Node,
        Map: visitor.Node,
        Scalar: visitor.Node,
        Seq: visitor.Node
      }, visitor.Value && {
        Map: visitor.Value,
        Scalar: visitor.Value,
        Seq: visitor.Value
      }, visitor.Collection && {
        Map: visitor.Collection,
        Seq: visitor.Collection
      }, visitor);
    }
    return visitor;
  }
  function callVisitor(key, node, visitor, path2) {
    if (typeof visitor === "function")
      return visitor(key, node, path2);
    if (isMap(node))
      return visitor.Map?.(key, node, path2);
    if (isSeq(node))
      return visitor.Seq?.(key, node, path2);
    if (isPair(node))
      return visitor.Pair?.(key, node, path2);
    if (isScalar(node))
      return visitor.Scalar?.(key, node, path2);
    if (isAlias(node))
      return visitor.Alias?.(key, node, path2);
    return void 0;
  }
  function replaceNode(key, path2, node) {
    const parent2 = path2[path2.length - 1];
    if (isCollection(parent2)) {
      parent2.items[key] = node;
    } else if (isPair(parent2)) {
      if (key === "key")
        parent2.key = node;
      else
        parent2.value = node;
    } else if (isDocument2(parent2)) {
      parent2.contents = node;
    } else {
      const pt = isAlias(parent2) ? "alias" : "scalar";
      throw new Error(`Cannot replace node with ${pt} parent`);
    }
  }

  // node_modules/yaml/browser/dist/doc/directives.js
  var escapeChars = {
    "!": "%21",
    ",": "%2C",
    "[": "%5B",
    "]": "%5D",
    "{": "%7B",
    "}": "%7D"
  };
  var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
  var Directives = class _Directives {
    constructor(yaml, tags) {
      this.docStart = null;
      this.docEnd = false;
      this.yaml = Object.assign({}, _Directives.defaultYaml, yaml);
      this.tags = Object.assign({}, _Directives.defaultTags, tags);
    }
    clone() {
      const copy = new _Directives(this.yaml, this.tags);
      copy.docStart = this.docStart;
      return copy;
    }
    /**
     * During parsing, get a Directives instance for the current document and
     * update the stream state according to the current version's spec.
     */
    atDocument() {
      const res = new _Directives(this.yaml, this.tags);
      switch (this.yaml.version) {
        case "1.1":
          this.atNextDocument = true;
          break;
        case "1.2":
          this.atNextDocument = false;
          this.yaml = {
            explicit: _Directives.defaultYaml.explicit,
            version: "1.2"
          };
          this.tags = Object.assign({}, _Directives.defaultTags);
          break;
      }
      return res;
    }
    /**
     * @param onError - May be called even if the action was successful
     * @returns `true` on success
     */
    add(line, onError) {
      if (this.atNextDocument) {
        this.yaml = { explicit: _Directives.defaultYaml.explicit, version: "1.1" };
        this.tags = Object.assign({}, _Directives.defaultTags);
        this.atNextDocument = false;
      }
      const parts = line.trim().split(/[ \t]+/);
      const name2 = parts.shift();
      switch (name2) {
        case "%TAG": {
          if (parts.length !== 2) {
            onError(0, "%TAG directive should contain exactly two parts");
            if (parts.length < 2)
              return false;
          }
          const [handle, prefix] = parts;
          this.tags[handle] = prefix;
          return true;
        }
        case "%YAML": {
          this.yaml.explicit = true;
          if (parts.length !== 1) {
            onError(0, "%YAML directive should contain exactly one part");
            return false;
          }
          const [version] = parts;
          if (version === "1.1" || version === "1.2") {
            this.yaml.version = version;
            return true;
          } else {
            const isValid = /^\d+\.\d+$/.test(version);
            onError(6, `Unsupported YAML version ${version}`, isValid);
            return false;
          }
        }
        default:
          onError(0, `Unknown directive ${name2}`, true);
          return false;
      }
    }
    /**
     * Resolves a tag, matching handles to those defined in %TAG directives.
     *
     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
     *   `'!local'` tag, or `null` if unresolvable.
     */
    tagName(source, onError) {
      if (source === "!")
        return "!";
      if (source[0] !== "!") {
        onError(`Not a valid tag: ${source}`);
        return null;
      }
      if (source[1] === "<") {
        const verbatim = source.slice(2, -1);
        if (verbatim === "!" || verbatim === "!!") {
          onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
          return null;
        }
        if (source[source.length - 1] !== ">")
          onError("Verbatim tags must end with a >");
        return verbatim;
      }
      const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
      if (!suffix)
        onError(`The ${source} tag has no suffix`);
      const prefix = this.tags[handle];
      if (prefix) {
        try {
          return prefix + decodeURIComponent(suffix);
        } catch (error2) {
          onError(String(error2));
          return null;
        }
      }
      if (handle === "!")
        return source;
      onError(`Could not resolve tag: ${source}`);
      return null;
    }
    /**
     * Given a fully resolved tag, returns its printable string form,
     * taking into account current tag prefixes and defaults.
     */
    tagString(tag) {
      for (const [handle, prefix] of Object.entries(this.tags)) {
        if (tag.startsWith(prefix))
          return handle + escapeTagName(tag.substring(prefix.length));
      }
      return tag[0] === "!" ? tag : `!<${tag}>`;
    }
    toString(doc) {
      const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
      const tagEntries = Object.entries(this.tags);
      let tagNames;
      if (doc && tagEntries.length > 0 && isNode2(doc.contents)) {
        const tags = {};
        visit(doc.contents, (_key, node) => {
          if (isNode2(node) && node.tag)
            tags[node.tag] = true;
        });
        tagNames = Object.keys(tags);
      } else
        tagNames = [];
      for (const [handle, prefix] of tagEntries) {
        if (handle === "!!" && prefix === "tag:yaml.org,2002:")
          continue;
        if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
          lines.push(`%TAG ${handle} ${prefix}`);
      }
      return lines.join("\n");
    }
  };
  Directives.defaultYaml = { explicit: false, version: "1.2" };
  Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };

  // node_modules/yaml/browser/dist/doc/anchors.js
  function anchorIsValid(anchor) {
    if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
      const sa = JSON.stringify(anchor);
      const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
      throw new Error(msg);
    }
    return true;
  }
  function anchorNames(root3) {
    const anchors = /* @__PURE__ */ new Set();
    visit(root3, {
      Value(_key, node) {
        if (node.anchor)
          anchors.add(node.anchor);
      }
    });
    return anchors;
  }
  function findNewAnchor(prefix, exclude) {
    for (let i = 1; true; ++i) {
      const name2 = `${prefix}${i}`;
      if (!exclude.has(name2))
        return name2;
    }
  }
  function createNodeAnchors(doc, prefix) {
    const aliasObjects = [];
    const sourceObjects = /* @__PURE__ */ new Map();
    let prevAnchors = null;
    return {
      onAnchor: (source) => {
        aliasObjects.push(source);
        prevAnchors ?? (prevAnchors = anchorNames(doc));
        const anchor = findNewAnchor(prefix, prevAnchors);
        prevAnchors.add(anchor);
        return anchor;
      },
      /**
       * With circular references, the source node is only resolved after all
       * of its child nodes are. This is why anchors are set only after all of
       * the nodes have been created.
       */
      setAnchors: () => {
        for (const source of aliasObjects) {
          const ref = sourceObjects.get(source);
          if (typeof ref === "object" && ref.anchor && (isScalar(ref.node) || isCollection(ref.node))) {
            ref.node.anchor = ref.anchor;
          } else {
            const error2 = new Error("Failed to resolve repeated object (this should not happen)");
            error2.source = source;
            throw error2;
          }
        }
      },
      sourceObjects
    };
  }

  // node_modules/yaml/browser/dist/doc/applyReviver.js
  function applyReviver(reviver, obj, key, val2) {
    if (val2 && typeof val2 === "object") {
      if (Array.isArray(val2)) {
        for (let i = 0, len = val2.length; i < len; ++i) {
          const v0 = val2[i];
          const v1 = applyReviver(reviver, val2, String(i), v0);
          if (v1 === void 0)
            delete val2[i];
          else if (v1 !== v0)
            val2[i] = v1;
        }
      } else if (val2 instanceof Map) {
        for (const k of Array.from(val2.keys())) {
          const v0 = val2.get(k);
          const v1 = applyReviver(reviver, val2, k, v0);
          if (v1 === void 0)
            val2.delete(k);
          else if (v1 !== v0)
            val2.set(k, v1);
        }
      } else if (val2 instanceof Set) {
        for (const v0 of Array.from(val2)) {
          const v1 = applyReviver(reviver, val2, v0, v0);
          if (v1 === void 0)
            val2.delete(v0);
          else if (v1 !== v0) {
            val2.delete(v0);
            val2.add(v1);
          }
        }
      } else {
        for (const [k, v0] of Object.entries(val2)) {
          const v1 = applyReviver(reviver, val2, k, v0);
          if (v1 === void 0)
            delete val2[k];
          else if (v1 !== v0)
            val2[k] = v1;
        }
      }
    }
    return reviver.call(obj, key, val2);
  }

  // node_modules/yaml/browser/dist/nodes/toJS.js
  function toJS(value, arg, ctx) {
    if (Array.isArray(value))
      return value.map((v2, i) => toJS(v2, String(i), ctx));
    if (value && typeof value.toJSON === "function") {
      if (!ctx || !hasAnchor(value))
        return value.toJSON(arg, ctx);
      const data2 = { aliasCount: 0, count: 1, res: void 0 };
      ctx.anchors.set(value, data2);
      ctx.onCreate = (res2) => {
        data2.res = res2;
        delete ctx.onCreate;
      };
      const res = value.toJSON(arg, ctx);
      if (ctx.onCreate)
        ctx.onCreate(res);
      return res;
    }
    if (typeof value === "bigint" && !ctx?.keep)
      return Number(value);
    return value;
  }

  // node_modules/yaml/browser/dist/nodes/Node.js
  var NodeBase = class {
    constructor(type2) {
      Object.defineProperty(this, NODE_TYPE, { value: type2 });
    }
    /** Create a copy of this node.  */
    clone() {
      const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    /** A plain JavaScript representation of this node. */
    toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
      if (!isDocument2(doc))
        throw new TypeError("A document argument is required");
      const ctx = {
        anchors: /* @__PURE__ */ new Map(),
        doc,
        keep: true,
        mapAsMap: mapAsMap === true,
        mapKeyWarned: false,
        maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
      };
      const res = toJS(this, "", ctx);
      if (typeof onAnchor === "function")
        for (const { count, res: res2 } of ctx.anchors.values())
          onAnchor(res2, count);
      return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
    }
  };

  // node_modules/yaml/browser/dist/nodes/Alias.js
  var Alias = class extends NodeBase {
    constructor(source) {
      super(ALIAS);
      this.source = source;
      Object.defineProperty(this, "tag", {
        set() {
          throw new Error("Alias nodes cannot have tags");
        }
      });
    }
    /**
     * Resolve the value of this alias within `doc`, finding the last
     * instance of the `source` anchor before this node.
     */
    resolve(doc, ctx) {
      let nodes;
      if (ctx?.aliasResolveCache) {
        nodes = ctx.aliasResolveCache;
      } else {
        nodes = [];
        visit(doc, {
          Node: (_key, node) => {
            if (isAlias(node) || hasAnchor(node))
              nodes.push(node);
          }
        });
        if (ctx)
          ctx.aliasResolveCache = nodes;
      }
      let found = void 0;
      for (const node of nodes) {
        if (node === this)
          break;
        if (node.anchor === this.source)
          found = node;
      }
      return found;
    }
    toJSON(_arg, ctx) {
      if (!ctx)
        return { source: this.source };
      const { anchors, doc, maxAliasCount } = ctx;
      const source = this.resolve(doc, ctx);
      if (!source) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new ReferenceError(msg);
      }
      let data2 = anchors.get(source);
      if (!data2) {
        toJS(source, null, ctx);
        data2 = anchors.get(source);
      }
      if (data2?.res === void 0) {
        const msg = "This should not happen: Alias anchor was not resolved?";
        throw new ReferenceError(msg);
      }
      if (maxAliasCount >= 0) {
        data2.count += 1;
        if (data2.aliasCount === 0)
          data2.aliasCount = getAliasCount(doc, source, anchors);
        if (data2.count * data2.aliasCount > maxAliasCount) {
          const msg = "Excessive alias count indicates a resource exhaustion attack";
          throw new ReferenceError(msg);
        }
      }
      return data2.res;
    }
    toString(ctx, _onComment, _onChompKeep) {
      const src = `*${this.source}`;
      if (ctx) {
        anchorIsValid(this.source);
        if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new Error(msg);
        }
        if (ctx.implicitKey)
          return `${src} `;
      }
      return src;
    }
  };
  function getAliasCount(doc, node, anchors) {
    if (isAlias(node)) {
      const source = node.resolve(doc);
      const anchor = anchors && source && anchors.get(source);
      return anchor ? anchor.count * anchor.aliasCount : 0;
    } else if (isCollection(node)) {
      let count = 0;
      for (const item of node.items) {
        const c = getAliasCount(doc, item, anchors);
        if (c > count)
          count = c;
      }
      return count;
    } else if (isPair(node)) {
      const kc = getAliasCount(doc, node.key, anchors);
      const vc = getAliasCount(doc, node.value, anchors);
      return Math.max(kc, vc);
    }
    return 1;
  }

  // node_modules/yaml/browser/dist/nodes/Scalar.js
  var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
  var Scalar = class extends NodeBase {
    constructor(value) {
      super(SCALAR);
      this.value = value;
    }
    toJSON(arg, ctx) {
      return ctx?.keep ? this.value : toJS(this.value, arg, ctx);
    }
    toString() {
      return String(this.value);
    }
  };
  Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
  Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
  Scalar.PLAIN = "PLAIN";
  Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
  Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";

  // node_modules/yaml/browser/dist/doc/createNode.js
  var defaultTagPrefix = "tag:yaml.org,2002:";
  function findTagObject(value, tagName, tags) {
    if (tagName) {
      const match2 = tags.filter((t) => t.tag === tagName);
      const tagObj = match2.find((t) => !t.format) ?? match2[0];
      if (!tagObj)
        throw new Error(`Tag ${tagName} not found`);
      return tagObj;
    }
    return tags.find((t) => t.identify?.(value) && !t.format);
  }
  function createNode(value, tagName, ctx) {
    if (isDocument2(value))
      value = value.contents;
    if (isNode2(value))
      return value;
    if (isPair(value)) {
      const map4 = ctx.schema[MAP].createNode?.(ctx.schema, null, ctx);
      map4.items.push(value);
      return map4;
    }
    if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
      value = value.valueOf();
    }
    const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema4, sourceObjects } = ctx;
    let ref = void 0;
    if (aliasDuplicateObjects && value && typeof value === "object") {
      ref = sourceObjects.get(value);
      if (ref) {
        ref.anchor ?? (ref.anchor = onAnchor(value));
        return new Alias(ref.anchor);
      } else {
        ref = { anchor: null, node: null };
        sourceObjects.set(value, ref);
      }
    }
    if (tagName?.startsWith("!!"))
      tagName = defaultTagPrefix + tagName.slice(2);
    let tagObj = findTagObject(value, tagName, schema4.tags);
    if (!tagObj) {
      if (value && typeof value.toJSON === "function") {
        value = value.toJSON();
      }
      if (!value || typeof value !== "object") {
        const node2 = new Scalar(value);
        if (ref)
          ref.node = node2;
        return node2;
      }
      tagObj = value instanceof Map ? schema4[MAP] : Symbol.iterator in Object(value) ? schema4[SEQ] : schema4[MAP];
    }
    if (onTagObj) {
      onTagObj(tagObj);
      delete ctx.onTagObj;
    }
    const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar(value);
    if (tagName)
      node.tag = tagName;
    else if (!tagObj.default)
      node.tag = tagObj.tag;
    if (ref)
      ref.node = node;
    return node;
  }

  // node_modules/yaml/browser/dist/nodes/Collection.js
  function collectionFromPath(schema4, path2, value) {
    let v2 = value;
    for (let i = path2.length - 1; i >= 0; --i) {
      const k = path2[i];
      if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
        const a = [];
        a[k] = v2;
        v2 = a;
      } else {
        v2 = /* @__PURE__ */ new Map([[k, v2]]);
      }
    }
    return createNode(v2, void 0, {
      aliasDuplicateObjects: false,
      keepUndefined: false,
      onAnchor: () => {
        throw new Error("This should not happen, please report a bug.");
      },
      schema: schema4,
      sourceObjects: /* @__PURE__ */ new Map()
    });
  }
  var isEmptyPath = (path2) => path2 == null || typeof path2 === "object" && !!path2[Symbol.iterator]().next().done;
  var Collection = class extends NodeBase {
    constructor(type2, schema4) {
      super(type2);
      Object.defineProperty(this, "schema", {
        value: schema4,
        configurable: true,
        enumerable: false,
        writable: true
      });
    }
    /**
     * Create a copy of this collection.
     *
     * @param schema - If defined, overwrites the original's schema
     */
    clone(schema4) {
      const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
      if (schema4)
        copy.schema = schema4;
      copy.items = copy.items.map((it2) => isNode2(it2) || isPair(it2) ? it2.clone(schema4) : it2);
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    /**
     * Adds a value to the collection. For `!!map` and `!!omap` the value must
     * be a Pair instance or a `{ key, value }` object, which may not have a key
     * that already exists in the map.
     */
    addIn(path2, value) {
      if (isEmptyPath(path2))
        this.add(value);
      else {
        const [key, ...rest] = path2;
        const node = this.get(key, true);
        if (isCollection(node))
          node.addIn(rest, value);
        else if (node === void 0 && this.schema)
          this.set(key, collectionFromPath(this.schema, rest, value));
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
    }
    /**
     * Removes a value from the collection.
     * @returns `true` if the item was found and removed.
     */
    deleteIn(path2) {
      const [key, ...rest] = path2;
      if (rest.length === 0)
        return this.delete(key);
      const node = this.get(key, true);
      if (isCollection(node))
        return node.deleteIn(rest);
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    getIn(path2, keepScalar) {
      const [key, ...rest] = path2;
      const node = this.get(key, true);
      if (rest.length === 0)
        return !keepScalar && isScalar(node) ? node.value : node;
      else
        return isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
    }
    hasAllNullValues(allowScalar) {
      return this.items.every((node) => {
        if (!isPair(node))
          return false;
        const n = node.value;
        return n == null || allowScalar && isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
      });
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     */
    hasIn(path2) {
      const [key, ...rest] = path2;
      if (rest.length === 0)
        return this.has(key);
      const node = this.get(key, true);
      return isCollection(node) ? node.hasIn(rest) : false;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    setIn(path2, value) {
      const [key, ...rest] = path2;
      if (rest.length === 0) {
        this.set(key, value);
      } else {
        const node = this.get(key, true);
        if (isCollection(node))
          node.setIn(rest, value);
        else if (node === void 0 && this.schema)
          this.set(key, collectionFromPath(this.schema, rest, value));
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
    }
  };

  // node_modules/yaml/browser/dist/stringify/stringifyComment.js
  var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
  function indentComment(comment2, indent) {
    if (/^\n+$/.test(comment2))
      return comment2.substring(1);
    return indent ? comment2.replace(/^(?! *$)/gm, indent) : comment2;
  }
  var lineComment = (str, indent, comment2) => str.endsWith("\n") ? indentComment(comment2, indent) : comment2.includes("\n") ? "\n" + indentComment(comment2, indent) : (str.endsWith(" ") ? "" : " ") + comment2;

  // node_modules/yaml/browser/dist/stringify/foldFlowLines.js
  var FOLD_FLOW = "flow";
  var FOLD_BLOCK = "block";
  var FOLD_QUOTED = "quoted";
  function foldFlowLines(text3, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
    if (!lineWidth || lineWidth < 0)
      return text3;
    if (lineWidth < minContentWidth)
      minContentWidth = 0;
    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
    if (text3.length <= endStep)
      return text3;
    const folds = [];
    const escapedFolds = {};
    let end2 = lineWidth - indent.length;
    if (typeof indentAtStart === "number") {
      if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
        folds.push(0);
      else
        end2 = lineWidth - indentAtStart;
    }
    let split = void 0;
    let prev2 = void 0;
    let overflow = false;
    let i = -1;
    let escStart = -1;
    let escEnd = -1;
    if (mode === FOLD_BLOCK) {
      i = consumeMoreIndentedLines(text3, i, indent.length);
      if (i !== -1)
        end2 = i + endStep;
    }
    for (let ch; ch = text3[i += 1]; ) {
      if (mode === FOLD_QUOTED && ch === "\\") {
        escStart = i;
        switch (text3[i + 1]) {
          case "x":
            i += 3;
            break;
          case "u":
            i += 5;
            break;
          case "U":
            i += 9;
            break;
          default:
            i += 1;
        }
        escEnd = i;
      }
      if (ch === "\n") {
        if (mode === FOLD_BLOCK)
          i = consumeMoreIndentedLines(text3, i, indent.length);
        end2 = i + indent.length + endStep;
        split = void 0;
      } else {
        if (ch === " " && prev2 && prev2 !== " " && prev2 !== "\n" && prev2 !== "	") {
          const next2 = text3[i + 1];
          if (next2 && next2 !== " " && next2 !== "\n" && next2 !== "	")
            split = i;
        }
        if (i >= end2) {
          if (split) {
            folds.push(split);
            end2 = split + endStep;
            split = void 0;
          } else if (mode === FOLD_QUOTED) {
            while (prev2 === " " || prev2 === "	") {
              prev2 = ch;
              ch = text3[i += 1];
              overflow = true;
            }
            const j2 = i > escEnd + 1 ? i - 2 : escStart - 1;
            if (escapedFolds[j2])
              return text3;
            folds.push(j2);
            escapedFolds[j2] = true;
            end2 = j2 + endStep;
            split = void 0;
          } else {
            overflow = true;
          }
        }
      }
      prev2 = ch;
    }
    if (overflow && onOverflow)
      onOverflow();
    if (folds.length === 0)
      return text3;
    if (onFold)
      onFold();
    let res = text3.slice(0, folds[0]);
    for (let i2 = 0; i2 < folds.length; ++i2) {
      const fold = folds[i2];
      const end3 = folds[i2 + 1] || text3.length;
      if (fold === 0)
        res = `
${indent}${text3.slice(0, end3)}`;
      else {
        if (mode === FOLD_QUOTED && escapedFolds[fold])
          res += `${text3[fold]}\\`;
        res += `
${indent}${text3.slice(fold + 1, end3)}`;
      }
    }
    return res;
  }
  function consumeMoreIndentedLines(text3, i, indent) {
    let end2 = i;
    let start2 = i + 1;
    let ch = text3[start2];
    while (ch === " " || ch === "	") {
      if (i < start2 + indent) {
        ch = text3[++i];
      } else {
        do {
          ch = text3[++i];
        } while (ch && ch !== "\n");
        end2 = i;
        start2 = i + 1;
        ch = text3[start2];
      }
    }
    return end2;
  }

  // node_modules/yaml/browser/dist/stringify/stringifyString.js
  var getFoldOptions = (ctx, isBlock2) => ({
    indentAtStart: isBlock2 ? ctx.indent.length : ctx.indentAtStart,
    lineWidth: ctx.options.lineWidth,
    minContentWidth: ctx.options.minContentWidth
  });
  var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
  function lineLengthOverLimit(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0)
      return false;
    const limit = lineWidth - indentLength;
    const strLen = str.length;
    if (strLen <= limit)
      return false;
    for (let i = 0, start2 = 0; i < strLen; ++i) {
      if (str[i] === "\n") {
        if (i - start2 > limit)
          return true;
        start2 = i + 1;
        if (strLen - start2 <= limit)
          return false;
      }
    }
    return true;
  }
  function doubleQuotedString(value, ctx) {
    const json = JSON.stringify(value);
    if (ctx.options.doubleQuotedAsJSON)
      return json;
    const { implicitKey } = ctx;
    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
    const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
    let str = "";
    let start2 = 0;
    for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
      if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
        str += json.slice(start2, i) + "\\ ";
        i += 1;
        start2 = i;
        ch = "\\";
      }
      if (ch === "\\")
        switch (json[i + 1]) {
          case "u":
            {
              str += json.slice(start2, i);
              const code2 = json.substr(i + 2, 4);
              switch (code2) {
                case "0000":
                  str += "\\0";
                  break;
                case "0007":
                  str += "\\a";
                  break;
                case "000b":
                  str += "\\v";
                  break;
                case "001b":
                  str += "\\e";
                  break;
                case "0085":
                  str += "\\N";
                  break;
                case "00a0":
                  str += "\\_";
                  break;
                case "2028":
                  str += "\\L";
                  break;
                case "2029":
                  str += "\\P";
                  break;
                default:
                  if (code2.substr(0, 2) === "00")
                    str += "\\x" + code2.substr(2);
                  else
                    str += json.substr(i, 6);
              }
              i += 5;
              start2 = i + 1;
            }
            break;
          case "n":
            if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
              i += 1;
            } else {
              str += json.slice(start2, i) + "\n\n";
              while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
                str += "\n";
                i += 2;
              }
              str += indent;
              if (json[i + 2] === " ")
                str += "\\";
              i += 1;
              start2 = i + 1;
            }
            break;
          default:
            i += 1;
        }
    }
    str = start2 ? str + json.slice(start2) : json;
    return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));
  }
  function singleQuotedString(value, ctx) {
    if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
      return doubleQuotedString(value, ctx);
    const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
    const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
    return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));
  }
  function quotedString(value, ctx) {
    const { singleQuote } = ctx.options;
    let qs;
    if (singleQuote === false)
      qs = doubleQuotedString;
    else {
      const hasDouble = value.includes('"');
      const hasSingle = value.includes("'");
      if (hasDouble && !hasSingle)
        qs = singleQuotedString;
      else if (hasSingle && !hasDouble)
        qs = doubleQuotedString;
      else
        qs = singleQuote ? singleQuotedString : doubleQuotedString;
    }
    return qs(value, ctx);
  }
  var blockEndNewlines;
  try {
    blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
  } catch {
    blockEndNewlines = /\n+(?!\n|$)/g;
  }
  function blockString({ comment: comment2, type: type2, value }, ctx, onComment, onChompKeep) {
    const { blockQuote, commentString, lineWidth } = ctx.options;
    if (!blockQuote || /\n[\t ]+$/.test(value)) {
      return quotedString(value, ctx);
    }
    const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
    const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type2 === Scalar.BLOCK_FOLDED ? false : type2 === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
    if (!value)
      return literal ? "|\n" : ">\n";
    let chomp;
    let endStart;
    for (endStart = value.length; endStart > 0; --endStart) {
      const ch = value[endStart - 1];
      if (ch !== "\n" && ch !== "	" && ch !== " ")
        break;
    }
    let end2 = value.substring(endStart);
    const endNlPos = end2.indexOf("\n");
    if (endNlPos === -1) {
      chomp = "-";
    } else if (value === end2 || endNlPos !== end2.length - 1) {
      chomp = "+";
      if (onChompKeep)
        onChompKeep();
    } else {
      chomp = "";
    }
    if (end2) {
      value = value.slice(0, -end2.length);
      if (end2[end2.length - 1] === "\n")
        end2 = end2.slice(0, -1);
      end2 = end2.replace(blockEndNewlines, `$&${indent}`);
    }
    let startWithSpace = false;
    let startEnd;
    let startNlPos = -1;
    for (startEnd = 0; startEnd < value.length; ++startEnd) {
      const ch = value[startEnd];
      if (ch === " ")
        startWithSpace = true;
      else if (ch === "\n")
        startNlPos = startEnd;
      else
        break;
    }
    let start2 = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
    if (start2) {
      value = value.substring(start2.length);
      start2 = start2.replace(/\n+/g, `$&${indent}`);
    }
    const indentSize = indent ? "2" : "1";
    let header = (startWithSpace ? indentSize : "") + chomp;
    if (comment2) {
      header += " " + commentString(comment2.replace(/ ?[\r\n]+/g, " "));
      if (onComment)
        onComment();
    }
    if (!literal) {
      const foldedValue = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
      let literalFallback = false;
      const foldOptions = getFoldOptions(ctx, true);
      if (blockQuote !== "folded" && type2 !== Scalar.BLOCK_FOLDED) {
        foldOptions.onOverflow = () => {
          literalFallback = true;
        };
      }
      const body = foldFlowLines(`${start2}${foldedValue}${end2}`, indent, FOLD_BLOCK, foldOptions);
      if (!literalFallback)
        return `>${header}
${indent}${body}`;
    }
    value = value.replace(/\n+/g, `$&${indent}`);
    return `|${header}
${indent}${start2}${value}${end2}`;
  }
  function plainString(item, ctx, onComment, onChompKeep) {
    const { type: type2, value } = item;
    const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
    if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) {
      return quotedString(value, ctx);
    }
    if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
      return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
    }
    if (!implicitKey && !inFlow && type2 !== Scalar.PLAIN && value.includes("\n")) {
      return blockString(item, ctx, onComment, onChompKeep);
    }
    if (containsDocumentMarker(value)) {
      if (indent === "") {
        ctx.forceBlockIndent = true;
        return blockString(item, ctx, onComment, onChompKeep);
      } else if (implicitKey && indent === indentStep) {
        return quotedString(value, ctx);
      }
    }
    const str = value.replace(/\n+/g, `$&
${indent}`);
    if (actualString) {
      const test2 = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
      const { compat, tags } = ctx.doc.schema;
      if (tags.some(test2) || compat?.some(test2))
        return quotedString(value, ctx);
    }
    return implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx, false));
  }
  function stringifyString(item, ctx, onComment, onChompKeep) {
    const { implicitKey, inFlow } = ctx;
    const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
    let { type: type2 } = item;
    if (type2 !== Scalar.QUOTE_DOUBLE) {
      if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
        type2 = Scalar.QUOTE_DOUBLE;
    }
    const _stringify = (_type) => {
      switch (_type) {
        case Scalar.BLOCK_FOLDED:
        case Scalar.BLOCK_LITERAL:
          return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
        case Scalar.QUOTE_DOUBLE:
          return doubleQuotedString(ss.value, ctx);
        case Scalar.QUOTE_SINGLE:
          return singleQuotedString(ss.value, ctx);
        case Scalar.PLAIN:
          return plainString(ss, ctx, onComment, onChompKeep);
        default:
          return null;
      }
    };
    let res = _stringify(type2);
    if (res === null) {
      const { defaultKeyType, defaultStringType } = ctx.options;
      const t = implicitKey && defaultKeyType || defaultStringType;
      res = _stringify(t);
      if (res === null)
        throw new Error(`Unsupported default string type ${t}`);
    }
    return res;
  }

  // node_modules/yaml/browser/dist/stringify/stringify.js
  function createStringifyContext(doc, options) {
    const opt = Object.assign({
      blockQuote: true,
      commentString: stringifyComment,
      defaultKeyType: null,
      defaultStringType: "PLAIN",
      directives: null,
      doubleQuotedAsJSON: false,
      doubleQuotedMinMultiLineLength: 40,
      falseStr: "false",
      flowCollectionPadding: true,
      indentSeq: true,
      lineWidth: 80,
      minContentWidth: 20,
      nullStr: "null",
      simpleKeys: false,
      singleQuote: null,
      trueStr: "true",
      verifyAliasOrder: true
    }, doc.schema.toStringOptions, options);
    let inFlow;
    switch (opt.collectionStyle) {
      case "block":
        inFlow = false;
        break;
      case "flow":
        inFlow = true;
        break;
      default:
        inFlow = null;
    }
    return {
      anchors: /* @__PURE__ */ new Set(),
      doc,
      flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
      indent: "",
      indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
      inFlow,
      options: opt
    };
  }
  function getTagObject(tags, item) {
    if (item.tag) {
      const match2 = tags.filter((t) => t.tag === item.tag);
      if (match2.length > 0)
        return match2.find((t) => t.format === item.format) ?? match2[0];
    }
    let tagObj = void 0;
    let obj;
    if (isScalar(item)) {
      obj = item.value;
      let match2 = tags.filter((t) => t.identify?.(obj));
      if (match2.length > 1) {
        const testMatch = match2.filter((t) => t.test);
        if (testMatch.length > 0)
          match2 = testMatch;
      }
      tagObj = match2.find((t) => t.format === item.format) ?? match2.find((t) => !t.format);
    } else {
      obj = item;
      tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
    }
    if (!tagObj) {
      const name2 = obj?.constructor?.name ?? (obj === null ? "null" : typeof obj);
      throw new Error(`Tag not resolved for ${name2} value`);
    }
    return tagObj;
  }
  function stringifyProps(node, tagObj, { anchors, doc }) {
    if (!doc.directives)
      return "";
    const props = [];
    const anchor = (isScalar(node) || isCollection(node)) && node.anchor;
    if (anchor && anchorIsValid(anchor)) {
      anchors.add(anchor);
      props.push(`&${anchor}`);
    }
    const tag = node.tag ?? (tagObj.default ? null : tagObj.tag);
    if (tag)
      props.push(doc.directives.tagString(tag));
    return props.join(" ");
  }
  function stringify2(item, ctx, onComment, onChompKeep) {
    if (isPair(item))
      return item.toString(ctx, onComment, onChompKeep);
    if (isAlias(item)) {
      if (ctx.doc.directives)
        return item.toString(ctx);
      if (ctx.resolvedAliases?.has(item)) {
        throw new TypeError(`Cannot stringify circular structure without alias nodes`);
      } else {
        if (ctx.resolvedAliases)
          ctx.resolvedAliases.add(item);
        else
          ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
        item = item.resolve(ctx.doc);
      }
    }
    let tagObj = void 0;
    const node = isNode2(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
    tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));
    const props = stringifyProps(node, tagObj, ctx);
    if (props.length > 0)
      ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
    const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : isScalar(node) ? stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
    if (!props)
      return str;
    return isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
  }

  // node_modules/yaml/browser/dist/stringify/stringifyPair.js
  function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
    let keyComment = isNode2(key) && key.comment || null;
    if (simpleKeys) {
      if (keyComment) {
        throw new Error("With simple keys, key nodes cannot have comments");
      }
      if (isCollection(key) || !isNode2(key) && typeof key === "object") {
        const msg = "With simple keys, collection cannot be used as a key value";
        throw new Error(msg);
      }
    }
    let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || isCollection(key) || (isScalar(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
    ctx = Object.assign({}, ctx, {
      allNullValues: false,
      implicitKey: !explicitKey && (simpleKeys || !allNullValues),
      indent: indent + indentStep
    });
    let keyCommentDone = false;
    let chompKeep = false;
    let str = stringify2(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
    if (!explicitKey && !ctx.inFlow && str.length > 1024) {
      if (simpleKeys)
        throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
      explicitKey = true;
    }
    if (ctx.inFlow) {
      if (allNullValues || value == null) {
        if (keyCommentDone && onComment)
          onComment();
        return str === "" ? "?" : explicitKey ? `? ${str}` : str;
      }
    } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
      str = `? ${str}`;
      if (keyComment && !keyCommentDone) {
        str += lineComment(str, ctx.indent, commentString(keyComment));
      } else if (chompKeep && onChompKeep)
        onChompKeep();
      return str;
    }
    if (keyCommentDone)
      keyComment = null;
    if (explicitKey) {
      if (keyComment)
        str += lineComment(str, ctx.indent, commentString(keyComment));
      str = `? ${str}
${indent}:`;
    } else {
      str = `${str}:`;
      if (keyComment)
        str += lineComment(str, ctx.indent, commentString(keyComment));
    }
    let vsb, vcb, valueComment;
    if (isNode2(value)) {
      vsb = !!value.spaceBefore;
      vcb = value.commentBefore;
      valueComment = value.comment;
    } else {
      vsb = false;
      vcb = null;
      valueComment = null;
      if (value && typeof value === "object")
        value = doc.createNode(value);
    }
    ctx.implicitKey = false;
    if (!explicitKey && !keyComment && isScalar(value))
      ctx.indentAtStart = str.length + 1;
    chompKeep = false;
    if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) {
      ctx.indent = ctx.indent.substring(2);
    }
    let valueCommentDone = false;
    const valueStr = stringify2(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
    let ws = " ";
    if (keyComment || vsb || vcb) {
      ws = vsb ? "\n" : "";
      if (vcb) {
        const cs = commentString(vcb);
        ws += `
${indentComment(cs, ctx.indent)}`;
      }
      if (valueStr === "" && !ctx.inFlow) {
        if (ws === "\n" && valueComment)
          ws = "\n\n";
      } else {
        ws += `
${ctx.indent}`;
      }
    } else if (!explicitKey && isCollection(value)) {
      const vs0 = valueStr[0];
      const nl0 = valueStr.indexOf("\n");
      const hasNewline = nl0 !== -1;
      const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
      if (hasNewline || !flow) {
        let hasPropsLine = false;
        if (hasNewline && (vs0 === "&" || vs0 === "!")) {
          let sp0 = valueStr.indexOf(" ");
          if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
            sp0 = valueStr.indexOf(" ", sp0 + 1);
          }
          if (sp0 === -1 || nl0 < sp0)
            hasPropsLine = true;
        }
        if (!hasPropsLine)
          ws = `
${ctx.indent}`;
      }
    } else if (valueStr === "" || valueStr[0] === "\n") {
      ws = "";
    }
    str += ws + valueStr;
    if (ctx.inFlow) {
      if (valueCommentDone && onComment)
        onComment();
    } else if (valueComment && !valueCommentDone) {
      str += lineComment(str, ctx.indent, commentString(valueComment));
    } else if (chompKeep && onChompKeep) {
      onChompKeep();
    }
    return str;
  }

  // node_modules/yaml/browser/dist/log.js
  function warn(logLevel, warning) {
    if (logLevel === "debug" || logLevel === "warn") {
      console.warn(warning);
    }
  }

  // node_modules/yaml/browser/dist/schema/yaml-1.1/merge.js
  var MERGE_KEY = "<<";
  var merge2 = {
    identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
    default: "key",
    tag: "tag:yaml.org,2002:merge",
    test: /^<<$/,
    resolve: () => Object.assign(new Scalar(Symbol(MERGE_KEY)), {
      addToJSMap: addMergeToJSMap
    }),
    stringify: () => MERGE_KEY
  };
  var isMergeKey = (ctx, key) => (merge2.identify(key) || isScalar(key) && (!key.type || key.type === Scalar.PLAIN) && merge2.identify(key.value)) && ctx?.doc.schema.tags.some((tag) => tag.tag === merge2.tag && tag.default);
  function addMergeToJSMap(ctx, map4, value) {
    value = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
    if (isSeq(value))
      for (const it2 of value.items)
        mergeValue(ctx, map4, it2);
    else if (Array.isArray(value))
      for (const it2 of value)
        mergeValue(ctx, map4, it2);
    else
      mergeValue(ctx, map4, value);
  }
  function mergeValue(ctx, map4, value) {
    const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
    if (!isMap(source))
      throw new Error("Merge sources must be maps or map aliases");
    const srcMap = source.toJSON(null, ctx, Map);
    for (const [key, value2] of srcMap) {
      if (map4 instanceof Map) {
        if (!map4.has(key))
          map4.set(key, value2);
      } else if (map4 instanceof Set) {
        map4.add(key);
      } else if (!Object.prototype.hasOwnProperty.call(map4, key)) {
        Object.defineProperty(map4, key, {
          value: value2,
          writable: true,
          enumerable: true,
          configurable: true
        });
      }
    }
    return map4;
  }

  // node_modules/yaml/browser/dist/nodes/addPairToJSMap.js
  function addPairToJSMap(ctx, map4, { key, value }) {
    if (isNode2(key) && key.addToJSMap)
      key.addToJSMap(ctx, map4, value);
    else if (isMergeKey(ctx, key))
      addMergeToJSMap(ctx, map4, value);
    else {
      const jsKey = toJS(key, "", ctx);
      if (map4 instanceof Map) {
        map4.set(jsKey, toJS(value, jsKey, ctx));
      } else if (map4 instanceof Set) {
        map4.add(jsKey);
      } else {
        const stringKey = stringifyKey(key, jsKey, ctx);
        const jsValue = toJS(value, stringKey, ctx);
        if (stringKey in map4)
          Object.defineProperty(map4, stringKey, {
            value: jsValue,
            writable: true,
            enumerable: true,
            configurable: true
          });
        else
          map4[stringKey] = jsValue;
      }
    }
    return map4;
  }
  function stringifyKey(key, jsKey, ctx) {
    if (jsKey === null)
      return "";
    if (typeof jsKey !== "object")
      return String(jsKey);
    if (isNode2(key) && ctx?.doc) {
      const strCtx = createStringifyContext(ctx.doc, {});
      strCtx.anchors = /* @__PURE__ */ new Set();
      for (const node of ctx.anchors.keys())
        strCtx.anchors.add(node.anchor);
      strCtx.inFlow = true;
      strCtx.inStringifyKey = true;
      const strKey = key.toString(strCtx);
      if (!ctx.mapKeyWarned) {
        let jsonStr = JSON.stringify(strKey);
        if (jsonStr.length > 40)
          jsonStr = jsonStr.substring(0, 36) + '..."';
        warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
        ctx.mapKeyWarned = true;
      }
      return strKey;
    }
    return JSON.stringify(jsKey);
  }

  // node_modules/yaml/browser/dist/nodes/Pair.js
  function createPair(key, value, ctx) {
    const k = createNode(key, void 0, ctx);
    const v2 = createNode(value, void 0, ctx);
    return new Pair(k, v2);
  }
  var Pair = class _Pair {
    constructor(key, value = null) {
      Object.defineProperty(this, NODE_TYPE, { value: PAIR });
      this.key = key;
      this.value = value;
    }
    clone(schema4) {
      let { key, value } = this;
      if (isNode2(key))
        key = key.clone(schema4);
      if (isNode2(value))
        value = value.clone(schema4);
      return new _Pair(key, value);
    }
    toJSON(_2, ctx) {
      const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
      return addPairToJSMap(ctx, pair, this);
    }
    toString(ctx, onComment, onChompKeep) {
      return ctx?.doc ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
    }
  };

  // node_modules/yaml/browser/dist/stringify/stringifyCollection.js
  function stringifyCollection(collection, ctx, options) {
    const flow = ctx.inFlow ?? collection.flow;
    const stringify5 = flow ? stringifyFlowCollection : stringifyBlockCollection;
    return stringify5(collection, ctx, options);
  }
  function stringifyBlockCollection({ comment: comment2, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
    const { indent, options: { commentString } } = ctx;
    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
    let chompKeep = false;
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
      const item = items[i];
      let comment3 = null;
      if (isNode2(item)) {
        if (!chompKeep && item.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
        if (item.comment)
          comment3 = item.comment;
      } else if (isPair(item)) {
        const ik = isNode2(item.key) ? item.key : null;
        if (ik) {
          if (!chompKeep && ik.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
        }
      }
      chompKeep = false;
      let str2 = stringify2(item, itemCtx, () => comment3 = null, () => chompKeep = true);
      if (comment3)
        str2 += lineComment(str2, itemIndent, commentString(comment3));
      if (chompKeep && comment3)
        chompKeep = false;
      lines.push(blockItemPrefix + str2);
    }
    let str;
    if (lines.length === 0) {
      str = flowChars.start + flowChars.end;
    } else {
      str = lines[0];
      for (let i = 1; i < lines.length; ++i) {
        const line = lines[i];
        str += line ? `
${indent}${line}` : "\n";
      }
    }
    if (comment2) {
      str += "\n" + indentComment(commentString(comment2), indent);
      if (onComment)
        onComment();
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
    const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
    itemIndent += indentStep;
    const itemCtx = Object.assign({}, ctx, {
      indent: itemIndent,
      inFlow: true,
      type: null
    });
    let reqNewline = false;
    let linesAtValue = 0;
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
      const item = items[i];
      let comment2 = null;
      if (isNode2(item)) {
        if (item.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, item.commentBefore, false);
        if (item.comment)
          comment2 = item.comment;
      } else if (isPair(item)) {
        const ik = isNode2(item.key) ? item.key : null;
        if (ik) {
          if (ik.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, ik.commentBefore, false);
          if (ik.comment)
            reqNewline = true;
        }
        const iv = isNode2(item.value) ? item.value : null;
        if (iv) {
          if (iv.comment)
            comment2 = iv.comment;
          if (iv.commentBefore)
            reqNewline = true;
        } else if (item.value == null && ik?.comment) {
          comment2 = ik.comment;
        }
      }
      if (comment2)
        reqNewline = true;
      let str = stringify2(item, itemCtx, () => comment2 = null);
      if (i < items.length - 1)
        str += ",";
      if (comment2)
        str += lineComment(str, itemIndent, commentString(comment2));
      if (!reqNewline && (lines.length > linesAtValue || str.includes("\n")))
        reqNewline = true;
      lines.push(str);
      linesAtValue = lines.length;
    }
    const { start: start2, end: end2 } = flowChars;
    if (lines.length === 0) {
      return start2 + end2;
    } else {
      if (!reqNewline) {
        const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
        reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
      }
      if (reqNewline) {
        let str = start2;
        for (const line of lines)
          str += line ? `
${indentStep}${indent}${line}` : "\n";
        return `${str}
${indent}${end2}`;
      } else {
        return `${start2}${fcPadding}${lines.join(" ")}${fcPadding}${end2}`;
      }
    }
  }
  function addCommentBefore({ indent, options: { commentString } }, lines, comment2, chompKeep) {
    if (comment2 && chompKeep)
      comment2 = comment2.replace(/^\n+/, "");
    if (comment2) {
      const ic = indentComment(commentString(comment2), indent);
      lines.push(ic.trimStart());
    }
  }

  // node_modules/yaml/browser/dist/nodes/YAMLMap.js
  function findPair(items, key) {
    const k = isScalar(key) ? key.value : key;
    for (const it2 of items) {
      if (isPair(it2)) {
        if (it2.key === key || it2.key === k)
          return it2;
        if (isScalar(it2.key) && it2.key.value === k)
          return it2;
      }
    }
    return void 0;
  }
  var YAMLMap = class extends Collection {
    static get tagName() {
      return "tag:yaml.org,2002:map";
    }
    constructor(schema4) {
      super(MAP, schema4);
      this.items = [];
    }
    /**
     * A generic collection parsing method that can be extended
     * to other node classes that inherit from YAMLMap
     */
    static from(schema4, obj, ctx) {
      const { keepUndefined, replacer } = ctx;
      const map4 = new this(schema4);
      const add3 = (key, value) => {
        if (typeof replacer === "function")
          value = replacer.call(obj, key, value);
        else if (Array.isArray(replacer) && !replacer.includes(key))
          return;
        if (value !== void 0 || keepUndefined)
          map4.items.push(createPair(key, value, ctx));
      };
      if (obj instanceof Map) {
        for (const [key, value] of obj)
          add3(key, value);
      } else if (obj && typeof obj === "object") {
        for (const key of Object.keys(obj))
          add3(key, obj[key]);
      }
      if (typeof schema4.sortMapEntries === "function") {
        map4.items.sort(schema4.sortMapEntries);
      }
      return map4;
    }
    /**
     * Adds a value to the collection.
     *
     * @param overwrite - If not set `true`, using a key that is already in the
     *   collection will throw. Otherwise, overwrites the previous value.
     */
    add(pair, overwrite) {
      let _pair;
      if (isPair(pair))
        _pair = pair;
      else if (!pair || typeof pair !== "object" || !("key" in pair)) {
        _pair = new Pair(pair, pair?.value);
      } else
        _pair = new Pair(pair.key, pair.value);
      const prev2 = findPair(this.items, _pair.key);
      const sortEntries = this.schema?.sortMapEntries;
      if (prev2) {
        if (!overwrite)
          throw new Error(`Key ${_pair.key} already set`);
        if (isScalar(prev2.value) && isScalarValue(_pair.value))
          prev2.value.value = _pair.value;
        else
          prev2.value = _pair.value;
      } else if (sortEntries) {
        const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
        if (i === -1)
          this.items.push(_pair);
        else
          this.items.splice(i, 0, _pair);
      } else {
        this.items.push(_pair);
      }
    }
    delete(key) {
      const it2 = findPair(this.items, key);
      if (!it2)
        return false;
      const del = this.items.splice(this.items.indexOf(it2), 1);
      return del.length > 0;
    }
    get(key, keepScalar) {
      const it2 = findPair(this.items, key);
      const node = it2?.value;
      return (!keepScalar && isScalar(node) ? node.value : node) ?? void 0;
    }
    has(key) {
      return !!findPair(this.items, key);
    }
    set(key, value) {
      this.add(new Pair(key, value), true);
    }
    /**
     * @param ctx - Conversion context, originally set in Document#toJS()
     * @param {Class} Type - If set, forces the returned collection type
     * @returns Instance of Type, Map, or Object
     */
    toJSON(_2, ctx, Type) {
      const map4 = Type ? new Type() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
      if (ctx?.onCreate)
        ctx.onCreate(map4);
      for (const item of this.items)
        addPairToJSMap(ctx, map4, item);
      return map4;
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      for (const item of this.items) {
        if (!isPair(item))
          throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
      }
      if (!ctx.allNullValues && this.hasAllNullValues(false))
        ctx = Object.assign({}, ctx, { allNullValues: true });
      return stringifyCollection(this, ctx, {
        blockItemPrefix: "",
        flowChars: { start: "{", end: "}" },
        itemIndent: ctx.indent || "",
        onChompKeep,
        onComment
      });
    }
  };

  // node_modules/yaml/browser/dist/schema/common/map.js
  var map3 = {
    collection: "map",
    default: true,
    nodeClass: YAMLMap,
    tag: "tag:yaml.org,2002:map",
    resolve(map4, onError) {
      if (!isMap(map4))
        onError("Expected a mapping for this tag");
      return map4;
    },
    createNode: (schema4, obj, ctx) => YAMLMap.from(schema4, obj, ctx)
  };

  // node_modules/yaml/browser/dist/nodes/YAMLSeq.js
  var YAMLSeq = class extends Collection {
    static get tagName() {
      return "tag:yaml.org,2002:seq";
    }
    constructor(schema4) {
      super(SEQ, schema4);
      this.items = [];
    }
    add(value) {
      this.items.push(value);
    }
    /**
     * Removes a value from the collection.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     *
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        return false;
      const del = this.items.splice(idx, 1);
      return del.length > 0;
    }
    get(key, keepScalar) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        return void 0;
      const it2 = this.items[idx];
      return !keepScalar && isScalar(it2) ? it2.value : it2;
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     */
    has(key) {
      const idx = asItemIndex(key);
      return typeof idx === "number" && idx < this.items.length;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     *
     * If `key` does not contain a representation of an integer, this will throw.
     * It may be wrapped in a `Scalar`.
     */
    set(key, value) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        throw new Error(`Expected a valid index, not ${key}.`);
      const prev2 = this.items[idx];
      if (isScalar(prev2) && isScalarValue(value))
        prev2.value = value;
      else
        this.items[idx] = value;
    }
    toJSON(_2, ctx) {
      const seq2 = [];
      if (ctx?.onCreate)
        ctx.onCreate(seq2);
      let i = 0;
      for (const item of this.items)
        seq2.push(toJS(item, String(i++), ctx));
      return seq2;
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      return stringifyCollection(this, ctx, {
        blockItemPrefix: "- ",
        flowChars: { start: "[", end: "]" },
        itemIndent: (ctx.indent || "") + "  ",
        onChompKeep,
        onComment
      });
    }
    static from(schema4, obj, ctx) {
      const { replacer } = ctx;
      const seq2 = new this(schema4);
      if (obj && Symbol.iterator in Object(obj)) {
        let i = 0;
        for (let it2 of obj) {
          if (typeof replacer === "function") {
            const key = obj instanceof Set ? it2 : String(i++);
            it2 = replacer.call(obj, key, it2);
          }
          seq2.items.push(createNode(it2, void 0, ctx));
        }
      }
      return seq2;
    }
  };
  function asItemIndex(key) {
    let idx = isScalar(key) ? key.value : key;
    if (idx && typeof idx === "string")
      idx = Number(idx);
    return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
  }

  // node_modules/yaml/browser/dist/schema/common/seq.js
  var seq = {
    collection: "seq",
    default: true,
    nodeClass: YAMLSeq,
    tag: "tag:yaml.org,2002:seq",
    resolve(seq2, onError) {
      if (!isSeq(seq2))
        onError("Expected a sequence for this tag");
      return seq2;
    },
    createNode: (schema4, obj, ctx) => YAMLSeq.from(schema4, obj, ctx)
  };

  // node_modules/yaml/browser/dist/schema/common/string.js
  var string = {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify(item, ctx, onComment, onChompKeep) {
      ctx = Object.assign({ actualString: true }, ctx);
      return stringifyString(item, ctx, onComment, onChompKeep);
    }
  };

  // node_modules/yaml/browser/dist/schema/common/null.js
  var nullTag = {
    identify: (value) => value == null,
    createNode: () => new Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^(?:~|[Nn]ull|NULL)?$/,
    resolve: () => new Scalar(null),
    stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
  };

  // node_modules/yaml/browser/dist/schema/core/bool.js
  var boolTag = {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
    resolve: (str) => new Scalar(str[0] === "t" || str[0] === "T"),
    stringify({ source, value }, ctx) {
      if (source && boolTag.test.test(source)) {
        const sv = source[0] === "t" || source[0] === "T";
        if (value === sv)
          return source;
      }
      return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
  };

  // node_modules/yaml/browser/dist/stringify/stringifyNumber.js
  function stringifyNumber({ format: format2, minFractionDigits, tag, value }) {
    if (typeof value === "bigint")
      return String(value);
    const num = typeof value === "number" ? value : Number(value);
    if (!isFinite(num))
      return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
    let n = Object.is(value, -0) ? "-0" : JSON.stringify(value);
    if (!format2 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
      let i = n.indexOf(".");
      if (i < 0) {
        i = n.length;
        n += ".";
      }
      let d = minFractionDigits - (n.length - i - 1);
      while (d-- > 0)
        n += "0";
    }
    return n;
  }

  // node_modules/yaml/browser/dist/schema/core/float.js
  var floatNaN = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber
  };
  var floatExp = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str),
    stringify(node) {
      const num = Number(node.value);
      return isFinite(num) ? num.toExponential() : stringifyNumber(node);
    }
  };
  var float = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
    resolve(str) {
      const node = new Scalar(parseFloat(str));
      const dot = str.indexOf(".");
      if (dot !== -1 && str[str.length - 1] === "0")
        node.minFractionDigits = str.length - dot - 1;
      return node;
    },
    stringify: stringifyNumber
  };

  // node_modules/yaml/browser/dist/schema/core/int.js
  var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
  var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
  function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value) && value >= 0)
      return prefix + value.toString(radix);
    return stringifyNumber(node);
  }
  var intOct = {
    identify: (value) => intIdentify(value) && value >= 0,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^0o[0-7]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
    stringify: (node) => intStringify(node, 8, "0o")
  };
  var int = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber
  };
  var intHex = {
    identify: (value) => intIdentify(value) && value >= 0,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^0x[0-9a-fA-F]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: (node) => intStringify(node, 16, "0x")
  };

  // node_modules/yaml/browser/dist/schema/core/schema.js
  var schema = [
    map3,
    seq,
    string,
    nullTag,
    boolTag,
    intOct,
    int,
    intHex,
    floatNaN,
    floatExp,
    float
  ];

  // node_modules/yaml/browser/dist/schema/json/schema.js
  function intIdentify2(value) {
    return typeof value === "bigint" || Number.isInteger(value);
  }
  var stringifyJSON = ({ value }) => JSON.stringify(value);
  var jsonScalars = [
    {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify: stringifyJSON
    },
    {
      identify: (value) => value == null,
      createNode: () => new Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^null$/,
      resolve: () => null,
      stringify: stringifyJSON
    },
    {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^true$|^false$/,
      resolve: (str) => str === "true",
      stringify: stringifyJSON
    },
    {
      identify: intIdentify2,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^-?(?:0|[1-9][0-9]*)$/,
      resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
      stringify: ({ value }) => intIdentify2(value) ? value.toString() : JSON.stringify(value)
    },
    {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
      resolve: (str) => parseFloat(str),
      stringify: stringifyJSON
    }
  ];
  var jsonError = {
    default: true,
    tag: "",
    test: /^/,
    resolve(str, onError) {
      onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
      return str;
    }
  };
  var schema2 = [map3, seq].concat(jsonScalars, jsonError);

  // node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js
  var binary = {
    identify: (value) => value instanceof Uint8Array,
    // Buffer inherits from Uint8Array
    default: false,
    tag: "tag:yaml.org,2002:binary",
    /**
     * Returns a Buffer in node and an Uint8Array in browsers
     *
     * To use the resulting buffer as an image, you'll want to do something like:
     *
     *   const blob = new Blob([buffer], { type: 'image/jpeg' })
     *   document.querySelector('#photo').src = URL.createObjectURL(blob)
     */
    resolve(src, onError) {
      if (typeof atob === "function") {
        const str = atob(src.replace(/[\n\r]/g, ""));
        const buffer = new Uint8Array(str.length);
        for (let i = 0; i < str.length; ++i)
          buffer[i] = str.charCodeAt(i);
        return buffer;
      } else {
        onError("This environment does not support reading binary tags; either Buffer or atob is required");
        return src;
      }
    },
    stringify({ comment: comment2, type: type2, value }, ctx, onComment, onChompKeep) {
      if (!value)
        return "";
      const buf = value;
      let str;
      if (typeof btoa === "function") {
        let s = "";
        for (let i = 0; i < buf.length; ++i)
          s += String.fromCharCode(buf[i]);
        str = btoa(s);
      } else {
        throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
      }
      type2 ?? (type2 = Scalar.BLOCK_LITERAL);
      if (type2 !== Scalar.QUOTE_DOUBLE) {
        const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
        const n = Math.ceil(str.length / lineWidth);
        const lines = new Array(n);
        for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
          lines[i] = str.substr(o, lineWidth);
        }
        str = lines.join(type2 === Scalar.BLOCK_LITERAL ? "\n" : " ");
      }
      return stringifyString({ comment: comment2, type: type2, value: str }, ctx, onComment, onChompKeep);
    }
  };

  // node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js
  function resolvePairs(seq2, onError) {
    if (isSeq(seq2)) {
      for (let i = 0; i < seq2.items.length; ++i) {
        let item = seq2.items[i];
        if (isPair(item))
          continue;
        else if (isMap(item)) {
          if (item.items.length > 1)
            onError("Each pair must have its own sequence indicator");
          const pair = item.items[0] || new Pair(new Scalar(null));
          if (item.commentBefore)
            pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
          if (item.comment) {
            const cn = pair.value ?? pair.key;
            cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
          }
          item = pair;
        }
        seq2.items[i] = isPair(item) ? item : new Pair(item);
      }
    } else
      onError("Expected a sequence for this tag");
    return seq2;
  }
  function createPairs(schema4, iterable, ctx) {
    const { replacer } = ctx;
    const pairs2 = new YAMLSeq(schema4);
    pairs2.tag = "tag:yaml.org,2002:pairs";
    let i = 0;
    if (iterable && Symbol.iterator in Object(iterable))
      for (let it2 of iterable) {
        if (typeof replacer === "function")
          it2 = replacer.call(iterable, String(i++), it2);
        let key, value;
        if (Array.isArray(it2)) {
          if (it2.length === 2) {
            key = it2[0];
            value = it2[1];
          } else
            throw new TypeError(`Expected [key, value] tuple: ${it2}`);
        } else if (it2 && it2 instanceof Object) {
          const keys = Object.keys(it2);
          if (keys.length === 1) {
            key = keys[0];
            value = it2[key];
          } else {
            throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
          }
        } else {
          key = it2;
        }
        pairs2.items.push(createPair(key, value, ctx));
      }
    return pairs2;
  }
  var pairs = {
    collection: "seq",
    default: false,
    tag: "tag:yaml.org,2002:pairs",
    resolve: resolvePairs,
    createNode: createPairs
  };

  // node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js
  var YAMLOMap = class _YAMLOMap extends YAMLSeq {
    constructor() {
      super();
      this.add = YAMLMap.prototype.add.bind(this);
      this.delete = YAMLMap.prototype.delete.bind(this);
      this.get = YAMLMap.prototype.get.bind(this);
      this.has = YAMLMap.prototype.has.bind(this);
      this.set = YAMLMap.prototype.set.bind(this);
      this.tag = _YAMLOMap.tag;
    }
    /**
     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
     * but TypeScript won't allow widening the signature of a child method.
     */
    toJSON(_2, ctx) {
      if (!ctx)
        return super.toJSON(_2);
      const map4 = /* @__PURE__ */ new Map();
      if (ctx?.onCreate)
        ctx.onCreate(map4);
      for (const pair of this.items) {
        let key, value;
        if (isPair(pair)) {
          key = toJS(pair.key, "", ctx);
          value = toJS(pair.value, key, ctx);
        } else {
          key = toJS(pair, "", ctx);
        }
        if (map4.has(key))
          throw new Error("Ordered maps must not include duplicate keys");
        map4.set(key, value);
      }
      return map4;
    }
    static from(schema4, iterable, ctx) {
      const pairs2 = createPairs(schema4, iterable, ctx);
      const omap2 = new this();
      omap2.items = pairs2.items;
      return omap2;
    }
  };
  YAMLOMap.tag = "tag:yaml.org,2002:omap";
  var omap = {
    collection: "seq",
    identify: (value) => value instanceof Map,
    nodeClass: YAMLOMap,
    default: false,
    tag: "tag:yaml.org,2002:omap",
    resolve(seq2, onError) {
      const pairs2 = resolvePairs(seq2, onError);
      const seenKeys = [];
      for (const { key } of pairs2.items) {
        if (isScalar(key)) {
          if (seenKeys.includes(key.value)) {
            onError(`Ordered maps must not include duplicate keys: ${key.value}`);
          } else {
            seenKeys.push(key.value);
          }
        }
      }
      return Object.assign(new YAMLOMap(), pairs2);
    },
    createNode: (schema4, iterable, ctx) => YAMLOMap.from(schema4, iterable, ctx)
  };

  // node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js
  function boolStringify({ value, source }, ctx) {
    const boolObj = value ? trueTag : falseTag;
    if (source && boolObj.test.test(source))
      return source;
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
  var trueTag = {
    identify: (value) => value === true,
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
    resolve: () => new Scalar(true),
    stringify: boolStringify
  };
  var falseTag = {
    identify: (value) => value === false,
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
    resolve: () => new Scalar(false),
    stringify: boolStringify
  };

  // node_modules/yaml/browser/dist/schema/yaml-1.1/float.js
  var floatNaN2 = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber
  };
  var floatExp2 = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str.replace(/_/g, "")),
    stringify(node) {
      const num = Number(node.value);
      return isFinite(num) ? num.toExponential() : stringifyNumber(node);
    }
  };
  var float2 = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
    resolve(str) {
      const node = new Scalar(parseFloat(str.replace(/_/g, "")));
      const dot = str.indexOf(".");
      if (dot !== -1) {
        const f = str.substring(dot + 1).replace(/_/g, "");
        if (f[f.length - 1] === "0")
          node.minFractionDigits = f.length;
      }
      return node;
    },
    stringify: stringifyNumber
  };

  // node_modules/yaml/browser/dist/schema/yaml-1.1/int.js
  var intIdentify3 = (value) => typeof value === "bigint" || Number.isInteger(value);
  function intResolve2(str, offset, radix, { intAsBigInt }) {
    const sign = str[0];
    if (sign === "-" || sign === "+")
      offset += 1;
    str = str.substring(offset).replace(/_/g, "");
    if (intAsBigInt) {
      switch (radix) {
        case 2:
          str = `0b${str}`;
          break;
        case 8:
          str = `0o${str}`;
          break;
        case 16:
          str = `0x${str}`;
          break;
      }
      const n2 = BigInt(str);
      return sign === "-" ? BigInt(-1) * n2 : n2;
    }
    const n = parseInt(str, radix);
    return sign === "-" ? -1 * n : n;
  }
  function intStringify2(node, radix, prefix) {
    const { value } = node;
    if (intIdentify3(value)) {
      const str = value.toString(radix);
      return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
    }
    return stringifyNumber(node);
  }
  var intBin = {
    identify: intIdentify3,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "BIN",
    test: /^[-+]?0b[0-1_]+$/,
    resolve: (str, _onError, opt) => intResolve2(str, 2, 2, opt),
    stringify: (node) => intStringify2(node, 2, "0b")
  };
  var intOct2 = {
    identify: intIdentify3,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^[-+]?0[0-7_]+$/,
    resolve: (str, _onError, opt) => intResolve2(str, 1, 8, opt),
    stringify: (node) => intStringify2(node, 8, "0")
  };
  var int2 = {
    identify: intIdentify3,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9][0-9_]*$/,
    resolve: (str, _onError, opt) => intResolve2(str, 0, 10, opt),
    stringify: stringifyNumber
  };
  var intHex2 = {
    identify: intIdentify3,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^[-+]?0x[0-9a-fA-F_]+$/,
    resolve: (str, _onError, opt) => intResolve2(str, 2, 16, opt),
    stringify: (node) => intStringify2(node, 16, "0x")
  };

  // node_modules/yaml/browser/dist/schema/yaml-1.1/set.js
  var YAMLSet = class _YAMLSet extends YAMLMap {
    constructor(schema4) {
      super(schema4);
      this.tag = _YAMLSet.tag;
    }
    add(key) {
      let pair;
      if (isPair(key))
        pair = key;
      else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
        pair = new Pair(key.key, null);
      else
        pair = new Pair(key, null);
      const prev2 = findPair(this.items, pair.key);
      if (!prev2)
        this.items.push(pair);
    }
    /**
     * If `keepPair` is `true`, returns the Pair matching `key`.
     * Otherwise, returns the value of that Pair's key.
     */
    get(key, keepPair) {
      const pair = findPair(this.items, key);
      return !keepPair && isPair(pair) ? isScalar(pair.key) ? pair.key.value : pair.key : pair;
    }
    set(key, value) {
      if (typeof value !== "boolean")
        throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
      const prev2 = findPair(this.items, key);
      if (prev2 && !value) {
        this.items.splice(this.items.indexOf(prev2), 1);
      } else if (!prev2 && value) {
        this.items.push(new Pair(key));
      }
    }
    toJSON(_2, ctx) {
      return super.toJSON(_2, ctx, Set);
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      if (this.hasAllNullValues(true))
        return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
      else
        throw new Error("Set items must all have null values");
    }
    static from(schema4, iterable, ctx) {
      const { replacer } = ctx;
      const set5 = new this(schema4);
      if (iterable && Symbol.iterator in Object(iterable))
        for (let value of iterable) {
          if (typeof replacer === "function")
            value = replacer.call(iterable, value, value);
          set5.items.push(createPair(value, null, ctx));
        }
      return set5;
    }
  };
  YAMLSet.tag = "tag:yaml.org,2002:set";
  var set2 = {
    collection: "map",
    identify: (value) => value instanceof Set,
    nodeClass: YAMLSet,
    default: false,
    tag: "tag:yaml.org,2002:set",
    createNode: (schema4, iterable, ctx) => YAMLSet.from(schema4, iterable, ctx),
    resolve(map4, onError) {
      if (isMap(map4)) {
        if (map4.hasAllNullValues(true))
          return Object.assign(new YAMLSet(), map4);
        else
          onError("Set items must all have null values");
      } else
        onError("Expected a mapping for this tag");
      return map4;
    }
  };

  // node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js
  function parseSexagesimal(str, asBigInt) {
    const sign = str[0];
    const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
    const num = (n) => asBigInt ? BigInt(n) : Number(n);
    const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
    return sign === "-" ? num(-1) * res : res;
  }
  function stringifySexagesimal(node) {
    let { value } = node;
    let num = (n) => n;
    if (typeof value === "bigint")
      num = (n) => BigInt(n);
    else if (isNaN(value) || !isFinite(value))
      return stringifyNumber(node);
    let sign = "";
    if (value < 0) {
      sign = "-";
      value *= num(-1);
    }
    const _60 = num(60);
    const parts = [value % _60];
    if (value < 60) {
      parts.unshift(0);
    } else {
      value = (value - parts[0]) / _60;
      parts.unshift(value % _60);
      if (value >= 60) {
        value = (value - parts[0]) / _60;
        parts.unshift(value);
      }
    }
    return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
  }
  var intTime = {
    identify: (value) => typeof value === "bigint" || Number.isInteger(value),
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
    stringify: stringifySexagesimal
  };
  var floatTime = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
    resolve: (str) => parseSexagesimal(str, false),
    stringify: stringifySexagesimal
  };
  var timestamp = {
    identify: (value) => value instanceof Date,
    default: true,
    tag: "tag:yaml.org,2002:timestamp",
    // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
    // may be omitted altogether, resulting in a date format. In such a case, the time part is
    // assumed to be 00:00:00Z (start of day, UTC).
    test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
    resolve(str) {
      const match2 = str.match(timestamp.test);
      if (!match2)
        throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
      const [, year, month, day, hour, minute, second] = match2.map(Number);
      const millisec = match2[7] ? Number((match2[7] + "00").substr(1, 3)) : 0;
      let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
      const tz = match2[8];
      if (tz && tz !== "Z") {
        let d = parseSexagesimal(tz, false);
        if (Math.abs(d) < 30)
          d *= 60;
        date -= 6e4 * d;
      }
      return new Date(date);
    },
    stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? ""
  };

  // node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js
  var schema3 = [
    map3,
    seq,
    string,
    nullTag,
    trueTag,
    falseTag,
    intBin,
    intOct2,
    int2,
    intHex2,
    floatNaN2,
    floatExp2,
    float2,
    binary,
    merge2,
    omap,
    pairs,
    set2,
    intTime,
    floatTime,
    timestamp
  ];

  // node_modules/yaml/browser/dist/schema/tags.js
  var schemas = /* @__PURE__ */ new Map([
    ["core", schema],
    ["failsafe", [map3, seq, string]],
    ["json", schema2],
    ["yaml11", schema3],
    ["yaml-1.1", schema3]
  ]);
  var tagsByName = {
    binary,
    bool: boolTag,
    float,
    floatExp,
    floatNaN,
    floatTime,
    int,
    intHex,
    intOct,
    intTime,
    map: map3,
    merge: merge2,
    null: nullTag,
    omap,
    pairs,
    seq,
    set: set2,
    timestamp
  };
  var coreKnownTags = {
    "tag:yaml.org,2002:binary": binary,
    "tag:yaml.org,2002:merge": merge2,
    "tag:yaml.org,2002:omap": omap,
    "tag:yaml.org,2002:pairs": pairs,
    "tag:yaml.org,2002:set": set2,
    "tag:yaml.org,2002:timestamp": timestamp
  };
  function getTags(customTags, schemaName, addMergeTag) {
    const schemaTags = schemas.get(schemaName);
    if (schemaTags && !customTags) {
      return addMergeTag && !schemaTags.includes(merge2) ? schemaTags.concat(merge2) : schemaTags.slice();
    }
    let tags = schemaTags;
    if (!tags) {
      if (Array.isArray(customTags))
        tags = [];
      else {
        const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
      }
    }
    if (Array.isArray(customTags)) {
      for (const tag of customTags)
        tags = tags.concat(tag);
    } else if (typeof customTags === "function") {
      tags = customTags(tags.slice());
    }
    if (addMergeTag)
      tags = tags.concat(merge2);
    return tags.reduce((tags2, tag) => {
      const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
      if (!tagObj) {
        const tagName = JSON.stringify(tag);
        const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
      }
      if (!tags2.includes(tagObj))
        tags2.push(tagObj);
      return tags2;
    }, []);
  }

  // node_modules/yaml/browser/dist/schema/Schema.js
  var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
  var Schema = class _Schema {
    constructor({ compat, customTags, merge: merge3, resolveKnownTags, schema: schema4, sortMapEntries, toStringDefaults }) {
      this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
      this.name = typeof schema4 === "string" && schema4 || "core";
      this.knownTags = resolveKnownTags ? coreKnownTags : {};
      this.tags = getTags(customTags, this.name, merge3);
      this.toStringOptions = toStringDefaults ?? null;
      Object.defineProperty(this, MAP, { value: map3 });
      Object.defineProperty(this, SCALAR, { value: string });
      Object.defineProperty(this, SEQ, { value: seq });
      this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
    }
    clone() {
      const copy = Object.create(_Schema.prototype, Object.getOwnPropertyDescriptors(this));
      copy.tags = this.tags.slice();
      return copy;
    }
  };

  // node_modules/yaml/browser/dist/stringify/stringifyDocument.js
  function stringifyDocument(doc, options) {
    const lines = [];
    let hasDirectives = options.directives === true;
    if (options.directives !== false && doc.directives) {
      const dir = doc.directives.toString(doc);
      if (dir) {
        lines.push(dir);
        hasDirectives = true;
      } else if (doc.directives.docStart)
        hasDirectives = true;
    }
    if (hasDirectives)
      lines.push("---");
    const ctx = createStringifyContext(doc, options);
    const { commentString } = ctx.options;
    if (doc.commentBefore) {
      if (lines.length !== 1)
        lines.unshift("");
      const cs = commentString(doc.commentBefore);
      lines.unshift(indentComment(cs, ""));
    }
    let chompKeep = false;
    let contentComment = null;
    if (doc.contents) {
      if (isNode2(doc.contents)) {
        if (doc.contents.spaceBefore && hasDirectives)
          lines.push("");
        if (doc.contents.commentBefore) {
          const cs = commentString(doc.contents.commentBefore);
          lines.push(indentComment(cs, ""));
        }
        ctx.forceBlockIndent = !!doc.comment;
        contentComment = doc.contents.comment;
      }
      const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
      let body = stringify2(doc.contents, ctx, () => contentComment = null, onChompKeep);
      if (contentComment)
        body += lineComment(body, "", commentString(contentComment));
      if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
        lines[lines.length - 1] = `--- ${body}`;
      } else
        lines.push(body);
    } else {
      lines.push(stringify2(doc.contents, ctx));
    }
    if (doc.directives?.docEnd) {
      if (doc.comment) {
        const cs = commentString(doc.comment);
        if (cs.includes("\n")) {
          lines.push("...");
          lines.push(indentComment(cs, ""));
        } else {
          lines.push(`... ${cs}`);
        }
      } else {
        lines.push("...");
      }
    } else {
      let dc = doc.comment;
      if (dc && chompKeep)
        dc = dc.replace(/^\n+/, "");
      if (dc) {
        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
          lines.push("");
        lines.push(indentComment(commentString(dc), ""));
      }
    }
    return lines.join("\n") + "\n";
  }

  // node_modules/yaml/browser/dist/doc/Document.js
  var Document2 = class _Document {
    constructor(value, replacer, options) {
      this.commentBefore = null;
      this.comment = null;
      this.errors = [];
      this.warnings = [];
      Object.defineProperty(this, NODE_TYPE, { value: DOC });
      let _replacer = null;
      if (typeof replacer === "function" || Array.isArray(replacer)) {
        _replacer = replacer;
      } else if (options === void 0 && replacer) {
        options = replacer;
        replacer = void 0;
      }
      const opt = Object.assign({
        intAsBigInt: false,
        keepSourceTokens: false,
        logLevel: "warn",
        prettyErrors: true,
        strict: true,
        stringKeys: false,
        uniqueKeys: true,
        version: "1.2"
      }, options);
      this.options = opt;
      let { version } = opt;
      if (options?._directives) {
        this.directives = options._directives.atDocument();
        if (this.directives.yaml.explicit)
          version = this.directives.yaml.version;
      } else
        this.directives = new Directives({ version });
      this.setSchema(version, options);
      this.contents = value === void 0 ? null : this.createNode(value, _replacer, options);
    }
    /**
     * Create a deep copy of this Document and its contents.
     *
     * Custom Node values that inherit from `Object` still refer to their original instances.
     */
    clone() {
      const copy = Object.create(_Document.prototype, {
        [NODE_TYPE]: { value: DOC }
      });
      copy.commentBefore = this.commentBefore;
      copy.comment = this.comment;
      copy.errors = this.errors.slice();
      copy.warnings = this.warnings.slice();
      copy.options = Object.assign({}, this.options);
      if (this.directives)
        copy.directives = this.directives.clone();
      copy.schema = this.schema.clone();
      copy.contents = isNode2(this.contents) ? this.contents.clone(copy.schema) : this.contents;
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    /** Adds a value to the document. */
    add(value) {
      if (assertCollection(this.contents))
        this.contents.add(value);
    }
    /** Adds a value to the document. */
    addIn(path2, value) {
      if (assertCollection(this.contents))
        this.contents.addIn(path2, value);
    }
    /**
     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
     *
     * If `node` already has an anchor, `name` is ignored.
     * Otherwise, the `node.anchor` value will be set to `name`,
     * or if an anchor with that name is already present in the document,
     * `name` will be used as a prefix for a new unique anchor.
     * If `name` is undefined, the generated anchor will use 'a' as a prefix.
     */
    createAlias(node, name2) {
      if (!node.anchor) {
        const prev2 = anchorNames(this);
        node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        !name2 || prev2.has(name2) ? findNewAnchor(name2 || "a", prev2) : name2;
      }
      return new Alias(node.anchor);
    }
    createNode(value, replacer, options) {
      let _replacer = void 0;
      if (typeof replacer === "function") {
        value = replacer.call({ "": value }, "", value);
        _replacer = replacer;
      } else if (Array.isArray(replacer)) {
        const keyToStr = (v2) => typeof v2 === "number" || v2 instanceof String || v2 instanceof Number;
        const asStr = replacer.filter(keyToStr).map(String);
        if (asStr.length > 0)
          replacer = replacer.concat(asStr);
        _replacer = replacer;
      } else if (options === void 0 && replacer) {
        options = replacer;
        replacer = void 0;
      }
      const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
      const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(
        this,
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        anchorPrefix || "a"
      );
      const ctx = {
        aliasDuplicateObjects: aliasDuplicateObjects ?? true,
        keepUndefined: keepUndefined ?? false,
        onAnchor,
        onTagObj,
        replacer: _replacer,
        schema: this.schema,
        sourceObjects
      };
      const node = createNode(value, tag, ctx);
      if (flow && isCollection(node))
        node.flow = true;
      setAnchors();
      return node;
    }
    /**
     * Convert a key and a value into a `Pair` using the current schema,
     * recursively wrapping all values as `Scalar` or `Collection` nodes.
     */
    createPair(key, value, options = {}) {
      const k = this.createNode(key, null, options);
      const v2 = this.createNode(value, null, options);
      return new Pair(k, v2);
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
      return assertCollection(this.contents) ? this.contents.delete(key) : false;
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    deleteIn(path2) {
      if (isEmptyPath(path2)) {
        if (this.contents == null)
          return false;
        this.contents = null;
        return true;
      }
      return assertCollection(this.contents) ? this.contents.deleteIn(path2) : false;
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    get(key, keepScalar) {
      return isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
    }
    /**
     * Returns item at `path`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    getIn(path2, keepScalar) {
      if (isEmptyPath(path2))
        return !keepScalar && isScalar(this.contents) ? this.contents.value : this.contents;
      return isCollection(this.contents) ? this.contents.getIn(path2, keepScalar) : void 0;
    }
    /**
     * Checks if the document includes a value with the key `key`.
     */
    has(key) {
      return isCollection(this.contents) ? this.contents.has(key) : false;
    }
    /**
     * Checks if the document includes a value at `path`.
     */
    hasIn(path2) {
      if (isEmptyPath(path2))
        return this.contents !== void 0;
      return isCollection(this.contents) ? this.contents.hasIn(path2) : false;
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    set(key, value) {
      if (this.contents == null) {
        this.contents = collectionFromPath(this.schema, [key], value);
      } else if (assertCollection(this.contents)) {
        this.contents.set(key, value);
      }
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    setIn(path2, value) {
      if (isEmptyPath(path2)) {
        this.contents = value;
      } else if (this.contents == null) {
        this.contents = collectionFromPath(this.schema, Array.from(path2), value);
      } else if (assertCollection(this.contents)) {
        this.contents.setIn(path2, value);
      }
    }
    /**
     * Change the YAML version and schema used by the document.
     * A `null` version disables support for directives, explicit tags, anchors, and aliases.
     * It also requires the `schema` option to be given as a `Schema` instance value.
     *
     * Overrides all previously set schema options.
     */
    setSchema(version, options = {}) {
      if (typeof version === "number")
        version = String(version);
      let opt;
      switch (version) {
        case "1.1":
          if (this.directives)
            this.directives.yaml.version = "1.1";
          else
            this.directives = new Directives({ version: "1.1" });
          opt = { resolveKnownTags: false, schema: "yaml-1.1" };
          break;
        case "1.2":
        case "next":
          if (this.directives)
            this.directives.yaml.version = version;
          else
            this.directives = new Directives({ version });
          opt = { resolveKnownTags: true, schema: "core" };
          break;
        case null:
          if (this.directives)
            delete this.directives;
          opt = null;
          break;
        default: {
          const sv = JSON.stringify(version);
          throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
        }
      }
      if (options.schema instanceof Object)
        this.schema = options.schema;
      else if (opt)
        this.schema = new Schema(Object.assign(opt, options));
      else
        throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
    }
    // json & jsonArg are only used from toJSON()
    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
      const ctx = {
        anchors: /* @__PURE__ */ new Map(),
        doc: this,
        keep: !json,
        mapAsMap: mapAsMap === true,
        mapKeyWarned: false,
        maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
      };
      const res = toJS(this.contents, jsonArg ?? "", ctx);
      if (typeof onAnchor === "function")
        for (const { count, res: res2 } of ctx.anchors.values())
          onAnchor(res2, count);
      return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
    }
    /**
     * A JSON representation of the document `contents`.
     *
     * @param jsonArg Used by `JSON.stringify` to indicate the array index or
     *   property name.
     */
    toJSON(jsonArg, onAnchor) {
      return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
    }
    /** A YAML representation of the document. */
    toString(options = {}) {
      if (this.errors.length > 0)
        throw new Error("Document with errors cannot be stringified");
      if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
        const s = JSON.stringify(options.indent);
        throw new Error(`"indent" option must be a positive integer, not ${s}`);
      }
      return stringifyDocument(this, options);
    }
  };
  function assertCollection(contents2) {
    if (isCollection(contents2))
      return true;
    throw new Error("Expected a YAML collection as document contents");
  }

  // node_modules/yaml/browser/dist/errors.js
  var YAMLError = class extends Error {
    constructor(name2, pos, code2, message) {
      super();
      this.name = name2;
      this.code = code2;
      this.message = message;
      this.pos = pos;
    }
  };
  var YAMLParseError = class extends YAMLError {
    constructor(pos, code2, message) {
      super("YAMLParseError", pos, code2, message);
    }
  };
  var YAMLWarning = class extends YAMLError {
    constructor(pos, code2, message) {
      super("YAMLWarning", pos, code2, message);
    }
  };
  var prettifyError = (src, lc) => (error2) => {
    if (error2.pos[0] === -1)
      return;
    error2.linePos = error2.pos.map((pos) => lc.linePos(pos));
    const { line, col } = error2.linePos[0];
    error2.message += ` at line ${line}, column ${col}`;
    let ci = col - 1;
    let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
    if (ci >= 60 && lineStr.length > 80) {
      const trimStart = Math.min(ci - 39, lineStr.length - 79);
      lineStr = "\u2026" + lineStr.substring(trimStart);
      ci -= trimStart - 1;
    }
    if (lineStr.length > 80)
      lineStr = lineStr.substring(0, 79) + "\u2026";
    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
      let prev2 = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
      if (prev2.length > 80)
        prev2 = prev2.substring(0, 79) + "\u2026\n";
      lineStr = prev2 + lineStr;
    }
    if (/[^ ]/.test(lineStr)) {
      let count = 1;
      const end2 = error2.linePos[1];
      if (end2?.line === line && end2.col > col) {
        count = Math.max(1, Math.min(end2.col - col, 80 - ci));
      }
      const pointer = " ".repeat(ci) + "^".repeat(count);
      error2.message += `:

${lineStr}
${pointer}
`;
    }
  };

  // node_modules/yaml/browser/dist/compose/resolve-props.js
  function resolveProps(tokens, { flow, indicator, next: next2, offset, onError, parentIndent, startOnNewline }) {
    let spaceBefore = false;
    let atNewline = startOnNewline;
    let hasSpace = startOnNewline;
    let comment2 = "";
    let commentSep = "";
    let hasNewline = false;
    let reqSpace = false;
    let tab = null;
    let anchor = null;
    let tag = null;
    let newlineAfterProp = null;
    let comma = null;
    let found = null;
    let start2 = null;
    for (const token of tokens) {
      if (reqSpace) {
        if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
          onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
        reqSpace = false;
      }
      if (tab) {
        if (atNewline && token.type !== "comment" && token.type !== "newline") {
          onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
        }
        tab = null;
      }
      switch (token.type) {
        case "space":
          if (!flow && (indicator !== "doc-start" || next2?.type !== "flow-collection") && token.source.includes("	")) {
            tab = token;
          }
          hasSpace = true;
          break;
        case "comment": {
          if (!hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = token.source.substring(1) || " ";
          if (!comment2)
            comment2 = cb;
          else
            comment2 += commentSep + cb;
          commentSep = "";
          atNewline = false;
          break;
        }
        case "newline":
          if (atNewline) {
            if (comment2)
              comment2 += token.source;
            else if (!found || indicator !== "seq-item-ind")
              spaceBefore = true;
          } else
            commentSep += token.source;
          atNewline = true;
          hasNewline = true;
          if (anchor || tag)
            newlineAfterProp = token;
          hasSpace = true;
          break;
        case "anchor":
          if (anchor)
            onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
          if (token.source.endsWith(":"))
            onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
          anchor = token;
          start2 ?? (start2 = token.offset);
          atNewline = false;
          hasSpace = false;
          reqSpace = true;
          break;
        case "tag": {
          if (tag)
            onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
          tag = token;
          start2 ?? (start2 = token.offset);
          atNewline = false;
          hasSpace = false;
          reqSpace = true;
          break;
        }
        case indicator:
          if (anchor || tag)
            onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
          if (found)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
          found = token;
          atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
          hasSpace = false;
          break;
        case "comma":
          if (flow) {
            if (comma)
              onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
            comma = token;
            atNewline = false;
            hasSpace = false;
            break;
          }
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
          atNewline = false;
          hasSpace = false;
      }
    }
    const last2 = tokens[tokens.length - 1];
    const end2 = last2 ? last2.offset + last2.source.length : offset;
    if (reqSpace && next2 && next2.type !== "space" && next2.type !== "newline" && next2.type !== "comma" && (next2.type !== "scalar" || next2.source !== "")) {
      onError(next2.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
    }
    if (tab && (atNewline && tab.indent <= parentIndent || next2?.type === "block-map" || next2?.type === "block-seq"))
      onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
    return {
      comma,
      found,
      spaceBefore,
      comment: comment2,
      hasNewline,
      anchor,
      tag,
      newlineAfterProp,
      end: end2,
      start: start2 ?? end2
    };
  }

  // node_modules/yaml/browser/dist/compose/util-contains-newline.js
  function containsNewline(key) {
    if (!key)
      return null;
    switch (key.type) {
      case "alias":
      case "scalar":
      case "double-quoted-scalar":
      case "single-quoted-scalar":
        if (key.source.includes("\n"))
          return true;
        if (key.end) {
          for (const st of key.end)
            if (st.type === "newline")
              return true;
        }
        return false;
      case "flow-collection":
        for (const it2 of key.items) {
          for (const st of it2.start)
            if (st.type === "newline")
              return true;
          if (it2.sep) {
            for (const st of it2.sep)
              if (st.type === "newline")
                return true;
          }
          if (containsNewline(it2.key) || containsNewline(it2.value))
            return true;
        }
        return false;
      default:
        return true;
    }
  }

  // node_modules/yaml/browser/dist/compose/util-flow-indent-check.js
  function flowIndentCheck(indent, fc, onError) {
    if (fc?.type === "flow-collection") {
      const end2 = fc.end[0];
      if (end2.indent === indent && (end2.source === "]" || end2.source === "}") && containsNewline(fc)) {
        const msg = "Flow end indicator should be more indented than parent";
        onError(end2, "BAD_INDENT", msg, true);
      }
    }
  }

  // node_modules/yaml/browser/dist/compose/util-map-includes.js
  function mapIncludes(ctx, items, search) {
    const { uniqueKeys } = ctx.options;
    if (uniqueKeys === false)
      return false;
    const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || isScalar(a) && isScalar(b) && a.value === b.value;
    return items.some((pair) => isEqual(pair.key, search));
  }

  // node_modules/yaml/browser/dist/compose/resolve-block-map.js
  var startColMsg = "All mapping items must start at the same column";
  function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bm, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLMap;
    const map4 = new NodeClass(ctx.schema);
    if (ctx.atRoot)
      ctx.atRoot = false;
    let offset = bm.offset;
    let commentEnd = null;
    for (const collItem of bm.items) {
      const { start: start2, key, sep, value } = collItem;
      const keyProps = resolveProps(start2, {
        indicator: "explicit-key-ind",
        next: key ?? sep?.[0],
        offset,
        onError,
        parentIndent: bm.indent,
        startOnNewline: true
      });
      const implicitKey = !keyProps.found;
      if (implicitKey) {
        if (key) {
          if (key.type === "block-seq")
            onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
          else if ("indent" in key && key.indent !== bm.indent)
            onError(offset, "BAD_INDENT", startColMsg);
        }
        if (!keyProps.anchor && !keyProps.tag && !sep) {
          commentEnd = keyProps.end;
          if (keyProps.comment) {
            if (map4.comment)
              map4.comment += "\n" + keyProps.comment;
            else
              map4.comment = keyProps.comment;
          }
          continue;
        }
        if (keyProps.newlineAfterProp || containsNewline(key)) {
          onError(key ?? start2[start2.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
        }
      } else if (keyProps.found?.indent !== bm.indent) {
        onError(offset, "BAD_INDENT", startColMsg);
      }
      ctx.atKey = true;
      const keyStart = keyProps.end;
      const keyNode = key ? composeNode2(ctx, key, keyProps, onError) : composeEmptyNode2(ctx, keyStart, start2, null, keyProps, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bm.indent, key, onError);
      ctx.atKey = false;
      if (mapIncludes(ctx, map4.items, keyNode))
        onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
      const valueProps = resolveProps(sep ?? [], {
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        parentIndent: bm.indent,
        startOnNewline: !key || key.type === "block-scalar"
      });
      offset = valueProps.end;
      if (valueProps.found) {
        if (implicitKey) {
          if (value?.type === "block-map" && !valueProps.hasNewline)
            onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
          if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
            onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
        }
        const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : composeEmptyNode2(ctx, offset, sep, null, valueProps, onError);
        if (ctx.schema.compat)
          flowIndentCheck(bm.indent, value, onError);
        offset = valueNode.range[2];
        const pair = new Pair(keyNode, valueNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        map4.items.push(pair);
      } else {
        if (implicitKey)
          onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
        if (valueProps.comment) {
          if (keyNode.comment)
            keyNode.comment += "\n" + valueProps.comment;
          else
            keyNode.comment = valueProps.comment;
        }
        const pair = new Pair(keyNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        map4.items.push(pair);
      }
    }
    if (commentEnd && commentEnd < offset)
      onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
    map4.range = [bm.offset, offset, commentEnd ?? offset];
    return map4;
  }

  // node_modules/yaml/browser/dist/compose/resolve-block-seq.js
  function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bs, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLSeq;
    const seq2 = new NodeClass(ctx.schema);
    if (ctx.atRoot)
      ctx.atRoot = false;
    if (ctx.atKey)
      ctx.atKey = false;
    let offset = bs.offset;
    let commentEnd = null;
    for (const { start: start2, value } of bs.items) {
      const props = resolveProps(start2, {
        indicator: "seq-item-ind",
        next: value,
        offset,
        onError,
        parentIndent: bs.indent,
        startOnNewline: true
      });
      if (!props.found) {
        if (props.anchor || props.tag || value) {
          if (value?.type === "block-seq")
            onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
          else
            onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
        } else {
          commentEnd = props.end;
          if (props.comment)
            seq2.comment = props.comment;
          continue;
        }
      }
      const node = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, start2, null, props, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bs.indent, value, onError);
      offset = node.range[2];
      seq2.items.push(node);
    }
    seq2.range = [bs.offset, offset, commentEnd ?? offset];
    return seq2;
  }

  // node_modules/yaml/browser/dist/compose/resolve-end.js
  function resolveEnd(end2, offset, reqSpace, onError) {
    let comment2 = "";
    if (end2) {
      let hasSpace = false;
      let sep = "";
      for (const token of end2) {
        const { source, type: type2 } = token;
        switch (type2) {
          case "space":
            hasSpace = true;
            break;
          case "comment": {
            if (reqSpace && !hasSpace)
              onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            const cb = source.substring(1) || " ";
            if (!comment2)
              comment2 = cb;
            else
              comment2 += sep + cb;
            sep = "";
            break;
          }
          case "newline":
            if (comment2)
              sep += source;
            hasSpace = true;
            break;
          default:
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type2} at node end`);
        }
        offset += source.length;
      }
    }
    return { comment: comment2, offset };
  }

  // node_modules/yaml/browser/dist/compose/resolve-flow-collection.js
  var blockMsg = "Block collections are not allowed within flow collections";
  var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
  function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, fc, onError, tag) {
    const isMap2 = fc.start.source === "{";
    const fcName = isMap2 ? "flow map" : "flow sequence";
    const NodeClass = tag?.nodeClass ?? (isMap2 ? YAMLMap : YAMLSeq);
    const coll = new NodeClass(ctx.schema);
    coll.flow = true;
    const atRoot = ctx.atRoot;
    if (atRoot)
      ctx.atRoot = false;
    if (ctx.atKey)
      ctx.atKey = false;
    let offset = fc.offset + fc.start.source.length;
    for (let i = 0; i < fc.items.length; ++i) {
      const collItem = fc.items[i];
      const { start: start2, key, sep, value } = collItem;
      const props = resolveProps(start2, {
        flow: fcName,
        indicator: "explicit-key-ind",
        next: key ?? sep?.[0],
        offset,
        onError,
        parentIndent: fc.indent,
        startOnNewline: false
      });
      if (!props.found) {
        if (!props.anchor && !props.tag && !sep && !value) {
          if (i === 0 && props.comma)
            onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
          else if (i < fc.items.length - 1)
            onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
          if (props.comment) {
            if (coll.comment)
              coll.comment += "\n" + props.comment;
            else
              coll.comment = props.comment;
          }
          offset = props.end;
          continue;
        }
        if (!isMap2 && ctx.options.strict && containsNewline(key))
          onError(
            key,
            // checked by containsNewline()
            "MULTILINE_IMPLICIT_KEY",
            "Implicit keys of flow sequence pairs need to be on a single line"
          );
      }
      if (i === 0) {
        if (props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
      } else {
        if (!props.comma)
          onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
        if (props.comment) {
          let prevItemComment = "";
          loop: for (const st of start2) {
            switch (st.type) {
              case "comma":
              case "space":
                break;
              case "comment":
                prevItemComment = st.source.substring(1);
                break loop;
              default:
                break loop;
            }
          }
          if (prevItemComment) {
            let prev2 = coll.items[coll.items.length - 1];
            if (isPair(prev2))
              prev2 = prev2.value ?? prev2.key;
            if (prev2.comment)
              prev2.comment += "\n" + prevItemComment;
            else
              prev2.comment = prevItemComment;
            props.comment = props.comment.substring(prevItemComment.length + 1);
          }
        }
      }
      if (!isMap2 && !sep && !props.found) {
        const valueNode = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, sep, null, props, onError);
        coll.items.push(valueNode);
        offset = valueNode.range[2];
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else {
        ctx.atKey = true;
        const keyStart = props.end;
        const keyNode = key ? composeNode2(ctx, key, props, onError) : composeEmptyNode2(ctx, keyStart, start2, null, props, onError);
        if (isBlock(key))
          onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
        ctx.atKey = false;
        const valueProps = resolveProps(sep ?? [], {
          flow: fcName,
          indicator: "map-value-ind",
          next: value,
          offset: keyNode.range[2],
          onError,
          parentIndent: fc.indent,
          startOnNewline: false
        });
        if (valueProps.found) {
          if (!isMap2 && !props.found && ctx.options.strict) {
            if (sep)
              for (const st of sep) {
                if (st === valueProps.found)
                  break;
                if (st.type === "newline") {
                  onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                  break;
                }
              }
            if (props.start < valueProps.found.offset - 1024)
              onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
          }
        } else if (value) {
          if ("source" in value && value.source?.[0] === ":")
            onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
          else
            onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
        }
        const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode2(ctx, valueProps.end, sep, null, valueProps, onError) : null;
        if (valueNode) {
          if (isBlock(value))
            onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else if (valueProps.comment) {
          if (keyNode.comment)
            keyNode.comment += "\n" + valueProps.comment;
          else
            keyNode.comment = valueProps.comment;
        }
        const pair = new Pair(keyNode, valueNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        if (isMap2) {
          const map4 = coll;
          if (mapIncludes(ctx, map4.items, keyNode))
            onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
          map4.items.push(pair);
        } else {
          const map4 = new YAMLMap(ctx.schema);
          map4.flow = true;
          map4.items.push(pair);
          const endRange = (valueNode ?? keyNode).range;
          map4.range = [keyNode.range[0], endRange[1], endRange[2]];
          coll.items.push(map4);
        }
        offset = valueNode ? valueNode.range[2] : valueProps.end;
      }
    }
    const expectedEnd = isMap2 ? "}" : "]";
    const [ce, ...ee2] = fc.end;
    let cePos = offset;
    if (ce?.source === expectedEnd)
      cePos = ce.offset + ce.source.length;
    else {
      const name2 = fcName[0].toUpperCase() + fcName.substring(1);
      const msg = atRoot ? `${name2} must end with a ${expectedEnd}` : `${name2} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
      onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
      if (ce && ce.source.length !== 1)
        ee2.unshift(ce);
    }
    if (ee2.length > 0) {
      const end2 = resolveEnd(ee2, cePos, ctx.options.strict, onError);
      if (end2.comment) {
        if (coll.comment)
          coll.comment += "\n" + end2.comment;
        else
          coll.comment = end2.comment;
      }
      coll.range = [fc.offset, cePos, end2.offset];
    } else {
      coll.range = [fc.offset, cePos, cePos];
    }
    return coll;
  }

  // node_modules/yaml/browser/dist/compose/compose-collection.js
  function resolveCollection(CN2, ctx, token, onError, tagName, tag) {
    const coll = token.type === "block-map" ? resolveBlockMap(CN2, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq(CN2, ctx, token, onError, tag) : resolveFlowCollection(CN2, ctx, token, onError, tag);
    const Coll = coll.constructor;
    if (tagName === "!" || tagName === Coll.tagName) {
      coll.tag = Coll.tagName;
      return coll;
    }
    if (tagName)
      coll.tag = tagName;
    return coll;
  }
  function composeCollection(CN2, ctx, token, props, onError) {
    const tagToken = props.tag;
    const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
    if (token.type === "block-seq") {
      const { anchor, newlineAfterProp: nl } = props;
      const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
      if (lastProp && (!nl || nl.offset < lastProp.offset)) {
        const message = "Missing newline after block sequence props";
        onError(lastProp, "MISSING_CHAR", message);
      }
    }
    const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
    if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.tagName && expType === "seq") {
      return resolveCollection(CN2, ctx, token, onError, tagName);
    }
    let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
    if (!tag) {
      const kt = ctx.schema.knownTags[tagName];
      if (kt?.collection === expType) {
        ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
        tag = kt;
      } else {
        if (kt) {
          onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? "scalar"}`, true);
        } else {
          onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
        }
        return resolveCollection(CN2, ctx, token, onError, tagName);
      }
    }
    const coll = resolveCollection(CN2, ctx, token, onError, tagName, tag);
    const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
    const node = isNode2(res) ? res : new Scalar(res);
    node.range = coll.range;
    node.tag = tagName;
    if (tag?.format)
      node.format = tag.format;
    return node;
  }

  // node_modules/yaml/browser/dist/compose/resolve-block-scalar.js
  function resolveBlockScalar(ctx, scalar, onError) {
    const start2 = scalar.offset;
    const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
    if (!header)
      return { value: "", type: null, comment: "", range: [start2, start2, start2] };
    const type2 = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
    const lines = scalar.source ? splitLines(scalar.source) : [];
    let chompStart = lines.length;
    for (let i = lines.length - 1; i >= 0; --i) {
      const content = lines[i][1];
      if (content === "" || content === "\r")
        chompStart = i;
      else
        break;
    }
    if (chompStart === 0) {
      const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
      let end3 = start2 + header.length;
      if (scalar.source)
        end3 += scalar.source.length;
      return { value: value2, type: type2, comment: header.comment, range: [start2, end3, end3] };
    }
    let trimIndent = scalar.indent + header.indent;
    let offset = scalar.offset + header.length;
    let contentStart = 0;
    for (let i = 0; i < chompStart; ++i) {
      const [indent, content] = lines[i];
      if (content === "" || content === "\r") {
        if (header.indent === 0 && indent.length > trimIndent)
          trimIndent = indent.length;
      } else {
        if (indent.length < trimIndent) {
          const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
          onError(offset + indent.length, "MISSING_CHAR", message);
        }
        if (header.indent === 0)
          trimIndent = indent.length;
        contentStart = i;
        if (trimIndent === 0 && !ctx.atRoot) {
          const message = "Block scalar values in collections must be indented";
          onError(offset, "BAD_INDENT", message);
        }
        break;
      }
      offset += indent.length + content.length + 1;
    }
    for (let i = lines.length - 1; i >= chompStart; --i) {
      if (lines[i][0].length > trimIndent)
        chompStart = i + 1;
    }
    let value = "";
    let sep = "";
    let prevMoreIndented = false;
    for (let i = 0; i < contentStart; ++i)
      value += lines[i][0].slice(trimIndent) + "\n";
    for (let i = contentStart; i < chompStart; ++i) {
      let [indent, content] = lines[i];
      offset += indent.length + content.length + 1;
      const crlf = content[content.length - 1] === "\r";
      if (crlf)
        content = content.slice(0, -1);
      if (content && indent.length < trimIndent) {
        const src = header.indent ? "explicit indentation indicator" : "first line";
        const message = `Block scalar lines must not be less indented than their ${src}`;
        onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
        indent = "";
      }
      if (type2 === Scalar.BLOCK_LITERAL) {
        value += sep + indent.slice(trimIndent) + content;
        sep = "\n";
      } else if (indent.length > trimIndent || content[0] === "	") {
        if (sep === " ")
          sep = "\n";
        else if (!prevMoreIndented && sep === "\n")
          sep = "\n\n";
        value += sep + indent.slice(trimIndent) + content;
        sep = "\n";
        prevMoreIndented = true;
      } else if (content === "") {
        if (sep === "\n")
          value += "\n";
        else
          sep = "\n";
      } else {
        value += sep + content;
        sep = " ";
        prevMoreIndented = false;
      }
    }
    switch (header.chomp) {
      case "-":
        break;
      case "+":
        for (let i = chompStart; i < lines.length; ++i)
          value += "\n" + lines[i][0].slice(trimIndent);
        if (value[value.length - 1] !== "\n")
          value += "\n";
        break;
      default:
        value += "\n";
    }
    const end2 = start2 + header.length + scalar.source.length;
    return { value, type: type2, comment: header.comment, range: [start2, end2, end2] };
  }
  function parseBlockScalarHeader({ offset, props }, strict, onError) {
    if (props[0].type !== "block-scalar-header") {
      onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
      return null;
    }
    const { source } = props[0];
    const mode = source[0];
    let indent = 0;
    let chomp = "";
    let error2 = -1;
    for (let i = 1; i < source.length; ++i) {
      const ch = source[i];
      if (!chomp && (ch === "-" || ch === "+"))
        chomp = ch;
      else {
        const n = Number(ch);
        if (!indent && n)
          indent = n;
        else if (error2 === -1)
          error2 = offset + i;
      }
    }
    if (error2 !== -1)
      onError(error2, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
    let hasSpace = false;
    let comment2 = "";
    let length = source.length;
    for (let i = 1; i < props.length; ++i) {
      const token = props[i];
      switch (token.type) {
        case "space":
          hasSpace = true;
        case "newline":
          length += token.source.length;
          break;
        case "comment":
          if (strict && !hasSpace) {
            const message = "Comments must be separated from other tokens by white space characters";
            onError(token, "MISSING_CHAR", message);
          }
          length += token.source.length;
          comment2 = token.source.substring(1);
          break;
        case "error":
          onError(token, "UNEXPECTED_TOKEN", token.message);
          length += token.source.length;
          break;
        default: {
          const message = `Unexpected token in block scalar header: ${token.type}`;
          onError(token, "UNEXPECTED_TOKEN", message);
          const ts = token.source;
          if (ts && typeof ts === "string")
            length += ts.length;
        }
      }
    }
    return { mode, indent, chomp, comment: comment2, length };
  }
  function splitLines(source) {
    const split = source.split(/\n( *)/);
    const first2 = split[0];
    const m = first2.match(/^( *)/);
    const line0 = m?.[1] ? [m[1], first2.slice(m[1].length)] : ["", first2];
    const lines = [line0];
    for (let i = 1; i < split.length; i += 2)
      lines.push([split[i], split[i + 1]]);
    return lines;
  }

  // node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js
  function resolveFlowScalar(scalar, strict, onError) {
    const { offset, type: type2, source, end: end2 } = scalar;
    let _type;
    let value;
    const _onError = (rel, code2, msg) => onError(offset + rel, code2, msg);
    switch (type2) {
      case "scalar":
        _type = Scalar.PLAIN;
        value = plainValue(source, _onError);
        break;
      case "single-quoted-scalar":
        _type = Scalar.QUOTE_SINGLE;
        value = singleQuotedValue(source, _onError);
        break;
      case "double-quoted-scalar":
        _type = Scalar.QUOTE_DOUBLE;
        value = doubleQuotedValue(source, _onError);
        break;
      default:
        onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type2}`);
        return {
          value: "",
          type: null,
          comment: "",
          range: [offset, offset + source.length, offset + source.length]
        };
    }
    const valueEnd = offset + source.length;
    const re2 = resolveEnd(end2, valueEnd, strict, onError);
    return {
      value,
      type: _type,
      comment: re2.comment,
      range: [offset, valueEnd, re2.offset]
    };
  }
  function plainValue(source, onError) {
    let badChar = "";
    switch (source[0]) {
      case "	":
        badChar = "a tab character";
        break;
      case ",":
        badChar = "flow indicator character ,";
        break;
      case "%":
        badChar = "directive indicator character %";
        break;
      case "|":
      case ">": {
        badChar = `block scalar indicator ${source[0]}`;
        break;
      }
      case "@":
      case "`": {
        badChar = `reserved character ${source[0]}`;
        break;
      }
    }
    if (badChar)
      onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
    return foldLines(source);
  }
  function singleQuotedValue(source, onError) {
    if (source[source.length - 1] !== "'" || source.length === 1)
      onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
    return foldLines(source.slice(1, -1)).replace(/''/g, "'");
  }
  function foldLines(source) {
    let first2, line;
    try {
      first2 = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
      line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
    } catch {
      first2 = /(.*?)[ \t]*\r?\n/sy;
      line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
    }
    let match2 = first2.exec(source);
    if (!match2)
      return source;
    let res = match2[1];
    let sep = " ";
    let pos = first2.lastIndex;
    line.lastIndex = pos;
    while (match2 = line.exec(source)) {
      if (match2[1] === "") {
        if (sep === "\n")
          res += sep;
        else
          sep = "\n";
      } else {
        res += sep + match2[1];
        sep = " ";
      }
      pos = line.lastIndex;
    }
    const last2 = /[ \t]*(.*)/sy;
    last2.lastIndex = pos;
    match2 = last2.exec(source);
    return res + sep + (match2?.[1] ?? "");
  }
  function doubleQuotedValue(source, onError) {
    let res = "";
    for (let i = 1; i < source.length - 1; ++i) {
      const ch = source[i];
      if (ch === "\r" && source[i + 1] === "\n")
        continue;
      if (ch === "\n") {
        const { fold, offset } = foldNewline(source, i);
        res += fold;
        i = offset;
      } else if (ch === "\\") {
        let next2 = source[++i];
        const cc = escapeCodes[next2];
        if (cc)
          res += cc;
        else if (next2 === "\n") {
          next2 = source[i + 1];
          while (next2 === " " || next2 === "	")
            next2 = source[++i + 1];
        } else if (next2 === "\r" && source[i + 1] === "\n") {
          next2 = source[++i + 1];
          while (next2 === " " || next2 === "	")
            next2 = source[++i + 1];
        } else if (next2 === "x" || next2 === "u" || next2 === "U") {
          const length = { x: 2, u: 4, U: 8 }[next2];
          res += parseCharCode(source, i + 1, length, onError);
          i += length;
        } else {
          const raw = source.substr(i - 1, 2);
          onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
          res += raw;
        }
      } else if (ch === " " || ch === "	") {
        const wsStart = i;
        let next2 = source[i + 1];
        while (next2 === " " || next2 === "	")
          next2 = source[++i + 1];
        if (next2 !== "\n" && !(next2 === "\r" && source[i + 2] === "\n"))
          res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
      } else {
        res += ch;
      }
    }
    if (source[source.length - 1] !== '"' || source.length === 1)
      onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
    return res;
  }
  function foldNewline(source, offset) {
    let fold = "";
    let ch = source[offset + 1];
    while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
      if (ch === "\r" && source[offset + 2] !== "\n")
        break;
      if (ch === "\n")
        fold += "\n";
      offset += 1;
      ch = source[offset + 1];
    }
    if (!fold)
      fold = " ";
    return { fold, offset };
  }
  var escapeCodes = {
    "0": "\0",
    // null character
    a: "\x07",
    // bell character
    b: "\b",
    // backspace
    e: "\x1B",
    // escape character
    f: "\f",
    // form feed
    n: "\n",
    // line feed
    r: "\r",
    // carriage return
    t: "	",
    // horizontal tab
    v: "\v",
    // vertical tab
    N: "\x85",
    // Unicode next line
    _: "\xA0",
    // Unicode non-breaking space
    L: "\u2028",
    // Unicode line separator
    P: "\u2029",
    // Unicode paragraph separator
    " ": " ",
    '"': '"',
    "/": "/",
    "\\": "\\",
    "	": "	"
  };
  function parseCharCode(source, offset, length, onError) {
    const cc = source.substr(offset, length);
    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
    const code2 = ok ? parseInt(cc, 16) : NaN;
    if (isNaN(code2)) {
      const raw = source.substr(offset - 2, length + 2);
      onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
      return raw;
    }
    return String.fromCodePoint(code2);
  }

  // node_modules/yaml/browser/dist/compose/compose-scalar.js
  function composeScalar(ctx, token, tagToken, onError) {
    const { value, type: type2, comment: comment2, range } = token.type === "block-scalar" ? resolveBlockScalar(ctx, token, onError) : resolveFlowScalar(token, ctx.options.strict, onError);
    const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
    let tag;
    if (ctx.options.stringKeys && ctx.atKey) {
      tag = ctx.schema[SCALAR];
    } else if (tagName)
      tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
    else if (token.type === "scalar")
      tag = findScalarTagByTest(ctx, value, token, onError);
    else
      tag = ctx.schema[SCALAR];
    let scalar;
    try {
      const res = tag.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
      scalar = isScalar(res) ? res : new Scalar(res);
    } catch (error2) {
      const msg = error2 instanceof Error ? error2.message : String(error2);
      onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
      scalar = new Scalar(value);
    }
    scalar.range = range;
    scalar.source = value;
    if (type2)
      scalar.type = type2;
    if (tagName)
      scalar.tag = tagName;
    if (tag.format)
      scalar.format = tag.format;
    if (comment2)
      scalar.comment = comment2;
    return scalar;
  }
  function findScalarTagByName(schema4, value, tagName, tagToken, onError) {
    if (tagName === "!")
      return schema4[SCALAR];
    const matchWithTest = [];
    for (const tag of schema4.tags) {
      if (!tag.collection && tag.tag === tagName) {
        if (tag.default && tag.test)
          matchWithTest.push(tag);
        else
          return tag;
      }
    }
    for (const tag of matchWithTest)
      if (tag.test?.test(value))
        return tag;
    const kt = schema4.knownTags[tagName];
    if (kt && !kt.collection) {
      schema4.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
      return kt;
    }
    onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
    return schema4[SCALAR];
  }
  function findScalarTagByTest({ atKey, directives, schema: schema4 }, value, token, onError) {
    const tag = schema4.tags.find((tag2) => (tag2.default === true || atKey && tag2.default === "key") && tag2.test?.test(value)) || schema4[SCALAR];
    if (schema4.compat) {
      const compat = schema4.compat.find((tag2) => tag2.default && tag2.test?.test(value)) ?? schema4[SCALAR];
      if (tag.tag !== compat.tag) {
        const ts = directives.tagString(tag.tag);
        const cs = directives.tagString(compat.tag);
        const msg = `Value may be parsed as either ${ts} or ${cs}`;
        onError(token, "TAG_RESOLVE_FAILED", msg, true);
      }
    }
    return tag;
  }

  // node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js
  function emptyScalarPosition(offset, before2, pos) {
    if (before2) {
      pos ?? (pos = before2.length);
      for (let i = pos - 1; i >= 0; --i) {
        let st = before2[i];
        switch (st.type) {
          case "space":
          case "comment":
          case "newline":
            offset -= st.source.length;
            continue;
        }
        st = before2[++i];
        while (st?.type === "space") {
          offset += st.source.length;
          st = before2[++i];
        }
        break;
      }
    }
    return offset;
  }

  // node_modules/yaml/browser/dist/compose/compose-node.js
  var CN = { composeNode, composeEmptyNode };
  function composeNode(ctx, token, props, onError) {
    const atKey = ctx.atKey;
    const { spaceBefore, comment: comment2, anchor, tag } = props;
    let node;
    let isSrcToken = true;
    switch (token.type) {
      case "alias":
        node = composeAlias(ctx, token, onError);
        if (anchor || tag)
          onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
        break;
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
      case "block-scalar":
        node = composeScalar(ctx, token, tag, onError);
        if (anchor)
          node.anchor = anchor.source.substring(1);
        break;
      case "block-map":
      case "block-seq":
      case "flow-collection":
        node = composeCollection(CN, ctx, token, props, onError);
        if (anchor)
          node.anchor = anchor.source.substring(1);
        break;
      default: {
        const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
        onError(token, "UNEXPECTED_TOKEN", message);
        node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
        isSrcToken = false;
      }
    }
    if (anchor && node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    if (atKey && ctx.options.stringKeys && (!isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
      const msg = "With stringKeys, all keys must be strings";
      onError(tag ?? token, "NON_STRING_KEY", msg);
    }
    if (spaceBefore)
      node.spaceBefore = true;
    if (comment2) {
      if (token.type === "scalar" && token.source === "")
        node.comment = comment2;
      else
        node.commentBefore = comment2;
    }
    if (ctx.options.keepSourceTokens && isSrcToken)
      node.srcToken = token;
    return node;
  }
  function composeEmptyNode(ctx, offset, before2, pos, { spaceBefore, comment: comment2, anchor, tag, end: end2 }, onError) {
    const token = {
      type: "scalar",
      offset: emptyScalarPosition(offset, before2, pos),
      indent: -1,
      source: ""
    };
    const node = composeScalar(ctx, token, tag, onError);
    if (anchor) {
      node.anchor = anchor.source.substring(1);
      if (node.anchor === "")
        onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    }
    if (spaceBefore)
      node.spaceBefore = true;
    if (comment2) {
      node.comment = comment2;
      node.range[2] = end2;
    }
    return node;
  }
  function composeAlias({ options }, { offset, source, end: end2 }, onError) {
    const alias = new Alias(source.substring(1));
    if (alias.source === "")
      onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
    if (alias.source.endsWith(":"))
      onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
    const valueEnd = offset + source.length;
    const re2 = resolveEnd(end2, valueEnd, options.strict, onError);
    alias.range = [offset, valueEnd, re2.offset];
    if (re2.comment)
      alias.comment = re2.comment;
    return alias;
  }

  // node_modules/yaml/browser/dist/compose/compose-doc.js
  function composeDoc(options, directives, { offset, start: start2, value, end: end2 }, onError) {
    const opts = Object.assign({ _directives: directives }, options);
    const doc = new Document2(void 0, opts);
    const ctx = {
      atKey: false,
      atRoot: true,
      directives: doc.directives,
      options: doc.options,
      schema: doc.schema
    };
    const props = resolveProps(start2, {
      indicator: "doc-start",
      next: value ?? end2?.[0],
      offset,
      onError,
      parentIndent: 0,
      startOnNewline: true
    });
    if (props.found) {
      doc.directives.docStart = true;
      if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
        onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
    }
    doc.contents = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start2, null, props, onError);
    const contentEnd = doc.contents.range[2];
    const re2 = resolveEnd(end2, contentEnd, false, onError);
    if (re2.comment)
      doc.comment = re2.comment;
    doc.range = [offset, contentEnd, re2.offset];
    return doc;
  }

  // node_modules/yaml/browser/dist/compose/composer.js
  function getErrorPos(src) {
    if (typeof src === "number")
      return [src, src + 1];
    if (Array.isArray(src))
      return src.length === 2 ? src : [src[0], src[1]];
    const { offset, source } = src;
    return [offset, offset + (typeof source === "string" ? source.length : 1)];
  }
  function parsePrelude(prelude) {
    let comment2 = "";
    let atComment = false;
    let afterEmptyLine = false;
    for (let i = 0; i < prelude.length; ++i) {
      const source = prelude[i];
      switch (source[0]) {
        case "#":
          comment2 += (comment2 === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
          atComment = true;
          afterEmptyLine = false;
          break;
        case "%":
          if (prelude[i + 1]?.[0] !== "#")
            i += 1;
          atComment = false;
          break;
        default:
          if (!atComment)
            afterEmptyLine = true;
          atComment = false;
      }
    }
    return { comment: comment2, afterEmptyLine };
  }
  var Composer = class {
    constructor(options = {}) {
      this.doc = null;
      this.atDirectives = false;
      this.prelude = [];
      this.errors = [];
      this.warnings = [];
      this.onError = (source, code2, message, warning) => {
        const pos = getErrorPos(source);
        if (warning)
          this.warnings.push(new YAMLWarning(pos, code2, message));
        else
          this.errors.push(new YAMLParseError(pos, code2, message));
      };
      this.directives = new Directives({ version: options.version || "1.2" });
      this.options = options;
    }
    decorate(doc, afterDoc) {
      const { comment: comment2, afterEmptyLine } = parsePrelude(this.prelude);
      if (comment2) {
        const dc = doc.contents;
        if (afterDoc) {
          doc.comment = doc.comment ? `${doc.comment}
${comment2}` : comment2;
        } else if (afterEmptyLine || doc.directives.docStart || !dc) {
          doc.commentBefore = comment2;
        } else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {
          let it2 = dc.items[0];
          if (isPair(it2))
            it2 = it2.key;
          const cb = it2.commentBefore;
          it2.commentBefore = cb ? `${comment2}
${cb}` : comment2;
        } else {
          const cb = dc.commentBefore;
          dc.commentBefore = cb ? `${comment2}
${cb}` : comment2;
        }
      }
      if (afterDoc) {
        Array.prototype.push.apply(doc.errors, this.errors);
        Array.prototype.push.apply(doc.warnings, this.warnings);
      } else {
        doc.errors = this.errors;
        doc.warnings = this.warnings;
      }
      this.prelude = [];
      this.errors = [];
      this.warnings = [];
    }
    /**
     * Current stream status information.
     *
     * Mostly useful at the end of input for an empty stream.
     */
    streamInfo() {
      return {
        comment: parsePrelude(this.prelude).comment,
        directives: this.directives,
        errors: this.errors,
        warnings: this.warnings
      };
    }
    /**
     * Compose tokens into documents.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */
    *compose(tokens, forceDoc = false, endOffset = -1) {
      for (const token of tokens)
        yield* this.next(token);
      yield* this.end(forceDoc, endOffset);
    }
    /** Advance the composer by one CST token. */
    *next(token) {
      switch (token.type) {
        case "directive":
          this.directives.add(token.source, (offset, message, warning) => {
            const pos = getErrorPos(token);
            pos[0] += offset;
            this.onError(pos, "BAD_DIRECTIVE", message, warning);
          });
          this.prelude.push(token.source);
          this.atDirectives = true;
          break;
        case "document": {
          const doc = composeDoc(this.options, this.directives, token, this.onError);
          if (this.atDirectives && !doc.directives.docStart)
            this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
          this.decorate(doc, false);
          if (this.doc)
            yield this.doc;
          this.doc = doc;
          this.atDirectives = false;
          break;
        }
        case "byte-order-mark":
        case "space":
          break;
        case "comment":
        case "newline":
          this.prelude.push(token.source);
          break;
        case "error": {
          const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
          const error2 = new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
          if (this.atDirectives || !this.doc)
            this.errors.push(error2);
          else
            this.doc.errors.push(error2);
          break;
        }
        case "doc-end": {
          if (!this.doc) {
            const msg = "Unexpected doc-end without preceding document";
            this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
            break;
          }
          this.doc.directives.docEnd = true;
          const end2 = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
          this.decorate(this.doc, true);
          if (end2.comment) {
            const dc = this.doc.comment;
            this.doc.comment = dc ? `${dc}
${end2.comment}` : end2.comment;
          }
          this.doc.range[2] = end2.offset;
          break;
        }
        default:
          this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
      }
    }
    /**
     * Call at end of input to yield any remaining document.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */
    *end(forceDoc = false, endOffset = -1) {
      if (this.doc) {
        this.decorate(this.doc, true);
        yield this.doc;
        this.doc = null;
      } else if (forceDoc) {
        const opts = Object.assign({ _directives: this.directives }, this.options);
        const doc = new Document2(void 0, opts);
        if (this.atDirectives)
          this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
        doc.range = [0, endOffset, endOffset];
        this.decorate(doc, false);
        yield doc;
      }
    }
  };

  // node_modules/yaml/browser/dist/parse/cst-visit.js
  var BREAK2 = Symbol("break visit");
  var SKIP2 = Symbol("skip children");
  var REMOVE2 = Symbol("remove item");
  function visit2(cst, visitor) {
    if ("type" in cst && cst.type === "document")
      cst = { start: cst.start, value: cst.value };
    _visit(Object.freeze([]), cst, visitor);
  }
  visit2.BREAK = BREAK2;
  visit2.SKIP = SKIP2;
  visit2.REMOVE = REMOVE2;
  visit2.itemAtPath = (cst, path2) => {
    let item = cst;
    for (const [field, index2] of path2) {
      const tok = item?.[field];
      if (tok && "items" in tok) {
        item = tok.items[index2];
      } else
        return void 0;
    }
    return item;
  };
  visit2.parentCollection = (cst, path2) => {
    const parent2 = visit2.itemAtPath(cst, path2.slice(0, -1));
    const field = path2[path2.length - 1][0];
    const coll = parent2?.[field];
    if (coll && "items" in coll)
      return coll;
    throw new Error("Parent collection not found");
  };
  function _visit(path2, item, visitor) {
    let ctrl = visitor(item, path2);
    if (typeof ctrl === "symbol")
      return ctrl;
    for (const field of ["key", "value"]) {
      const token = item[field];
      if (token && "items" in token) {
        for (let i = 0; i < token.items.length; ++i) {
          const ci = _visit(Object.freeze(path2.concat([[field, i]])), token.items[i], visitor);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK2)
            return BREAK2;
          else if (ci === REMOVE2) {
            token.items.splice(i, 1);
            i -= 1;
          }
        }
        if (typeof ctrl === "function" && field === "key")
          ctrl = ctrl(item, path2);
      }
    }
    return typeof ctrl === "function" ? ctrl(item, path2) : ctrl;
  }

  // node_modules/yaml/browser/dist/parse/cst.js
  var BOM = "\uFEFF";
  var DOCUMENT = "";
  var FLOW_END = "";
  var SCALAR2 = "";
  function tokenType(source) {
    switch (source) {
      case BOM:
        return "byte-order-mark";
      case DOCUMENT:
        return "doc-mode";
      case FLOW_END:
        return "flow-error-end";
      case SCALAR2:
        return "scalar";
      case "---":
        return "doc-start";
      case "...":
        return "doc-end";
      case "":
      case "\n":
      case "\r\n":
        return "newline";
      case "-":
        return "seq-item-ind";
      case "?":
        return "explicit-key-ind";
      case ":":
        return "map-value-ind";
      case "{":
        return "flow-map-start";
      case "}":
        return "flow-map-end";
      case "[":
        return "flow-seq-start";
      case "]":
        return "flow-seq-end";
      case ",":
        return "comma";
    }
    switch (source[0]) {
      case " ":
      case "	":
        return "space";
      case "#":
        return "comment";
      case "%":
        return "directive-line";
      case "*":
        return "alias";
      case "&":
        return "anchor";
      case "!":
        return "tag";
      case "'":
        return "single-quoted-scalar";
      case '"':
        return "double-quoted-scalar";
      case "|":
      case ">":
        return "block-scalar-header";
    }
    return null;
  }

  // node_modules/yaml/browser/dist/parse/lexer.js
  function isEmpty2(ch) {
    switch (ch) {
      case void 0:
      case " ":
      case "\n":
      case "\r":
      case "	":
        return true;
      default:
        return false;
    }
  }
  var hexDigits = new Set("0123456789ABCDEFabcdef");
  var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
  var flowIndicatorChars = new Set(",[]{}");
  var invalidAnchorChars = new Set(" ,[]{}\n\r	");
  var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
  var Lexer = class {
    constructor() {
      this.atEnd = false;
      this.blockScalarIndent = -1;
      this.blockScalarKeep = false;
      this.buffer = "";
      this.flowKey = false;
      this.flowLevel = 0;
      this.indentNext = 0;
      this.indentValue = 0;
      this.lineEndPos = null;
      this.next = null;
      this.pos = 0;
    }
    /**
     * Generate YAML tokens from the `source` string. If `incomplete`,
     * a part of the last line may be left as a buffer for the next call.
     *
     * @returns A generator of lexical tokens
     */
    *lex(source, incomplete = false) {
      if (source) {
        if (typeof source !== "string")
          throw TypeError("source is not a string");
        this.buffer = this.buffer ? this.buffer + source : source;
        this.lineEndPos = null;
      }
      this.atEnd = !incomplete;
      let next2 = this.next ?? "stream";
      while (next2 && (incomplete || this.hasChars(1)))
        next2 = yield* this.parseNext(next2);
    }
    atLineEnd() {
      let i = this.pos;
      let ch = this.buffer[i];
      while (ch === " " || ch === "	")
        ch = this.buffer[++i];
      if (!ch || ch === "#" || ch === "\n")
        return true;
      if (ch === "\r")
        return this.buffer[i + 1] === "\n";
      return false;
    }
    charAt(n) {
      return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
      let ch = this.buffer[offset];
      if (this.indentNext > 0) {
        let indent = 0;
        while (ch === " ")
          ch = this.buffer[++indent + offset];
        if (ch === "\r") {
          const next2 = this.buffer[indent + offset + 1];
          if (next2 === "\n" || !next2 && !this.atEnd)
            return offset + indent + 1;
        }
        return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
      }
      if (ch === "-" || ch === ".") {
        const dt = this.buffer.substr(offset, 3);
        if ((dt === "---" || dt === "...") && isEmpty2(this.buffer[offset + 3]))
          return -1;
      }
      return offset;
    }
    getLine() {
      let end2 = this.lineEndPos;
      if (typeof end2 !== "number" || end2 !== -1 && end2 < this.pos) {
        end2 = this.buffer.indexOf("\n", this.pos);
        this.lineEndPos = end2;
      }
      if (end2 === -1)
        return this.atEnd ? this.buffer.substring(this.pos) : null;
      if (this.buffer[end2 - 1] === "\r")
        end2 -= 1;
      return this.buffer.substring(this.pos, end2);
    }
    hasChars(n) {
      return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
      this.buffer = this.buffer.substring(this.pos);
      this.pos = 0;
      this.lineEndPos = null;
      this.next = state;
      return null;
    }
    peek(n) {
      return this.buffer.substr(this.pos, n);
    }
    *parseNext(next2) {
      switch (next2) {
        case "stream":
          return yield* this.parseStream();
        case "line-start":
          return yield* this.parseLineStart();
        case "block-start":
          return yield* this.parseBlockStart();
        case "doc":
          return yield* this.parseDocument();
        case "flow":
          return yield* this.parseFlowCollection();
        case "quoted-scalar":
          return yield* this.parseQuotedScalar();
        case "block-scalar":
          return yield* this.parseBlockScalar();
        case "plain-scalar":
          return yield* this.parsePlainScalar();
      }
    }
    *parseStream() {
      let line = this.getLine();
      if (line === null)
        return this.setNext("stream");
      if (line[0] === BOM) {
        yield* this.pushCount(1);
        line = line.substring(1);
      }
      if (line[0] === "%") {
        let dirEnd = line.length;
        let cs = line.indexOf("#");
        while (cs !== -1) {
          const ch = line[cs - 1];
          if (ch === " " || ch === "	") {
            dirEnd = cs - 1;
            break;
          } else {
            cs = line.indexOf("#", cs + 1);
          }
        }
        while (true) {
          const ch = line[dirEnd - 1];
          if (ch === " " || ch === "	")
            dirEnd -= 1;
          else
            break;
        }
        const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
        yield* this.pushCount(line.length - n);
        this.pushNewline();
        return "stream";
      }
      if (this.atLineEnd()) {
        const sp = yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - sp);
        yield* this.pushNewline();
        return "stream";
      }
      yield DOCUMENT;
      return yield* this.parseLineStart();
    }
    *parseLineStart() {
      const ch = this.charAt(0);
      if (!ch && !this.atEnd)
        return this.setNext("line-start");
      if (ch === "-" || ch === ".") {
        if (!this.atEnd && !this.hasChars(4))
          return this.setNext("line-start");
        const s = this.peek(3);
        if ((s === "---" || s === "...") && isEmpty2(this.charAt(3))) {
          yield* this.pushCount(3);
          this.indentValue = 0;
          this.indentNext = 0;
          return s === "---" ? "doc" : "stream";
        }
      }
      this.indentValue = yield* this.pushSpaces(false);
      if (this.indentNext > this.indentValue && !isEmpty2(this.charAt(1)))
        this.indentNext = this.indentValue;
      return yield* this.parseBlockStart();
    }
    *parseBlockStart() {
      const [ch0, ch1] = this.peek(2);
      if (!ch1 && !this.atEnd)
        return this.setNext("block-start");
      if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty2(ch1)) {
        const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
        this.indentNext = this.indentValue + 1;
        this.indentValue += n;
        return yield* this.parseBlockStart();
      }
      return "doc";
    }
    *parseDocument() {
      yield* this.pushSpaces(true);
      const line = this.getLine();
      if (line === null)
        return this.setNext("doc");
      let n = yield* this.pushIndicators();
      switch (line[n]) {
        case "#":
          yield* this.pushCount(line.length - n);
        case void 0:
          yield* this.pushNewline();
          return yield* this.parseLineStart();
        case "{":
        case "[":
          yield* this.pushCount(1);
          this.flowKey = false;
          this.flowLevel = 1;
          return "flow";
        case "}":
        case "]":
          yield* this.pushCount(1);
          return "doc";
        case "*":
          yield* this.pushUntil(isNotAnchorChar);
          return "doc";
        case '"':
        case "'":
          return yield* this.parseQuotedScalar();
        case "|":
        case ">":
          n += yield* this.parseBlockScalarHeader();
          n += yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - n);
          yield* this.pushNewline();
          return yield* this.parseBlockScalar();
        default:
          return yield* this.parsePlainScalar();
      }
    }
    *parseFlowCollection() {
      let nl, sp;
      let indent = -1;
      do {
        nl = yield* this.pushNewline();
        if (nl > 0) {
          sp = yield* this.pushSpaces(false);
          this.indentValue = indent = sp;
        } else {
          sp = 0;
        }
        sp += yield* this.pushSpaces(true);
      } while (nl + sp > 0);
      const line = this.getLine();
      if (line === null)
        return this.setNext("flow");
      if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty2(line[3])) {
        const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
        if (!atFlowEndMarker) {
          this.flowLevel = 0;
          yield FLOW_END;
          return yield* this.parseLineStart();
        }
      }
      let n = 0;
      while (line[n] === ",") {
        n += yield* this.pushCount(1);
        n += yield* this.pushSpaces(true);
        this.flowKey = false;
      }
      n += yield* this.pushIndicators();
      switch (line[n]) {
        case void 0:
          return "flow";
        case "#":
          yield* this.pushCount(line.length - n);
          return "flow";
        case "{":
        case "[":
          yield* this.pushCount(1);
          this.flowKey = false;
          this.flowLevel += 1;
          return "flow";
        case "}":
        case "]":
          yield* this.pushCount(1);
          this.flowKey = true;
          this.flowLevel -= 1;
          return this.flowLevel ? "flow" : "doc";
        case "*":
          yield* this.pushUntil(isNotAnchorChar);
          return "flow";
        case '"':
        case "'":
          this.flowKey = true;
          return yield* this.parseQuotedScalar();
        case ":": {
          const next2 = this.charAt(1);
          if (this.flowKey || isEmpty2(next2) || next2 === ",") {
            this.flowKey = false;
            yield* this.pushCount(1);
            yield* this.pushSpaces(true);
            return "flow";
          }
        }
        default:
          this.flowKey = false;
          return yield* this.parsePlainScalar();
      }
    }
    *parseQuotedScalar() {
      const quote = this.charAt(0);
      let end2 = this.buffer.indexOf(quote, this.pos + 1);
      if (quote === "'") {
        while (end2 !== -1 && this.buffer[end2 + 1] === "'")
          end2 = this.buffer.indexOf("'", end2 + 2);
      } else {
        while (end2 !== -1) {
          let n = 0;
          while (this.buffer[end2 - 1 - n] === "\\")
            n += 1;
          if (n % 2 === 0)
            break;
          end2 = this.buffer.indexOf('"', end2 + 1);
        }
      }
      const qb = this.buffer.substring(0, end2);
      let nl = qb.indexOf("\n", this.pos);
      if (nl !== -1) {
        while (nl !== -1) {
          const cs = this.continueScalar(nl + 1);
          if (cs === -1)
            break;
          nl = qb.indexOf("\n", cs);
        }
        if (nl !== -1) {
          end2 = nl - (qb[nl - 1] === "\r" ? 2 : 1);
        }
      }
      if (end2 === -1) {
        if (!this.atEnd)
          return this.setNext("quoted-scalar");
        end2 = this.buffer.length;
      }
      yield* this.pushToIndex(end2 + 1, false);
      return this.flowLevel ? "flow" : "doc";
    }
    *parseBlockScalarHeader() {
      this.blockScalarIndent = -1;
      this.blockScalarKeep = false;
      let i = this.pos;
      while (true) {
        const ch = this.buffer[++i];
        if (ch === "+")
          this.blockScalarKeep = true;
        else if (ch > "0" && ch <= "9")
          this.blockScalarIndent = Number(ch) - 1;
        else if (ch !== "-")
          break;
      }
      return yield* this.pushUntil((ch) => isEmpty2(ch) || ch === "#");
    }
    *parseBlockScalar() {
      let nl = this.pos - 1;
      let indent = 0;
      let ch;
      loop: for (let i2 = this.pos; ch = this.buffer[i2]; ++i2) {
        switch (ch) {
          case " ":
            indent += 1;
            break;
          case "\n":
            nl = i2;
            indent = 0;
            break;
          case "\r": {
            const next2 = this.buffer[i2 + 1];
            if (!next2 && !this.atEnd)
              return this.setNext("block-scalar");
            if (next2 === "\n")
              break;
          }
          default:
            break loop;
        }
      }
      if (!ch && !this.atEnd)
        return this.setNext("block-scalar");
      if (indent >= this.indentNext) {
        if (this.blockScalarIndent === -1)
          this.indentNext = indent;
        else {
          this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
        }
        do {
          const cs = this.continueScalar(nl + 1);
          if (cs === -1)
            break;
          nl = this.buffer.indexOf("\n", cs);
        } while (nl !== -1);
        if (nl === -1) {
          if (!this.atEnd)
            return this.setNext("block-scalar");
          nl = this.buffer.length;
        }
      }
      let i = nl + 1;
      ch = this.buffer[i];
      while (ch === " ")
        ch = this.buffer[++i];
      if (ch === "	") {
        while (ch === "	" || ch === " " || ch === "\r" || ch === "\n")
          ch = this.buffer[++i];
        nl = i - 1;
      } else if (!this.blockScalarKeep) {
        do {
          let i2 = nl - 1;
          let ch2 = this.buffer[i2];
          if (ch2 === "\r")
            ch2 = this.buffer[--i2];
          const lastChar = i2;
          while (ch2 === " ")
            ch2 = this.buffer[--i2];
          if (ch2 === "\n" && i2 >= this.pos && i2 + 1 + indent > lastChar)
            nl = i2;
          else
            break;
        } while (true);
      }
      yield SCALAR2;
      yield* this.pushToIndex(nl + 1, true);
      return yield* this.parseLineStart();
    }
    *parsePlainScalar() {
      const inFlow = this.flowLevel > 0;
      let end2 = this.pos - 1;
      let i = this.pos - 1;
      let ch;
      while (ch = this.buffer[++i]) {
        if (ch === ":") {
          const next2 = this.buffer[i + 1];
          if (isEmpty2(next2) || inFlow && flowIndicatorChars.has(next2))
            break;
          end2 = i;
        } else if (isEmpty2(ch)) {
          let next2 = this.buffer[i + 1];
          if (ch === "\r") {
            if (next2 === "\n") {
              i += 1;
              ch = "\n";
              next2 = this.buffer[i + 1];
            } else
              end2 = i;
          }
          if (next2 === "#" || inFlow && flowIndicatorChars.has(next2))
            break;
          if (ch === "\n") {
            const cs = this.continueScalar(i + 1);
            if (cs === -1)
              break;
            i = Math.max(i, cs - 2);
          }
        } else {
          if (inFlow && flowIndicatorChars.has(ch))
            break;
          end2 = i;
        }
      }
      if (!ch && !this.atEnd)
        return this.setNext("plain-scalar");
      yield SCALAR2;
      yield* this.pushToIndex(end2 + 1, true);
      return inFlow ? "flow" : "doc";
    }
    *pushCount(n) {
      if (n > 0) {
        yield this.buffer.substr(this.pos, n);
        this.pos += n;
        return n;
      }
      return 0;
    }
    *pushToIndex(i, allowEmpty) {
      const s = this.buffer.slice(this.pos, i);
      if (s) {
        yield s;
        this.pos += s.length;
        return s.length;
      } else if (allowEmpty)
        yield "";
      return 0;
    }
    *pushIndicators() {
      switch (this.charAt(0)) {
        case "!":
          return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        case "&":
          return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        case "-":
        case "?":
        case ":": {
          const inFlow = this.flowLevel > 0;
          const ch1 = this.charAt(1);
          if (isEmpty2(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
            if (!inFlow)
              this.indentNext = this.indentValue + 1;
            else if (this.flowKey)
              this.flowKey = false;
            return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          }
        }
      }
      return 0;
    }
    *pushTag() {
      if (this.charAt(1) === "<") {
        let i = this.pos + 2;
        let ch = this.buffer[i];
        while (!isEmpty2(ch) && ch !== ">")
          ch = this.buffer[++i];
        return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
      } else {
        let i = this.pos + 1;
        let ch = this.buffer[i];
        while (ch) {
          if (tagChars.has(ch))
            ch = this.buffer[++i];
          else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
            ch = this.buffer[i += 3];
          } else
            break;
        }
        return yield* this.pushToIndex(i, false);
      }
    }
    *pushNewline() {
      const ch = this.buffer[this.pos];
      if (ch === "\n")
        return yield* this.pushCount(1);
      else if (ch === "\r" && this.charAt(1) === "\n")
        return yield* this.pushCount(2);
      else
        return 0;
    }
    *pushSpaces(allowTabs) {
      let i = this.pos - 1;
      let ch;
      do {
        ch = this.buffer[++i];
      } while (ch === " " || allowTabs && ch === "	");
      const n = i - this.pos;
      if (n > 0) {
        yield this.buffer.substr(this.pos, n);
        this.pos = i;
      }
      return n;
    }
    *pushUntil(test2) {
      let i = this.pos;
      let ch = this.buffer[i];
      while (!test2(ch))
        ch = this.buffer[++i];
      return yield* this.pushToIndex(i, false);
    }
  };

  // node_modules/yaml/browser/dist/parse/line-counter.js
  var LineCounter = class {
    constructor() {
      this.lineStarts = [];
      this.addNewLine = (offset) => this.lineStarts.push(offset);
      this.linePos = (offset) => {
        let low = 0;
        let high = this.lineStarts.length;
        while (low < high) {
          const mid = low + high >> 1;
          if (this.lineStarts[mid] < offset)
            low = mid + 1;
          else
            high = mid;
        }
        if (this.lineStarts[low] === offset)
          return { line: low + 1, col: 1 };
        if (low === 0)
          return { line: 0, col: offset };
        const start2 = this.lineStarts[low - 1];
        return { line: low, col: offset - start2 + 1 };
      };
    }
  };

  // node_modules/yaml/browser/dist/parse/parser.js
  function includesToken(list2, type2) {
    for (let i = 0; i < list2.length; ++i)
      if (list2[i].type === type2)
        return true;
    return false;
  }
  function findNonEmptyIndex(list2) {
    for (let i = 0; i < list2.length; ++i) {
      switch (list2[i].type) {
        case "space":
        case "comment":
        case "newline":
          break;
        default:
          return i;
      }
    }
    return -1;
  }
  function isFlowToken(token) {
    switch (token?.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
      case "flow-collection":
        return true;
      default:
        return false;
    }
  }
  function getPrevProps(parent2) {
    switch (parent2.type) {
      case "document":
        return parent2.start;
      case "block-map": {
        const it2 = parent2.items[parent2.items.length - 1];
        return it2.sep ?? it2.start;
      }
      case "block-seq":
        return parent2.items[parent2.items.length - 1].start;
      default:
        return [];
    }
  }
  function getFirstKeyStartProps(prev2) {
    if (prev2.length === 0)
      return [];
    let i = prev2.length;
    loop: while (--i >= 0) {
      switch (prev2[i].type) {
        case "doc-start":
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
        case "newline":
          break loop;
      }
    }
    while (prev2[++i]?.type === "space") {
    }
    return prev2.splice(i, prev2.length);
  }
  function fixFlowSeqItems(fc) {
    if (fc.start.type === "flow-seq-start") {
      for (const it2 of fc.items) {
        if (it2.sep && !it2.value && !includesToken(it2.start, "explicit-key-ind") && !includesToken(it2.sep, "map-value-ind")) {
          if (it2.key)
            it2.value = it2.key;
          delete it2.key;
          if (isFlowToken(it2.value)) {
            if (it2.value.end)
              Array.prototype.push.apply(it2.value.end, it2.sep);
            else
              it2.value.end = it2.sep;
          } else
            Array.prototype.push.apply(it2.start, it2.sep);
          delete it2.sep;
        }
      }
    }
  }
  var Parser2 = class {
    /**
     * @param onNewLine - If defined, called separately with the start position of
     *   each new line (in `parse()`, including the start of input).
     */
    constructor(onNewLine) {
      this.atNewLine = true;
      this.atScalar = false;
      this.indent = 0;
      this.offset = 0;
      this.onKeyLine = false;
      this.stack = [];
      this.source = "";
      this.type = "";
      this.lexer = new Lexer();
      this.onNewLine = onNewLine;
    }
    /**
     * Parse `source` as a YAML stream.
     * If `incomplete`, a part of the last line may be left as a buffer for the next call.
     *
     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
     *
     * @returns A generator of tokens representing each directive, document, and other structure.
     */
    *parse(source, incomplete = false) {
      if (this.onNewLine && this.offset === 0)
        this.onNewLine(0);
      for (const lexeme of this.lexer.lex(source, incomplete))
        yield* this.next(lexeme);
      if (!incomplete)
        yield* this.end();
    }
    /**
     * Advance the parser by the `source` of one lexical token.
     */
    *next(source) {
      this.source = source;
      if (this.atScalar) {
        this.atScalar = false;
        yield* this.step();
        this.offset += source.length;
        return;
      }
      const type2 = tokenType(source);
      if (!type2) {
        const message = `Not a YAML token: ${source}`;
        yield* this.pop({ type: "error", offset: this.offset, message, source });
        this.offset += source.length;
      } else if (type2 === "scalar") {
        this.atNewLine = false;
        this.atScalar = true;
        this.type = "scalar";
      } else {
        this.type = type2;
        yield* this.step();
        switch (type2) {
          case "newline":
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine)
              this.onNewLine(this.offset + source.length);
            break;
          case "space":
            if (this.atNewLine && source[0] === " ")
              this.indent += source.length;
            break;
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
            if (this.atNewLine)
              this.indent += source.length;
            break;
          case "doc-mode":
          case "flow-error-end":
            return;
          default:
            this.atNewLine = false;
        }
        this.offset += source.length;
      }
    }
    /** Call at end of input to push out any remaining constructions */
    *end() {
      while (this.stack.length > 0)
        yield* this.pop();
    }
    get sourceToken() {
      const st = {
        type: this.type,
        offset: this.offset,
        indent: this.indent,
        source: this.source
      };
      return st;
    }
    *step() {
      const top = this.peek(1);
      if (this.type === "doc-end" && top?.type !== "doc-end") {
        while (this.stack.length > 0)
          yield* this.pop();
        this.stack.push({
          type: "doc-end",
          offset: this.offset,
          source: this.source
        });
        return;
      }
      if (!top)
        return yield* this.stream();
      switch (top.type) {
        case "document":
          return yield* this.document(top);
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return yield* this.scalar(top);
        case "block-scalar":
          return yield* this.blockScalar(top);
        case "block-map":
          return yield* this.blockMap(top);
        case "block-seq":
          return yield* this.blockSequence(top);
        case "flow-collection":
          return yield* this.flowCollection(top);
        case "doc-end":
          return yield* this.documentEnd(top);
      }
      yield* this.pop();
    }
    peek(n) {
      return this.stack[this.stack.length - n];
    }
    *pop(error2) {
      const token = error2 ?? this.stack.pop();
      if (!token) {
        const message = "Tried to pop an empty stack";
        yield { type: "error", offset: this.offset, source: "", message };
      } else if (this.stack.length === 0) {
        yield token;
      } else {
        const top = this.peek(1);
        if (token.type === "block-scalar") {
          token.indent = "indent" in top ? top.indent : 0;
        } else if (token.type === "flow-collection" && top.type === "document") {
          token.indent = 0;
        }
        if (token.type === "flow-collection")
          fixFlowSeqItems(token);
        switch (top.type) {
          case "document":
            top.value = token;
            break;
          case "block-scalar":
            top.props.push(token);
            break;
          case "block-map": {
            const it2 = top.items[top.items.length - 1];
            if (it2.value) {
              top.items.push({ start: [], key: token, sep: [] });
              this.onKeyLine = true;
              return;
            } else if (it2.sep) {
              it2.value = token;
            } else {
              Object.assign(it2, { key: token, sep: [] });
              this.onKeyLine = !it2.explicitKey;
              return;
            }
            break;
          }
          case "block-seq": {
            const it2 = top.items[top.items.length - 1];
            if (it2.value)
              top.items.push({ start: [], value: token });
            else
              it2.value = token;
            break;
          }
          case "flow-collection": {
            const it2 = top.items[top.items.length - 1];
            if (!it2 || it2.value)
              top.items.push({ start: [], key: token, sep: [] });
            else if (it2.sep)
              it2.value = token;
            else
              Object.assign(it2, { key: token, sep: [] });
            return;
          }
          default:
            yield* this.pop();
            yield* this.pop(token);
        }
        if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
          const last2 = token.items[token.items.length - 1];
          if (last2 && !last2.sep && !last2.value && last2.start.length > 0 && findNonEmptyIndex(last2.start) === -1 && (token.indent === 0 || last2.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
            if (top.type === "document")
              top.end = last2.start;
            else
              top.items.push({ start: last2.start });
            token.items.splice(-1, 1);
          }
        }
      }
    }
    *stream() {
      switch (this.type) {
        case "directive-line":
          yield { type: "directive", offset: this.offset, source: this.source };
          return;
        case "byte-order-mark":
        case "space":
        case "comment":
        case "newline":
          yield this.sourceToken;
          return;
        case "doc-mode":
        case "doc-start": {
          const doc = {
            type: "document",
            offset: this.offset,
            start: []
          };
          if (this.type === "doc-start")
            doc.start.push(this.sourceToken);
          this.stack.push(doc);
          return;
        }
      }
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML stream`,
        source: this.source
      };
    }
    *document(doc) {
      if (doc.value)
        return yield* this.lineEnd(doc);
      switch (this.type) {
        case "doc-start": {
          if (findNonEmptyIndex(doc.start) !== -1) {
            yield* this.pop();
            yield* this.step();
          } else
            doc.start.push(this.sourceToken);
          return;
        }
        case "anchor":
        case "tag":
        case "space":
        case "comment":
        case "newline":
          doc.start.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(doc);
      if (bv)
        this.stack.push(bv);
      else {
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML document`,
          source: this.source
        };
      }
    }
    *scalar(scalar) {
      if (this.type === "map-value-ind") {
        const prev2 = getPrevProps(this.peek(2));
        const start2 = getFirstKeyStartProps(prev2);
        let sep;
        if (scalar.end) {
          sep = scalar.end;
          sep.push(this.sourceToken);
          delete scalar.end;
        } else
          sep = [this.sourceToken];
        const map4 = {
          type: "block-map",
          offset: scalar.offset,
          indent: scalar.indent,
          items: [{ start: start2, key: scalar, sep }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map4;
      } else
        yield* this.lineEnd(scalar);
    }
    *blockScalar(scalar) {
      switch (this.type) {
        case "space":
        case "comment":
        case "newline":
          scalar.props.push(this.sourceToken);
          return;
        case "scalar":
          scalar.source = this.source;
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine) {
            let nl = this.source.indexOf("\n") + 1;
            while (nl !== 0) {
              this.onNewLine(this.offset + nl);
              nl = this.source.indexOf("\n", nl) + 1;
            }
          }
          yield* this.pop();
          break;
        default:
          yield* this.pop();
          yield* this.step();
      }
    }
    *blockMap(map4) {
      const it2 = map4.items[map4.items.length - 1];
      switch (this.type) {
        case "newline":
          this.onKeyLine = false;
          if (it2.value) {
            const end2 = "end" in it2.value ? it2.value.end : void 0;
            const last2 = Array.isArray(end2) ? end2[end2.length - 1] : void 0;
            if (last2?.type === "comment")
              end2?.push(this.sourceToken);
            else
              map4.items.push({ start: [this.sourceToken] });
          } else if (it2.sep) {
            it2.sep.push(this.sourceToken);
          } else {
            it2.start.push(this.sourceToken);
          }
          return;
        case "space":
        case "comment":
          if (it2.value) {
            map4.items.push({ start: [this.sourceToken] });
          } else if (it2.sep) {
            it2.sep.push(this.sourceToken);
          } else {
            if (this.atIndentedComment(it2.start, map4.indent)) {
              const prev2 = map4.items[map4.items.length - 2];
              const end2 = prev2?.value?.end;
              if (Array.isArray(end2)) {
                Array.prototype.push.apply(end2, it2.start);
                end2.push(this.sourceToken);
                map4.items.pop();
                return;
              }
            }
            it2.start.push(this.sourceToken);
          }
          return;
      }
      if (this.indent >= map4.indent) {
        const atMapIndent = !this.onKeyLine && this.indent === map4.indent;
        const atNextItem = atMapIndent && (it2.sep || it2.explicitKey) && this.type !== "seq-item-ind";
        let start2 = [];
        if (atNextItem && it2.sep && !it2.value) {
          const nl = [];
          for (let i = 0; i < it2.sep.length; ++i) {
            const st = it2.sep[i];
            switch (st.type) {
              case "newline":
                nl.push(i);
                break;
              case "space":
                break;
              case "comment":
                if (st.indent > map4.indent)
                  nl.length = 0;
                break;
              default:
                nl.length = 0;
            }
          }
          if (nl.length >= 2)
            start2 = it2.sep.splice(nl[1]);
        }
        switch (this.type) {
          case "anchor":
          case "tag":
            if (atNextItem || it2.value) {
              start2.push(this.sourceToken);
              map4.items.push({ start: start2 });
              this.onKeyLine = true;
            } else if (it2.sep) {
              it2.sep.push(this.sourceToken);
            } else {
              it2.start.push(this.sourceToken);
            }
            return;
          case "explicit-key-ind":
            if (!it2.sep && !it2.explicitKey) {
              it2.start.push(this.sourceToken);
              it2.explicitKey = true;
            } else if (atNextItem || it2.value) {
              start2.push(this.sourceToken);
              map4.items.push({ start: start2, explicitKey: true });
            } else {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [this.sourceToken], explicitKey: true }]
              });
            }
            this.onKeyLine = true;
            return;
          case "map-value-ind":
            if (it2.explicitKey) {
              if (!it2.sep) {
                if (includesToken(it2.start, "newline")) {
                  Object.assign(it2, { key: null, sep: [this.sourceToken] });
                } else {
                  const start3 = getFirstKeyStartProps(it2.start);
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start3, key: null, sep: [this.sourceToken] }]
                  });
                }
              } else if (it2.value) {
                map4.items.push({ start: [], key: null, sep: [this.sourceToken] });
              } else if (includesToken(it2.sep, "map-value-ind")) {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                });
              } else if (isFlowToken(it2.key) && !includesToken(it2.sep, "newline")) {
                const start3 = getFirstKeyStartProps(it2.start);
                const key = it2.key;
                const sep = it2.sep;
                sep.push(this.sourceToken);
                delete it2.key;
                delete it2.sep;
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start3, key, sep }]
                });
              } else if (start2.length > 0) {
                it2.sep = it2.sep.concat(start2, this.sourceToken);
              } else {
                it2.sep.push(this.sourceToken);
              }
            } else {
              if (!it2.sep) {
                Object.assign(it2, { key: null, sep: [this.sourceToken] });
              } else if (it2.value || atNextItem) {
                map4.items.push({ start: start2, key: null, sep: [this.sourceToken] });
              } else if (includesToken(it2.sep, "map-value-ind")) {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [], key: null, sep: [this.sourceToken] }]
                });
              } else {
                it2.sep.push(this.sourceToken);
              }
            }
            this.onKeyLine = true;
            return;
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar": {
            const fs = this.flowScalar(this.type);
            if (atNextItem || it2.value) {
              map4.items.push({ start: start2, key: fs, sep: [] });
              this.onKeyLine = true;
            } else if (it2.sep) {
              this.stack.push(fs);
            } else {
              Object.assign(it2, { key: fs, sep: [] });
              this.onKeyLine = true;
            }
            return;
          }
          default: {
            const bv = this.startBlockValue(map4);
            if (bv) {
              if (bv.type === "block-seq") {
                if (!it2.explicitKey && it2.sep && !includesToken(it2.sep, "newline")) {
                  yield* this.pop({
                    type: "error",
                    offset: this.offset,
                    message: "Unexpected block-seq-ind on same line with key",
                    source: this.source
                  });
                  return;
                }
              } else if (atMapIndent) {
                map4.items.push({ start: start2 });
              }
              this.stack.push(bv);
              return;
            }
          }
        }
      }
      yield* this.pop();
      yield* this.step();
    }
    *blockSequence(seq2) {
      const it2 = seq2.items[seq2.items.length - 1];
      switch (this.type) {
        case "newline":
          if (it2.value) {
            const end2 = "end" in it2.value ? it2.value.end : void 0;
            const last2 = Array.isArray(end2) ? end2[end2.length - 1] : void 0;
            if (last2?.type === "comment")
              end2?.push(this.sourceToken);
            else
              seq2.items.push({ start: [this.sourceToken] });
          } else
            it2.start.push(this.sourceToken);
          return;
        case "space":
        case "comment":
          if (it2.value)
            seq2.items.push({ start: [this.sourceToken] });
          else {
            if (this.atIndentedComment(it2.start, seq2.indent)) {
              const prev2 = seq2.items[seq2.items.length - 2];
              const end2 = prev2?.value?.end;
              if (Array.isArray(end2)) {
                Array.prototype.push.apply(end2, it2.start);
                end2.push(this.sourceToken);
                seq2.items.pop();
                return;
              }
            }
            it2.start.push(this.sourceToken);
          }
          return;
        case "anchor":
        case "tag":
          if (it2.value || this.indent <= seq2.indent)
            break;
          it2.start.push(this.sourceToken);
          return;
        case "seq-item-ind":
          if (this.indent !== seq2.indent)
            break;
          if (it2.value || includesToken(it2.start, "seq-item-ind"))
            seq2.items.push({ start: [this.sourceToken] });
          else
            it2.start.push(this.sourceToken);
          return;
      }
      if (this.indent > seq2.indent) {
        const bv = this.startBlockValue(seq2);
        if (bv) {
          this.stack.push(bv);
          return;
        }
      }
      yield* this.pop();
      yield* this.step();
    }
    *flowCollection(fc) {
      const it2 = fc.items[fc.items.length - 1];
      if (this.type === "flow-error-end") {
        let top;
        do {
          yield* this.pop();
          top = this.peek(1);
        } while (top?.type === "flow-collection");
      } else if (fc.end.length === 0) {
        switch (this.type) {
          case "comma":
          case "explicit-key-ind":
            if (!it2 || it2.sep)
              fc.items.push({ start: [this.sourceToken] });
            else
              it2.start.push(this.sourceToken);
            return;
          case "map-value-ind":
            if (!it2 || it2.value)
              fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
            else if (it2.sep)
              it2.sep.push(this.sourceToken);
            else
              Object.assign(it2, { key: null, sep: [this.sourceToken] });
            return;
          case "space":
          case "comment":
          case "newline":
          case "anchor":
          case "tag":
            if (!it2 || it2.value)
              fc.items.push({ start: [this.sourceToken] });
            else if (it2.sep)
              it2.sep.push(this.sourceToken);
            else
              it2.start.push(this.sourceToken);
            return;
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar": {
            const fs = this.flowScalar(this.type);
            if (!it2 || it2.value)
              fc.items.push({ start: [], key: fs, sep: [] });
            else if (it2.sep)
              this.stack.push(fs);
            else
              Object.assign(it2, { key: fs, sep: [] });
            return;
          }
          case "flow-map-end":
          case "flow-seq-end":
            fc.end.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(fc);
        if (bv)
          this.stack.push(bv);
        else {
          yield* this.pop();
          yield* this.step();
        }
      } else {
        const parent2 = this.peek(2);
        if (parent2.type === "block-map" && (this.type === "map-value-ind" && parent2.indent === fc.indent || this.type === "newline" && !parent2.items[parent2.items.length - 1].sep)) {
          yield* this.pop();
          yield* this.step();
        } else if (this.type === "map-value-ind" && parent2.type !== "flow-collection") {
          const prev2 = getPrevProps(parent2);
          const start2 = getFirstKeyStartProps(prev2);
          fixFlowSeqItems(fc);
          const sep = fc.end.splice(1, fc.end.length);
          sep.push(this.sourceToken);
          const map4 = {
            type: "block-map",
            offset: fc.offset,
            indent: fc.indent,
            items: [{ start: start2, key: fc, sep }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map4;
        } else {
          yield* this.lineEnd(fc);
        }
      }
    }
    flowScalar(type2) {
      if (this.onNewLine) {
        let nl = this.source.indexOf("\n") + 1;
        while (nl !== 0) {
          this.onNewLine(this.offset + nl);
          nl = this.source.indexOf("\n", nl) + 1;
        }
      }
      return {
        type: type2,
        offset: this.offset,
        indent: this.indent,
        source: this.source
      };
    }
    startBlockValue(parent2) {
      switch (this.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return this.flowScalar(this.type);
        case "block-scalar-header":
          return {
            type: "block-scalar",
            offset: this.offset,
            indent: this.indent,
            props: [this.sourceToken],
            source: ""
          };
        case "flow-map-start":
        case "flow-seq-start":
          return {
            type: "flow-collection",
            offset: this.offset,
            indent: this.indent,
            start: this.sourceToken,
            items: [],
            end: []
          };
        case "seq-item-ind":
          return {
            type: "block-seq",
            offset: this.offset,
            indent: this.indent,
            items: [{ start: [this.sourceToken] }]
          };
        case "explicit-key-ind": {
          this.onKeyLine = true;
          const prev2 = getPrevProps(parent2);
          const start2 = getFirstKeyStartProps(prev2);
          start2.push(this.sourceToken);
          return {
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start: start2, explicitKey: true }]
          };
        }
        case "map-value-ind": {
          this.onKeyLine = true;
          const prev2 = getPrevProps(parent2);
          const start2 = getFirstKeyStartProps(prev2);
          return {
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start: start2, key: null, sep: [this.sourceToken] }]
          };
        }
      }
      return null;
    }
    atIndentedComment(start2, indent) {
      if (this.type !== "comment")
        return false;
      if (this.indent <= indent)
        return false;
      return start2.every((st) => st.type === "newline" || st.type === "space");
    }
    *documentEnd(docEnd) {
      if (this.type !== "doc-mode") {
        if (docEnd.end)
          docEnd.end.push(this.sourceToken);
        else
          docEnd.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
      }
    }
    *lineEnd(token) {
      switch (this.type) {
        case "comma":
        case "doc-start":
        case "doc-end":
        case "flow-seq-end":
        case "flow-map-end":
        case "map-value-ind":
          yield* this.pop();
          yield* this.step();
          break;
        case "newline":
          this.onKeyLine = false;
        case "space":
        case "comment":
        default:
          if (token.end)
            token.end.push(this.sourceToken);
          else
            token.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
      }
    }
  };

  // node_modules/yaml/browser/dist/public-api.js
  function parseOptions(options) {
    const prettyErrors = options.prettyErrors !== false;
    const lineCounter = options.lineCounter || prettyErrors && new LineCounter() || null;
    return { lineCounter, prettyErrors };
  }
  function parseDocument2(source, options = {}) {
    const { lineCounter, prettyErrors } = parseOptions(options);
    const parser = new Parser2(lineCounter?.addNewLine);
    const composer = new Composer(options);
    let doc = null;
    for (const _doc of composer.compose(parser.parse(source), true, source.length)) {
      if (!doc)
        doc = _doc;
      else if (doc.options.logLevel !== "silent") {
        doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
        break;
      }
    }
    if (prettyErrors && lineCounter) {
      doc.errors.forEach(prettifyError(source, lineCounter));
      doc.warnings.forEach(prettifyError(source, lineCounter));
    }
    return doc;
  }
  function parse2(src, reviver, options) {
    let _reviver = void 0;
    if (typeof reviver === "function") {
      _reviver = reviver;
    } else if (options === void 0 && reviver && typeof reviver === "object") {
      options = reviver;
    }
    const doc = parseDocument2(src, options);
    if (!doc)
      return null;
    doc.warnings.forEach((warning) => warn(doc.options.logLevel, warning));
    if (doc.errors.length > 0) {
      if (doc.options.logLevel !== "silent")
        throw doc.errors[0];
      else
        doc.errors = [];
    }
    return doc.toJS(Object.assign({ reviver: _reviver }, options));
  }

  // node_modules/markmap-lib/dist/browser/index.mjs
  var import_markdown_it_katex = __toESM(require_dist(), 1);
  function initializeMarkdownIt() {
    const md = lib_default({
      html: true,
      breaks: true
    });
    md.use(ins_plugin).use(ins_plugin2).use(sub_plugin).use(sup_plugin);
    return md;
  }
  function createTransformHooks(transformer2) {
    return {
      transformer: transformer2,
      parser: new Hook(),
      beforeParse: new Hook(),
      afterParse: new Hook(),
      retransform: new Hook()
    };
  }
  function definePlugin(plugin2) {
    return plugin2;
  }
  var svgMarked = '<svg width="16" height="16" viewBox="0 -3 24 24"><path d="M19 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2m-9 14-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8z"/></svg>\n';
  var svgUnmarked = '<svg width="16" height="16" viewBox="0 -3 24 24"><path fill-rule="evenodd" d="M6 5a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1zM3 6a3 3 0 0 1 3-3h12a3 3 0 0 1 3 3v12a3 3 0 0 1-3 3H6a3 3 0 0 1-3-3v-5z" clip-rule="evenodd"/></svg>\n';
  var name$5 = "checkbox";
  var images = {
    " ": svgUnmarked.trim(),
    x: svgMarked.trim()
  };
  var plugin$3 = definePlugin({
    name: name$5,
    transform(transformHooks) {
      transformHooks.parser.tap((md) => {
        md.core.ruler.before("inline", "checkbox", (state) => {
          for (let i = 2; i < state.tokens.length; i += 1) {
            const token = state.tokens[i];
            if (token.type === "inline" && token.content) {
              const prevType = state.tokens[i - 1].type;
              const prevPrevType = state.tokens[i - 2].type;
              if (prevType === "heading_open" || prevType === "paragraph_open" && prevPrevType === "list_item_open") {
                token.content = token.content.replace(
                  /^\[(.)\] /,
                  (m, g) => images[g] ? `${images[g]} ` : m
                );
              }
            }
          }
          return false;
        });
      });
      return {};
    }
  });
  var name$4 = "frontmatter";
  var pluginFrontmatter = definePlugin({
    name: name$4,
    transform(transformHooks) {
      transformHooks.beforeParse.tap((_md, context) => {
        var _a3;
        const { content } = context;
        if (!/^---\r?\n/.test(content)) return;
        const match2 = /\n---\r?\n/.exec(content);
        if (!match2) return;
        const raw = content.slice(4, match2.index).trimEnd();
        let frontmatter;
        try {
          frontmatter = parse2(raw.replace(/\r?\n|\r/g, "\n"));
          if (frontmatter == null ? void 0 : frontmatter.markmap) {
            frontmatter.markmap = normalizeMarkmapJsonOptions(
              frontmatter.markmap
            );
          }
        } catch {
          return;
        }
        context.frontmatter = frontmatter;
        context.parserOptions = {
          ...context.parserOptions,
          ...(_a3 = frontmatter == null ? void 0 : frontmatter.markmap) == null ? void 0 : _a3.htmlParser
        };
        context.frontmatterInfo = {
          lines: content.slice(0, match2.index).split("\n").length + 1,
          offset: match2.index + match2[0].length
        };
      });
      return {};
    }
  });
  function normalizeMarkmapJsonOptions(options) {
    if (!options) return;
    ["color", "extraJs", "extraCss"].forEach((key) => {
      if (options[key] != null) options[key] = normalizeStringArray(options[key]);
    });
    ["duration", "maxWidth", "initialExpandLevel"].forEach((key) => {
      if (options[key] != null) options[key] = normalizeNumber(options[key]);
    });
    return options;
  }
  function normalizeStringArray(value) {
    let result;
    if (typeof value === "string") result = [value];
    else if (Array.isArray(value))
      result = value.filter((item) => item && typeof item === "string");
    return (result == null ? void 0 : result.length) ? result : void 0;
  }
  function normalizeNumber(value) {
    if (isNaN(+value)) return;
    return +value;
  }
  function patchJSItem(urlBuilder2, item) {
    if (item.type === "script" && item.data.src) {
      return {
        ...item,
        data: {
          ...item.data,
          src: urlBuilder2.getFullUrl(item.data.src)
        }
      };
    }
    return item;
  }
  function patchCSSItem(urlBuilder2, item) {
    if (item.type === "stylesheet" && item.data.href) {
      return {
        ...item,
        data: {
          ...item.data,
          href: urlBuilder2.getFullUrl(item.data.href)
        }
      };
    }
    return item;
  }
  var name$3 = "hljs";
  var preloadScripts$1 = [
    `@highlightjs/cdn-assets@${"11.11.1"}/highlight.min.js`
  ].map((path2) => buildJSItem(path2));
  var styles$1 = [
    `@highlightjs/cdn-assets@${"11.11.1"}/styles/default.min.css`
  ].map((path2) => buildCSSItem(path2));
  var config$1 = {
    versions: {
      hljs: "11.11.1"
    },
    preloadScripts: preloadScripts$1,
    styles: styles$1
  };
  var plugin$2 = definePlugin({
    name: name$3,
    config: config$1,
    transform(transformHooks) {
      var _a3, _b, _c;
      let loading;
      const preloadScripts2 = ((_b = (_a3 = plugin$2.config) == null ? void 0 : _a3.preloadScripts) == null ? void 0 : _b.map(
        (item) => patchJSItem(transformHooks.transformer.urlBuilder, item)
      )) || [];
      const autoload = () => {
        loading || (loading = loadJS(preloadScripts2));
        return loading;
      };
      let enableFeature = noop;
      transformHooks.parser.tap((md) => {
        md.set({
          highlight: (str, language) => {
            enableFeature();
            const { hljs } = window;
            if (hljs) {
              return hljs.highlightAuto(str, language ? [language] : void 0).value;
            }
            autoload().then(() => {
              transformHooks.retransform.call();
            });
            return str;
          }
        });
      });
      transformHooks.beforeParse.tap((_2, context) => {
        enableFeature = () => {
          context.features[name$3] = true;
        };
      });
      return {
        styles: (_c = plugin$2.config) == null ? void 0 : _c.styles
      };
    }
  });
  function addDefaultVersions(paths, name2, version) {
    return paths.map((path2) => {
      if (typeof path2 === "string" && !path2.includes("://")) {
        if (!path2.startsWith("npm:")) {
          path2 = `npm:${path2}`;
        }
        const prefixLength = 4 + name2.length;
        if (path2.startsWith(`npm:${name2}/`)) {
          path2 = `${path2.slice(0, prefixLength)}@${version}${path2.slice(
            prefixLength
          )}`;
        }
      }
      return path2;
    });
  }
  var define_define_KATEX_RESOURCES_default = ["katex@0.16.18/dist/fonts/KaTeX_AMS-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Caligraphic-Bold.woff2", "katex@0.16.18/dist/fonts/KaTeX_Caligraphic-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Fraktur-Bold.woff2", "katex@0.16.18/dist/fonts/KaTeX_Fraktur-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Main-Bold.woff2", "katex@0.16.18/dist/fonts/KaTeX_Main-BoldItalic.woff2", "katex@0.16.18/dist/fonts/KaTeX_Main-Italic.woff2", "katex@0.16.18/dist/fonts/KaTeX_Main-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Math-BoldItalic.woff2", "katex@0.16.18/dist/fonts/KaTeX_Math-Italic.woff2", "katex@0.16.18/dist/fonts/KaTeX_SansSerif-Bold.woff2", "katex@0.16.18/dist/fonts/KaTeX_SansSerif-Italic.woff2", "katex@0.16.18/dist/fonts/KaTeX_SansSerif-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Script-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Size1-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Size2-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Size3-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Size4-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Typewriter-Regular.woff2"];
  var name$2 = "katex";
  var preloadScripts = [
    `katex@${"0.16.18"}/dist/katex.min.js`
  ].map((path2) => buildJSItem(path2));
  var webfontloader = buildJSItem(
    `webfontloader@${"1.6.28"}/webfontloader.js`
  );
  webfontloader.data.defer = true;
  var styles = [`katex@${"0.16.18"}/dist/katex.min.css`].map(
    (path2) => buildCSSItem(path2)
  );
  var config2 = {
    versions: {
      katex: "0.16.18",
      webfontloader: "1.6.28"
    },
    preloadScripts,
    scripts: [
      {
        type: "iife",
        data: {
          fn: (getMarkmap) => {
            window.WebFontConfig = {
              custom: {
                families: [
                  "KaTeX_AMS",
                  "KaTeX_Caligraphic:n4,n7",
                  "KaTeX_Fraktur:n4,n7",
                  "KaTeX_Main:n4,n7,i4,i7",
                  "KaTeX_Math:i4,i7",
                  "KaTeX_Script",
                  "KaTeX_SansSerif:n4,n7,i4",
                  "KaTeX_Size1",
                  "KaTeX_Size2",
                  "KaTeX_Size3",
                  "KaTeX_Size4",
                  "KaTeX_Typewriter"
                ]
              },
              active: () => {
                getMarkmap().refreshHook.call();
              }
            };
          },
          getParams({ getMarkmap }) {
            return [getMarkmap];
          }
        }
      },
      webfontloader
    ],
    styles,
    resources: define_define_KATEX_RESOURCES_default
  };
  function interop(mod) {
    return mod.default || mod;
  }
  var katexPlugin = interop(import_markdown_it_katex.default);
  var plugin$1 = definePlugin({
    name: name$2,
    config: config2,
    transform(transformHooks) {
      var _a3, _b, _c, _d;
      let loading;
      const preloadScripts2 = ((_b = (_a3 = plugin$1.config) == null ? void 0 : _a3.preloadScripts) == null ? void 0 : _b.map(
        (item) => patchJSItem(transformHooks.transformer.urlBuilder, item)
      )) || [];
      const autoload = () => {
        loading || (loading = loadJS(preloadScripts2));
        return loading;
      };
      const renderKatex = (source, displayMode) => {
        const { katex } = window;
        if (katex) {
          return katex.renderToString(source, {
            displayMode,
            throwOnError: false
          });
        }
        autoload().then(() => {
          transformHooks.retransform.call();
        });
        return source;
      };
      let enableFeature = noop;
      transformHooks.parser.tap((md) => {
        md.use(katexPlugin);
        ["math_block", "math_inline"].forEach((key) => {
          const fn = (tokens, idx) => {
            enableFeature();
            const result = renderKatex(tokens[idx].content, !!tokens[idx].block);
            return result;
          };
          md.renderer.rules[key] = fn;
        });
      });
      transformHooks.beforeParse.tap((_2, context) => {
        enableFeature = () => {
          context.features[name$2] = true;
        };
      });
      transformHooks.afterParse.tap((_2, context) => {
        var _a22;
        const markmap = (_a22 = context.frontmatter) == null ? void 0 : _a22.markmap;
        if (markmap) {
          ["extraJs", "extraCss"].forEach((key) => {
            var _a32, _b2;
            const value = markmap[key];
            if (value) {
              markmap[key] = addDefaultVersions(
                value,
                name$2,
                ((_b2 = (_a32 = plugin$1.config) == null ? void 0 : _a32.versions) == null ? void 0 : _b2.katex) || ""
              );
            }
          });
        }
      });
      return {
        styles: (_c = plugin$1.config) == null ? void 0 : _c.styles,
        scripts: (_d = plugin$1.config) == null ? void 0 : _d.scripts
      };
    }
  });
  var name$1 = "npmUrl";
  var pluginNpmUrl = definePlugin({
    name: name$1,
    transform(transformHooks) {
      transformHooks.afterParse.tap((_2, context) => {
        const { frontmatter } = context;
        const markmap = frontmatter == null ? void 0 : frontmatter.markmap;
        if (markmap) {
          ["extraJs", "extraCss"].forEach((key) => {
            const value = markmap[key];
            if (value) {
              markmap[key] = value.map((path2) => {
                if (path2.startsWith("npm:")) {
                  return transformHooks.transformer.urlBuilder.getFullUrl(
                    path2.slice(4)
                  );
                }
                return path2;
              });
            }
          });
        }
      });
      return {};
    }
  });
  var name = "sourceLines";
  var plugin = definePlugin({
    name,
    transform(transformHooks) {
      let frontmatterLines = 0;
      transformHooks.beforeParse.tap((_md, context) => {
        var _a3;
        frontmatterLines = ((_a3 = context.frontmatterInfo) == null ? void 0 : _a3.lines) || 0;
      });
      transformHooks.parser.tap((md) => {
        md.renderer.renderAttrs = wrapFunction(
          md.renderer.renderAttrs,
          (renderAttrs2, token) => {
            if (token.block && token.map) {
              const lineRange = token.map.map((line) => line + frontmatterLines);
              token.attrSet("data-lines", lineRange.join(","));
            }
            return renderAttrs2(token);
          }
        );
        if (md.renderer.rules.fence) {
          md.renderer.rules.fence = wrapFunction(
            md.renderer.rules.fence,
            (fence2, tokens, idx, ...rest) => {
              let result = fence2(tokens, idx, ...rest);
              const token = tokens[idx];
              if (result.startsWith("<pre>") && token.map) {
                const lineRange = token.map.map(
                  (line) => line + frontmatterLines
                );
                result = result.slice(0, 4) + ` data-lines="${lineRange.join(",")}"` + result.slice(4);
              }
              return result;
            }
          );
        }
      });
      return {};
    }
  });
  var plugins = [
    pluginFrontmatter,
    plugin$1,
    plugin$2,
    pluginNpmUrl,
    plugin$3,
    plugin
  ];
  var builtInPlugins = plugins;
  function cleanNode(node) {
    while (!node.content && node.children.length === 1) {
      node = node.children[0];
    }
    while (node.children.length === 1 && !node.children[0].content) {
      node = {
        ...node,
        children: node.children[0].children
      };
    }
    return {
      ...node,
      children: node.children.map(cleanNode)
    };
  }
  var Transformer = class {
    constructor(plugins2 = builtInPlugins) {
      this.assetsMap = {};
      this.urlBuilder = new UrlBuilder();
      this.hooks = createTransformHooks(this);
      this.plugins = plugins2.map(
        (plugin2) => typeof plugin2 === "function" ? plugin2() : plugin2
      );
      const assetsMap = {};
      for (const { name: name2, transform: transform2 } of this.plugins) {
        assetsMap[name2] = transform2(this.hooks);
      }
      this.assetsMap = assetsMap;
      const md = initializeMarkdownIt();
      this.md = md;
      this.hooks.parser.call(md);
    }
    transform(content, fallbackParserOptions) {
      var _a3;
      const context = {
        content,
        features: {},
        parserOptions: fallbackParserOptions
      };
      this.hooks.beforeParse.call(this.md, context);
      let { content: rawContent } = context;
      if (context.frontmatterInfo)
        rawContent = rawContent.slice(context.frontmatterInfo.offset);
      const html2 = this.md.render(rawContent, {});
      this.hooks.afterParse.call(this.md, context);
      const root3 = cleanNode(buildTree(html2, context.parserOptions));
      root3.content || (root3.content = `${((_a3 = context.frontmatter) == null ? void 0 : _a3.title) || ""}`);
      return { ...context, root: root3 };
    }
    resolveJS(item) {
      return patchJSItem(this.urlBuilder, item);
    }
    resolveCSS(item) {
      return patchCSSItem(this.urlBuilder, item);
    }
    /**
     * Get all assets from enabled plugins or filter them by plugin names as keys.
     */
    getAssets(keys) {
      const styles2 = [];
      const scripts = [];
      keys ?? (keys = this.plugins.map((plugin2) => plugin2.name));
      for (const assets of keys.map((key) => this.assetsMap[key])) {
        if (assets) {
          if (assets.styles) styles2.push(...assets.styles);
          if (assets.scripts) scripts.push(...assets.scripts);
        }
      }
      return {
        styles: styles2.map((item) => this.resolveCSS(item)),
        scripts: scripts.map((item) => this.resolveJS(item))
      };
    }
    /**
     * Get used assets by features object returned by `transform`.
     */
    getUsedAssets(features) {
      const keys = this.plugins.map((plugin2) => plugin2.name).filter((name2) => features[name2]);
      return this.getAssets(keys);
    }
  };

  // node_modules/internmap/src/index.js
  var InternMap = class extends Map {
    constructor(entries, key = keyof) {
      super();
      Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
      if (entries != null) for (const [key2, value] of entries) this.set(key2, value);
    }
    get(key) {
      return super.get(intern_get(this, key));
    }
    has(key) {
      return super.has(intern_get(this, key));
    }
    set(key, value) {
      return super.set(intern_set(this, key), value);
    }
    delete(key) {
      return super.delete(intern_delete(this, key));
    }
  };
  function intern_get({ _intern, _key }, value) {
    const key = _key(value);
    return _intern.has(key) ? _intern.get(key) : value;
  }
  function intern_set({ _intern, _key }, value) {
    const key = _key(value);
    if (_intern.has(key)) return _intern.get(key);
    _intern.set(key, value);
    return value;
  }
  function intern_delete({ _intern, _key }, value) {
    const key = _key(value);
    if (_intern.has(key)) {
      value = _intern.get(key);
      _intern.delete(key);
    }
    return value;
  }
  function keyof(value) {
    return value !== null && typeof value === "object" ? value.valueOf() : value;
  }

  // node_modules/d3-array/src/max.js
  function max(values, valueof) {
    let max3;
    if (valueof === void 0) {
      for (const value of values) {
        if (value != null && (max3 < value || max3 === void 0 && value >= value)) {
          max3 = value;
        }
      }
    } else {
      let index2 = -1;
      for (let value of values) {
        if ((value = valueof(value, ++index2, values)) != null && (max3 < value || max3 === void 0 && value >= value)) {
          max3 = value;
        }
      }
    }
    return max3;
  }

  // node_modules/d3-array/src/min.js
  function min(values, valueof) {
    let min3;
    if (valueof === void 0) {
      for (const value of values) {
        if (value != null && (min3 > value || min3 === void 0 && value >= value)) {
          min3 = value;
        }
      }
    } else {
      let index2 = -1;
      for (let value of values) {
        if ((value = valueof(value, ++index2, values)) != null && (min3 > value || min3 === void 0 && value >= value)) {
          min3 = value;
        }
      }
    }
    return min3;
  }

  // node_modules/d3-array/src/minIndex.js
  function minIndex(values, valueof) {
    let min3;
    let minIndex2 = -1;
    let index2 = -1;
    if (valueof === void 0) {
      for (const value of values) {
        ++index2;
        if (value != null && (min3 > value || min3 === void 0 && value >= value)) {
          min3 = value, minIndex2 = index2;
        }
      }
    } else {
      for (let value of values) {
        if ((value = valueof(value, ++index2, values)) != null && (min3 > value || min3 === void 0 && value >= value)) {
          min3 = value, minIndex2 = index2;
        }
      }
    }
    return minIndex2;
  }

  // node_modules/d3-dispatch/src/dispatch.js
  var noop2 = { value: () => {
  } };
  function dispatch() {
    for (var i = 0, n = arguments.length, _2 = {}, t; i < n; ++i) {
      if (!(t = arguments[i] + "") || t in _2 || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
      _2[t] = [];
    }
    return new Dispatch(_2);
  }
  function Dispatch(_2) {
    this._ = _2;
  }
  function parseTypenames(typenames, types) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name2 = "", i = t.indexOf(".");
      if (i >= 0) name2 = t.slice(i + 1), t = t.slice(0, i);
      if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
      return { type: t, name: name2 };
    });
  }
  Dispatch.prototype = dispatch.prototype = {
    constructor: Dispatch,
    on: function(typename, callback) {
      var _2 = this._, T2 = parseTypenames(typename + "", _2), t, i = -1, n = T2.length;
      if (arguments.length < 2) {
        while (++i < n) if ((t = (typename = T2[i]).type) && (t = get2(_2[t], typename.name))) return t;
        return;
      }
      if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
      while (++i < n) {
        if (t = (typename = T2[i]).type) _2[t] = set3(_2[t], typename.name, callback);
        else if (callback == null) for (t in _2) _2[t] = set3(_2[t], typename.name, null);
      }
      return this;
    },
    copy: function() {
      var copy = {}, _2 = this._;
      for (var t in _2) copy[t] = _2[t].slice();
      return new Dispatch(copy);
    },
    call: function(type2, that) {
      if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
      if (!this._.hasOwnProperty(type2)) throw new Error("unknown type: " + type2);
      for (t = this._[type2], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
    },
    apply: function(type2, that, args) {
      if (!this._.hasOwnProperty(type2)) throw new Error("unknown type: " + type2);
      for (var t = this._[type2], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
    }
  };
  function get2(type2, name2) {
    for (var i = 0, n = type2.length, c; i < n; ++i) {
      if ((c = type2[i]).name === name2) {
        return c.value;
      }
    }
  }
  function set3(type2, name2, callback) {
    for (var i = 0, n = type2.length; i < n; ++i) {
      if (type2[i].name === name2) {
        type2[i] = noop2, type2 = type2.slice(0, i).concat(type2.slice(i + 1));
        break;
      }
    }
    if (callback != null) type2.push({ name: name2, value: callback });
    return type2;
  }
  var dispatch_default = dispatch;

  // node_modules/d3-selection/src/namespaces.js
  var xhtml = "http://www.w3.org/1999/xhtml";
  var namespaces_default = {
    svg: "http://www.w3.org/2000/svg",
    xhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };

  // node_modules/d3-selection/src/namespace.js
  function namespace_default(name2) {
    var prefix = name2 += "", i = prefix.indexOf(":");
    if (i >= 0 && (prefix = name2.slice(0, i)) !== "xmlns") name2 = name2.slice(i + 1);
    return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name2 } : name2;
  }

  // node_modules/d3-selection/src/creator.js
  function creatorInherit(name2) {
    return function() {
      var document2 = this.ownerDocument, uri = this.namespaceURI;
      return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name2) : document2.createElementNS(uri, name2);
    };
  }
  function creatorFixed(fullname) {
    return function() {
      return this.ownerDocument.createElementNS(fullname.space, fullname.local);
    };
  }
  function creator_default(name2) {
    var fullname = namespace_default(name2);
    return (fullname.local ? creatorFixed : creatorInherit)(fullname);
  }

  // node_modules/d3-selection/src/selector.js
  function none() {
  }
  function selector_default(selector) {
    return selector == null ? none : function() {
      return this.querySelector(selector);
    };
  }

  // node_modules/d3-selection/src/selection/select.js
  function select_default(select2) {
    if (typeof select2 !== "function") select2 = selector_default(select2);
    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j2 = 0; j2 < m; ++j2) {
      for (var group = groups[j2], n = group.length, subgroup = subgroups[j2] = new Array(n), node, subnode, i = 0; i < n; ++i) {
        if ((node = group[i]) && (subnode = select2.call(node, node.__data__, i, group))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          subgroup[i] = subnode;
        }
      }
    }
    return new Selection(subgroups, this._parents);
  }

  // node_modules/d3-selection/src/array.js
  function array(x2) {
    return x2 == null ? [] : Array.isArray(x2) ? x2 : Array.from(x2);
  }

  // node_modules/d3-selection/src/selectorAll.js
  function empty2() {
    return [];
  }
  function selectorAll_default(selector) {
    return selector == null ? empty2 : function() {
      return this.querySelectorAll(selector);
    };
  }

  // node_modules/d3-selection/src/selection/selectAll.js
  function arrayAll(select2) {
    return function() {
      return array(select2.apply(this, arguments));
    };
  }
  function selectAll_default(select2) {
    if (typeof select2 === "function") select2 = arrayAll(select2);
    else select2 = selectorAll_default(select2);
    for (var groups = this._groups, m = groups.length, subgroups = [], parents2 = [], j2 = 0; j2 < m; ++j2) {
      for (var group = groups[j2], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          subgroups.push(select2.call(node, node.__data__, i, group));
          parents2.push(node);
        }
      }
    }
    return new Selection(subgroups, parents2);
  }

  // node_modules/d3-selection/src/matcher.js
  function matcher_default(selector) {
    return function() {
      return this.matches(selector);
    };
  }
  function childMatcher(selector) {
    return function(node) {
      return node.matches(selector);
    };
  }

  // node_modules/d3-selection/src/selection/selectChild.js
  var find2 = Array.prototype.find;
  function childFind(match2) {
    return function() {
      return find2.call(this.children, match2);
    };
  }
  function childFirst() {
    return this.firstElementChild;
  }
  function selectChild_default(match2) {
    return this.select(match2 == null ? childFirst : childFind(typeof match2 === "function" ? match2 : childMatcher(match2)));
  }

  // node_modules/d3-selection/src/selection/selectChildren.js
  var filter2 = Array.prototype.filter;
  function children2() {
    return Array.from(this.children);
  }
  function childrenFilter(match2) {
    return function() {
      return filter2.call(this.children, match2);
    };
  }
  function selectChildren_default(match2) {
    return this.selectAll(match2 == null ? children2 : childrenFilter(typeof match2 === "function" ? match2 : childMatcher(match2)));
  }

  // node_modules/d3-selection/src/selection/filter.js
  function filter_default(match2) {
    if (typeof match2 !== "function") match2 = matcher_default(match2);
    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j2 = 0; j2 < m; ++j2) {
      for (var group = groups[j2], n = group.length, subgroup = subgroups[j2] = [], node, i = 0; i < n; ++i) {
        if ((node = group[i]) && match2.call(node, node.__data__, i, group)) {
          subgroup.push(node);
        }
      }
    }
    return new Selection(subgroups, this._parents);
  }

  // node_modules/d3-selection/src/selection/sparse.js
  function sparse_default(update2) {
    return new Array(update2.length);
  }

  // node_modules/d3-selection/src/selection/enter.js
  function enter_default() {
    return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
  }
  function EnterNode(parent2, datum2) {
    this.ownerDocument = parent2.ownerDocument;
    this.namespaceURI = parent2.namespaceURI;
    this._next = null;
    this._parent = parent2;
    this.__data__ = datum2;
  }
  EnterNode.prototype = {
    constructor: EnterNode,
    appendChild: function(child) {
      return this._parent.insertBefore(child, this._next);
    },
    insertBefore: function(child, next2) {
      return this._parent.insertBefore(child, next2);
    },
    querySelector: function(selector) {
      return this._parent.querySelector(selector);
    },
    querySelectorAll: function(selector) {
      return this._parent.querySelectorAll(selector);
    }
  };

  // node_modules/d3-selection/src/constant.js
  function constant_default(x2) {
    return function() {
      return x2;
    };
  }

  // node_modules/d3-selection/src/selection/data.js
  function bindIndex(parent2, group, enter, update2, exit, data2) {
    var i = 0, node, groupLength = group.length, dataLength = data2.length;
    for (; i < dataLength; ++i) {
      if (node = group[i]) {
        node.__data__ = data2[i];
        update2[i] = node;
      } else {
        enter[i] = new EnterNode(parent2, data2[i]);
      }
    }
    for (; i < groupLength; ++i) {
      if (node = group[i]) {
        exit[i] = node;
      }
    }
  }
  function bindKey(parent2, group, enter, update2, exit, data2, key) {
    var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data2.length, keyValues = new Array(groupLength), keyValue;
    for (i = 0; i < groupLength; ++i) {
      if (node = group[i]) {
        keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
        if (nodeByKeyValue.has(keyValue)) {
          exit[i] = node;
        } else {
          nodeByKeyValue.set(keyValue, node);
        }
      }
    }
    for (i = 0; i < dataLength; ++i) {
      keyValue = key.call(parent2, data2[i], i, data2) + "";
      if (node = nodeByKeyValue.get(keyValue)) {
        update2[i] = node;
        node.__data__ = data2[i];
        nodeByKeyValue.delete(keyValue);
      } else {
        enter[i] = new EnterNode(parent2, data2[i]);
      }
    }
    for (i = 0; i < groupLength; ++i) {
      if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
        exit[i] = node;
      }
    }
  }
  function datum(node) {
    return node.__data__;
  }
  function data_default(value, key) {
    if (!arguments.length) return Array.from(this, datum);
    var bind = key ? bindKey : bindIndex, parents2 = this._parents, groups = this._groups;
    if (typeof value !== "function") value = constant_default(value);
    for (var m = groups.length, update2 = new Array(m), enter = new Array(m), exit = new Array(m), j2 = 0; j2 < m; ++j2) {
      var parent2 = parents2[j2], group = groups[j2], groupLength = group.length, data2 = arraylike(value.call(parent2, parent2 && parent2.__data__, j2, parents2)), dataLength = data2.length, enterGroup = enter[j2] = new Array(dataLength), updateGroup = update2[j2] = new Array(dataLength), exitGroup = exit[j2] = new Array(groupLength);
      bind(parent2, group, enterGroup, updateGroup, exitGroup, data2, key);
      for (var i0 = 0, i1 = 0, previous, next2; i0 < dataLength; ++i0) {
        if (previous = enterGroup[i0]) {
          if (i0 >= i1) i1 = i0 + 1;
          while (!(next2 = updateGroup[i1]) && ++i1 < dataLength) ;
          previous._next = next2 || null;
        }
      }
    }
    update2 = new Selection(update2, parents2);
    update2._enter = enter;
    update2._exit = exit;
    return update2;
  }
  function arraylike(data2) {
    return typeof data2 === "object" && "length" in data2 ? data2 : Array.from(data2);
  }

  // node_modules/d3-selection/src/selection/exit.js
  function exit_default() {
    return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
  }

  // node_modules/d3-selection/src/selection/join.js
  function join_default(onenter, onupdate, onexit) {
    var enter = this.enter(), update2 = this, exit = this.exit();
    if (typeof onenter === "function") {
      enter = onenter(enter);
      if (enter) enter = enter.selection();
    } else {
      enter = enter.append(onenter + "");
    }
    if (onupdate != null) {
      update2 = onupdate(update2);
      if (update2) update2 = update2.selection();
    }
    if (onexit == null) exit.remove();
    else onexit(exit);
    return enter && update2 ? enter.merge(update2).order() : update2;
  }

  // node_modules/d3-selection/src/selection/merge.js
  function merge_default(context) {
    var selection2 = context.selection ? context.selection() : context;
    for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j2 = 0; j2 < m; ++j2) {
      for (var group0 = groups0[j2], group1 = groups1[j2], n = group0.length, merge3 = merges[j2] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group0[i] || group1[i]) {
          merge3[i] = node;
        }
      }
    }
    for (; j2 < m0; ++j2) {
      merges[j2] = groups0[j2];
    }
    return new Selection(merges, this._parents);
  }

  // node_modules/d3-selection/src/selection/order.js
  function order_default() {
    for (var groups = this._groups, j2 = -1, m = groups.length; ++j2 < m; ) {
      for (var group = groups[j2], i = group.length - 1, next2 = group[i], node; --i >= 0; ) {
        if (node = group[i]) {
          if (next2 && node.compareDocumentPosition(next2) ^ 4) next2.parentNode.insertBefore(node, next2);
          next2 = node;
        }
      }
    }
    return this;
  }

  // node_modules/d3-selection/src/selection/sort.js
  function sort_default(compare) {
    if (!compare) compare = ascending;
    function compareNode(a, b) {
      return a && b ? compare(a.__data__, b.__data__) : !a - !b;
    }
    for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j2 = 0; j2 < m; ++j2) {
      for (var group = groups[j2], n = group.length, sortgroup = sortgroups[j2] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          sortgroup[i] = node;
        }
      }
      sortgroup.sort(compareNode);
    }
    return new Selection(sortgroups, this._parents).order();
  }
  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  // node_modules/d3-selection/src/selection/call.js
  function call_default() {
    var callback = arguments[0];
    arguments[0] = this;
    callback.apply(null, arguments);
    return this;
  }

  // node_modules/d3-selection/src/selection/nodes.js
  function nodes_default() {
    return Array.from(this);
  }

  // node_modules/d3-selection/src/selection/node.js
  function node_default() {
    for (var groups = this._groups, j2 = 0, m = groups.length; j2 < m; ++j2) {
      for (var group = groups[j2], i = 0, n = group.length; i < n; ++i) {
        var node = group[i];
        if (node) return node;
      }
    }
    return null;
  }

  // node_modules/d3-selection/src/selection/size.js
  function size_default() {
    let size = 0;
    for (const node of this) ++size;
    return size;
  }

  // node_modules/d3-selection/src/selection/empty.js
  function empty_default() {
    return !this.node();
  }

  // node_modules/d3-selection/src/selection/each.js
  function each_default(callback) {
    for (var groups = this._groups, j2 = 0, m = groups.length; j2 < m; ++j2) {
      for (var group = groups[j2], i = 0, n = group.length, node; i < n; ++i) {
        if (node = group[i]) callback.call(node, node.__data__, i, group);
      }
    }
    return this;
  }

  // node_modules/d3-selection/src/selection/attr.js
  function attrRemove(name2) {
    return function() {
      this.removeAttribute(name2);
    };
  }
  function attrRemoveNS(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }
  function attrConstant(name2, value) {
    return function() {
      this.setAttribute(name2, value);
    };
  }
  function attrConstantNS(fullname, value) {
    return function() {
      this.setAttributeNS(fullname.space, fullname.local, value);
    };
  }
  function attrFunction(name2, value) {
    return function() {
      var v2 = value.apply(this, arguments);
      if (v2 == null) this.removeAttribute(name2);
      else this.setAttribute(name2, v2);
    };
  }
  function attrFunctionNS(fullname, value) {
    return function() {
      var v2 = value.apply(this, arguments);
      if (v2 == null) this.removeAttributeNS(fullname.space, fullname.local);
      else this.setAttributeNS(fullname.space, fullname.local, v2);
    };
  }
  function attr_default(name2, value) {
    var fullname = namespace_default(name2);
    if (arguments.length < 2) {
      var node = this.node();
      return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
    }
    return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
  }

  // node_modules/d3-selection/src/window.js
  function window_default(node) {
    return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
  }

  // node_modules/d3-selection/src/selection/style.js
  function styleRemove(name2) {
    return function() {
      this.style.removeProperty(name2);
    };
  }
  function styleConstant(name2, value, priority) {
    return function() {
      this.style.setProperty(name2, value, priority);
    };
  }
  function styleFunction(name2, value, priority) {
    return function() {
      var v2 = value.apply(this, arguments);
      if (v2 == null) this.style.removeProperty(name2);
      else this.style.setProperty(name2, v2, priority);
    };
  }
  function style_default(name2, value, priority) {
    return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name2, value, priority == null ? "" : priority)) : styleValue(this.node(), name2);
  }
  function styleValue(node, name2) {
    return node.style.getPropertyValue(name2) || window_default(node).getComputedStyle(node, null).getPropertyValue(name2);
  }

  // node_modules/d3-selection/src/selection/property.js
  function propertyRemove(name2) {
    return function() {
      delete this[name2];
    };
  }
  function propertyConstant(name2, value) {
    return function() {
      this[name2] = value;
    };
  }
  function propertyFunction(name2, value) {
    return function() {
      var v2 = value.apply(this, arguments);
      if (v2 == null) delete this[name2];
      else this[name2] = v2;
    };
  }
  function property_default(name2, value) {
    return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name2, value)) : this.node()[name2];
  }

  // node_modules/d3-selection/src/selection/classed.js
  function classArray(string2) {
    return string2.trim().split(/^|\s+/);
  }
  function classList(node) {
    return node.classList || new ClassList(node);
  }
  function ClassList(node) {
    this._node = node;
    this._names = classArray(node.getAttribute("class") || "");
  }
  ClassList.prototype = {
    add: function(name2) {
      var i = this._names.indexOf(name2);
      if (i < 0) {
        this._names.push(name2);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    remove: function(name2) {
      var i = this._names.indexOf(name2);
      if (i >= 0) {
        this._names.splice(i, 1);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    contains: function(name2) {
      return this._names.indexOf(name2) >= 0;
    }
  };
  function classedAdd(node, names) {
    var list2 = classList(node), i = -1, n = names.length;
    while (++i < n) list2.add(names[i]);
  }
  function classedRemove(node, names) {
    var list2 = classList(node), i = -1, n = names.length;
    while (++i < n) list2.remove(names[i]);
  }
  function classedTrue(names) {
    return function() {
      classedAdd(this, names);
    };
  }
  function classedFalse(names) {
    return function() {
      classedRemove(this, names);
    };
  }
  function classedFunction(names, value) {
    return function() {
      (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
    };
  }
  function classed_default(name2, value) {
    var names = classArray(name2 + "");
    if (arguments.length < 2) {
      var list2 = classList(this.node()), i = -1, n = names.length;
      while (++i < n) if (!list2.contains(names[i])) return false;
      return true;
    }
    return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
  }

  // node_modules/d3-selection/src/selection/text.js
  function textRemove() {
    this.textContent = "";
  }
  function textConstant(value) {
    return function() {
      this.textContent = value;
    };
  }
  function textFunction(value) {
    return function() {
      var v2 = value.apply(this, arguments);
      this.textContent = v2 == null ? "" : v2;
    };
  }
  function text_default(value) {
    return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
  }

  // node_modules/d3-selection/src/selection/html.js
  function htmlRemove() {
    this.innerHTML = "";
  }
  function htmlConstant(value) {
    return function() {
      this.innerHTML = value;
    };
  }
  function htmlFunction(value) {
    return function() {
      var v2 = value.apply(this, arguments);
      this.innerHTML = v2 == null ? "" : v2;
    };
  }
  function html_default(value) {
    return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
  }

  // node_modules/d3-selection/src/selection/raise.js
  function raise() {
    if (this.nextSibling) this.parentNode.appendChild(this);
  }
  function raise_default() {
    return this.each(raise);
  }

  // node_modules/d3-selection/src/selection/lower.js
  function lower() {
    if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }
  function lower_default() {
    return this.each(lower);
  }

  // node_modules/d3-selection/src/selection/append.js
  function append_default(name2) {
    var create2 = typeof name2 === "function" ? name2 : creator_default(name2);
    return this.select(function() {
      return this.appendChild(create2.apply(this, arguments));
    });
  }

  // node_modules/d3-selection/src/selection/insert.js
  function constantNull() {
    return null;
  }
  function insert_default(name2, before2) {
    var create2 = typeof name2 === "function" ? name2 : creator_default(name2), select2 = before2 == null ? constantNull : typeof before2 === "function" ? before2 : selector_default(before2);
    return this.select(function() {
      return this.insertBefore(create2.apply(this, arguments), select2.apply(this, arguments) || null);
    });
  }

  // node_modules/d3-selection/src/selection/remove.js
  function remove2() {
    var parent2 = this.parentNode;
    if (parent2) parent2.removeChild(this);
  }
  function remove_default() {
    return this.each(remove2);
  }

  // node_modules/d3-selection/src/selection/clone.js
  function selection_cloneShallow() {
    var clone2 = this.cloneNode(false), parent2 = this.parentNode;
    return parent2 ? parent2.insertBefore(clone2, this.nextSibling) : clone2;
  }
  function selection_cloneDeep() {
    var clone2 = this.cloneNode(true), parent2 = this.parentNode;
    return parent2 ? parent2.insertBefore(clone2, this.nextSibling) : clone2;
  }
  function clone_default(deep) {
    return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
  }

  // node_modules/d3-selection/src/selection/datum.js
  function datum_default(value) {
    return arguments.length ? this.property("__data__", value) : this.node().__data__;
  }

  // node_modules/d3-selection/src/selection/on.js
  function contextListener(listener) {
    return function(event) {
      listener.call(this, event, this.__data__);
    };
  }
  function parseTypenames2(typenames) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name2 = "", i = t.indexOf(".");
      if (i >= 0) name2 = t.slice(i + 1), t = t.slice(0, i);
      return { type: t, name: name2 };
    });
  }
  function onRemove(typename) {
    return function() {
      var on = this.__on;
      if (!on) return;
      for (var j2 = 0, i = -1, m = on.length, o; j2 < m; ++j2) {
        if (o = on[j2], (!typename.type || o.type === typename.type) && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
        } else {
          on[++i] = o;
        }
      }
      if (++i) on.length = i;
      else delete this.__on;
    };
  }
  function onAdd(typename, value, options) {
    return function() {
      var on = this.__on, o, listener = contextListener(value);
      if (on) for (var j2 = 0, m = on.length; j2 < m; ++j2) {
        if ((o = on[j2]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
          this.addEventListener(o.type, o.listener = listener, o.options = options);
          o.value = value;
          return;
        }
      }
      this.addEventListener(typename.type, listener, options);
      o = { type: typename.type, name: typename.name, value, listener, options };
      if (!on) this.__on = [o];
      else on.push(o);
    };
  }
  function on_default(typename, value, options) {
    var typenames = parseTypenames2(typename + ""), i, n = typenames.length, t;
    if (arguments.length < 2) {
      var on = this.node().__on;
      if (on) for (var j2 = 0, m = on.length, o; j2 < m; ++j2) {
        for (i = 0, o = on[j2]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
      return;
    }
    on = value ? onAdd : onRemove;
    for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
    return this;
  }

  // node_modules/d3-selection/src/selection/dispatch.js
  function dispatchEvent(node, type2, params) {
    var window2 = window_default(node), event = window2.CustomEvent;
    if (typeof event === "function") {
      event = new event(type2, params);
    } else {
      event = window2.document.createEvent("Event");
      if (params) event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;
      else event.initEvent(type2, false, false);
    }
    node.dispatchEvent(event);
  }
  function dispatchConstant(type2, params) {
    return function() {
      return dispatchEvent(this, type2, params);
    };
  }
  function dispatchFunction(type2, params) {
    return function() {
      return dispatchEvent(this, type2, params.apply(this, arguments));
    };
  }
  function dispatch_default2(type2, params) {
    return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
  }

  // node_modules/d3-selection/src/selection/iterator.js
  function* iterator_default() {
    for (var groups = this._groups, j2 = 0, m = groups.length; j2 < m; ++j2) {
      for (var group = groups[j2], i = 0, n = group.length, node; i < n; ++i) {
        if (node = group[i]) yield node;
      }
    }
  }

  // node_modules/d3-selection/src/selection/index.js
  var root2 = [null];
  function Selection(groups, parents2) {
    this._groups = groups;
    this._parents = parents2;
  }
  function selection() {
    return new Selection([[document.documentElement]], root2);
  }
  function selection_selection() {
    return this;
  }
  Selection.prototype = selection.prototype = {
    constructor: Selection,
    select: select_default,
    selectAll: selectAll_default,
    selectChild: selectChild_default,
    selectChildren: selectChildren_default,
    filter: filter_default,
    data: data_default,
    enter: enter_default,
    exit: exit_default,
    join: join_default,
    merge: merge_default,
    selection: selection_selection,
    order: order_default,
    sort: sort_default,
    call: call_default,
    nodes: nodes_default,
    node: node_default,
    size: size_default,
    empty: empty_default,
    each: each_default,
    attr: attr_default,
    style: style_default,
    property: property_default,
    classed: classed_default,
    text: text_default,
    html: html_default,
    raise: raise_default,
    lower: lower_default,
    append: append_default,
    insert: insert_default,
    remove: remove_default,
    clone: clone_default,
    datum: datum_default,
    on: on_default,
    dispatch: dispatch_default2,
    [Symbol.iterator]: iterator_default
  };
  var selection_default = selection;

  // node_modules/d3-selection/src/select.js
  function select_default2(selector) {
    return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root2);
  }

  // node_modules/d3-selection/src/sourceEvent.js
  function sourceEvent_default(event) {
    let sourceEvent;
    while (sourceEvent = event.sourceEvent) event = sourceEvent;
    return event;
  }

  // node_modules/d3-selection/src/pointer.js
  function pointer_default(event, node) {
    event = sourceEvent_default(event);
    if (node === void 0) node = event.currentTarget;
    if (node) {
      var svg = node.ownerSVGElement || node;
      if (svg.createSVGPoint) {
        var point = svg.createSVGPoint();
        point.x = event.clientX, point.y = event.clientY;
        point = point.matrixTransform(node.getScreenCTM().inverse());
        return [point.x, point.y];
      }
      if (node.getBoundingClientRect) {
        var rect = node.getBoundingClientRect();
        return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
      }
    }
    return [event.pageX, event.pageY];
  }

  // node_modules/d3-drag/src/noevent.js
  var nonpassivecapture = { capture: true, passive: false };
  function noevent_default(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
  }

  // node_modules/d3-drag/src/nodrag.js
  function nodrag_default(view) {
    var root3 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", noevent_default, nonpassivecapture);
    if ("onselectstart" in root3) {
      selection2.on("selectstart.drag", noevent_default, nonpassivecapture);
    } else {
      root3.__noselect = root3.style.MozUserSelect;
      root3.style.MozUserSelect = "none";
    }
  }
  function yesdrag(view, noclick) {
    var root3 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", null);
    if (noclick) {
      selection2.on("click.drag", noevent_default, nonpassivecapture);
      setTimeout(function() {
        selection2.on("click.drag", null);
      }, 0);
    }
    if ("onselectstart" in root3) {
      selection2.on("selectstart.drag", null);
    } else {
      root3.style.MozUserSelect = root3.__noselect;
      delete root3.__noselect;
    }
  }

  // node_modules/d3-color/src/define.js
  function define_default(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }
  function extend(parent2, definition) {
    var prototype = Object.create(parent2.prototype);
    for (var key in definition) prototype[key] = definition[key];
    return prototype;
  }

  // node_modules/d3-color/src/color.js
  function Color() {
  }
  var darker = 0.7;
  var brighter = 1 / darker;
  var reI = "\\s*([+-]?\\d+)\\s*";
  var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
  var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
  var reHex = /^#([0-9a-f]{3,8})$/;
  var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
  var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
  var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
  var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
  var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
  var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
  var named = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  define_default(Color, color, {
    copy(channels) {
      return Object.assign(new this.constructor(), this, channels);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: color_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: color_formatHex,
    formatHex8: color_formatHex8,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
  });
  function color_formatHex() {
    return this.rgb().formatHex();
  }
  function color_formatHex8() {
    return this.rgb().formatHex8();
  }
  function color_formatHsl() {
    return hslConvert(this).formatHsl();
  }
  function color_formatRgb() {
    return this.rgb().formatRgb();
  }
  function color(format2) {
    var m, l;
    format2 = (format2 + "").trim().toLowerCase();
    return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
  }
  function rgbn(n) {
    return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
  }
  function rgba(r, g, b, a) {
    if (a <= 0) r = g = b = NaN;
    return new Rgb(r, g, b, a);
  }
  function rgbConvert(o) {
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Rgb();
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
  }
  function rgb(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
  }
  function Rgb(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }
  define_default(Rgb, rgb, extend(Color, {
    brighter(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
    },
    displayable() {
      return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: rgb_formatHex,
    formatHex8: rgb_formatHex8,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
  }));
  function rgb_formatHex() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
  }
  function rgb_formatHex8() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
  }
  function rgb_formatRgb() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
  }
  function clampa(opacity) {
    return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
  }
  function clampi(value) {
    return Math.max(0, Math.min(255, Math.round(value) || 0));
  }
  function hex(value) {
    value = clampi(value);
    return (value < 16 ? "0" : "") + value.toString(16);
  }
  function hsla(h2, s, l, a) {
    if (a <= 0) h2 = s = l = NaN;
    else if (l <= 0 || l >= 1) h2 = s = NaN;
    else if (s <= 0) h2 = NaN;
    return new Hsl(h2, s, l, a);
  }
  function hslConvert(o) {
    if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Hsl();
    if (o instanceof Hsl) return o;
    o = o.rgb();
    var r = o.r / 255, g = o.g / 255, b = o.b / 255, min3 = Math.min(r, g, b), max3 = Math.max(r, g, b), h2 = NaN, s = max3 - min3, l = (max3 + min3) / 2;
    if (s) {
      if (r === max3) h2 = (g - b) / s + (g < b) * 6;
      else if (g === max3) h2 = (b - r) / s + 2;
      else h2 = (r - g) / s + 4;
      s /= l < 0.5 ? max3 + min3 : 2 - max3 - min3;
      h2 *= 60;
    } else {
      s = l > 0 && l < 1 ? 0 : h2;
    }
    return new Hsl(h2, s, l, o.opacity);
  }
  function hsl(h2, s, l, opacity) {
    return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s, l, opacity == null ? 1 : opacity);
  }
  function Hsl(h2, s, l, opacity) {
    this.h = +h2;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }
  define_default(Hsl, hsl, extend(Color, {
    brighter(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    rgb() {
      var h2 = this.h % 360 + (this.h < 0) * 360, s = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
      return new Rgb(
        hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2),
        hsl2rgb(h2, m1, m2),
        hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2),
        this.opacity
      );
    },
    clamp() {
      return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl() {
      const a = clampa(this.opacity);
      return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
    }
  }));
  function clamph(value) {
    value = (value || 0) % 360;
    return value < 0 ? value + 360 : value;
  }
  function clampt(value) {
    return Math.max(0, Math.min(1, value || 0));
  }
  function hsl2rgb(h2, m1, m2) {
    return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
  }

  // node_modules/d3-interpolate/src/basis.js
  function basis(t1, v0, v1, v2, v3) {
    var t2 = t1 * t1, t3 = t2 * t1;
    return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
  }
  function basis_default(values) {
    var n = values.length - 1;
    return function(t) {
      var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
      return basis((t - i / n) * n, v0, v1, v2, v3);
    };
  }

  // node_modules/d3-interpolate/src/basisClosed.js
  function basisClosed_default(values) {
    var n = values.length;
    return function(t) {
      var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
      return basis((t - i / n) * n, v0, v1, v2, v3);
    };
  }

  // node_modules/d3-interpolate/src/constant.js
  var constant_default2 = (x2) => () => x2;

  // node_modules/d3-interpolate/src/color.js
  function linear(a, d) {
    return function(t) {
      return a + t * d;
    };
  }
  function exponential(a, b, y2) {
    return a = Math.pow(a, y2), b = Math.pow(b, y2) - a, y2 = 1 / y2, function(t) {
      return Math.pow(a + t * b, y2);
    };
  }
  function gamma(y2) {
    return (y2 = +y2) === 1 ? nogamma : function(a, b) {
      return b - a ? exponential(a, b, y2) : constant_default2(isNaN(a) ? b : a);
    };
  }
  function nogamma(a, b) {
    var d = b - a;
    return d ? linear(a, d) : constant_default2(isNaN(a) ? b : a);
  }

  // node_modules/d3-interpolate/src/rgb.js
  var rgb_default = function rgbGamma(y2) {
    var color2 = gamma(y2);
    function rgb2(start2, end2) {
      var r = color2((start2 = rgb(start2)).r, (end2 = rgb(end2)).r), g = color2(start2.g, end2.g), b = color2(start2.b, end2.b), opacity = nogamma(start2.opacity, end2.opacity);
      return function(t) {
        start2.r = r(t);
        start2.g = g(t);
        start2.b = b(t);
        start2.opacity = opacity(t);
        return start2 + "";
      };
    }
    rgb2.gamma = rgbGamma;
    return rgb2;
  }(1);
  function rgbSpline(spline) {
    return function(colors) {
      var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
      for (i = 0; i < n; ++i) {
        color2 = rgb(colors[i]);
        r[i] = color2.r || 0;
        g[i] = color2.g || 0;
        b[i] = color2.b || 0;
      }
      r = spline(r);
      g = spline(g);
      b = spline(b);
      color2.opacity = 1;
      return function(t) {
        color2.r = r(t);
        color2.g = g(t);
        color2.b = b(t);
        return color2 + "";
      };
    };
  }
  var rgbBasis = rgbSpline(basis_default);
  var rgbBasisClosed = rgbSpline(basisClosed_default);

  // node_modules/d3-interpolate/src/number.js
  function number_default(a, b) {
    return a = +a, b = +b, function(t) {
      return a * (1 - t) + b * t;
    };
  }

  // node_modules/d3-interpolate/src/string.js
  var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
  var reB = new RegExp(reA.source, "g");
  function zero(b) {
    return function() {
      return b;
    };
  }
  function one(b) {
    return function(t) {
      return b(t) + "";
    };
  }
  function string_default(a, b) {
    var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q2 = [];
    a = a + "", b = b + "";
    while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
      if ((bs = bm.index) > bi) {
        bs = b.slice(bi, bs);
        if (s[i]) s[i] += bs;
        else s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s[i]) s[i] += bm;
        else s[++i] = bm;
      } else {
        s[++i] = null;
        q2.push({ i, x: number_default(am, bm) });
      }
      bi = reB.lastIndex;
    }
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i]) s[i] += bs;
      else s[++i] = bs;
    }
    return s.length < 2 ? q2[0] ? one(q2[0].x) : zero(b) : (b = q2.length, function(t) {
      for (var i2 = 0, o; i2 < b; ++i2) s[(o = q2[i2]).i] = o.x(t);
      return s.join("");
    });
  }

  // node_modules/d3-interpolate/src/transform/decompose.js
  var degrees = 180 / Math.PI;
  var identity = {
    translateX: 0,
    translateY: 0,
    rotate: 0,
    skewX: 0,
    scaleX: 1,
    scaleY: 1
  };
  function decompose_default(a, b, c, d, e, f) {
    var scaleX, scaleY, skewX;
    if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
    if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
    if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
    if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
    return {
      translateX: e,
      translateY: f,
      rotate: Math.atan2(b, a) * degrees,
      skewX: Math.atan(skewX) * degrees,
      scaleX,
      scaleY
    };
  }

  // node_modules/d3-interpolate/src/transform/parse.js
  var svgNode;
  function parseCss(value) {
    const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
    return m.isIdentity ? identity : decompose_default(m.a, m.b, m.c, m.d, m.e, m.f);
  }
  function parseSvg(value) {
    if (value == null) return identity;
    if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
    svgNode.setAttribute("transform", value);
    if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
    value = value.matrix;
    return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
  }

  // node_modules/d3-interpolate/src/transform/index.js
  function interpolateTransform(parse3, pxComma, pxParen, degParen) {
    function pop(s) {
      return s.length ? s.pop() + " " : "";
    }
    function translate(xa, ya, xb, yb, s, q2) {
      if (xa !== xb || ya !== yb) {
        var i = s.push("translate(", null, pxComma, null, pxParen);
        q2.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
      } else if (xb || yb) {
        s.push("translate(" + xb + pxComma + yb + pxParen);
      }
    }
    function rotate(a, b, s, q2) {
      if (a !== b) {
        if (a - b > 180) b += 360;
        else if (b - a > 180) a += 360;
        q2.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number_default(a, b) });
      } else if (b) {
        s.push(pop(s) + "rotate(" + b + degParen);
      }
    }
    function skewX(a, b, s, q2) {
      if (a !== b) {
        q2.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number_default(a, b) });
      } else if (b) {
        s.push(pop(s) + "skewX(" + b + degParen);
      }
    }
    function scale(xa, ya, xb, yb, s, q2) {
      if (xa !== xb || ya !== yb) {
        var i = s.push(pop(s) + "scale(", null, ",", null, ")");
        q2.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
      } else if (xb !== 1 || yb !== 1) {
        s.push(pop(s) + "scale(" + xb + "," + yb + ")");
      }
    }
    return function(a, b) {
      var s = [], q2 = [];
      a = parse3(a), b = parse3(b);
      translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q2);
      rotate(a.rotate, b.rotate, s, q2);
      skewX(a.skewX, b.skewX, s, q2);
      scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q2);
      a = b = null;
      return function(t) {
        var i = -1, n = q2.length, o;
        while (++i < n) s[(o = q2[i]).i] = o.x(t);
        return s.join("");
      };
    };
  }
  var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
  var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

  // node_modules/d3-interpolate/src/zoom.js
  var epsilon2 = 1e-12;
  function cosh(x2) {
    return ((x2 = Math.exp(x2)) + 1 / x2) / 2;
  }
  function sinh(x2) {
    return ((x2 = Math.exp(x2)) - 1 / x2) / 2;
  }
  function tanh(x2) {
    return ((x2 = Math.exp(2 * x2)) - 1) / (x2 + 1);
  }
  var zoom_default = function zoomRho(rho, rho2, rho4) {
    function zoom(p0, p1) {
      var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
      if (d2 < epsilon2) {
        S = Math.log(w1 / w0) / rho;
        i = function(t) {
          return [
            ux0 + t * dx,
            uy0 + t * dy,
            w0 * Math.exp(rho * t * S)
          ];
        };
      } else {
        var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
        S = (r1 - r0) / rho;
        i = function(t) {
          var s = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
          return [
            ux0 + u * dx,
            uy0 + u * dy,
            w0 * coshr0 / cosh(rho * s + r0)
          ];
        };
      }
      i.duration = S * 1e3 * rho / Math.SQRT2;
      return i;
    }
    zoom.rho = function(_2) {
      var _1 = Math.max(1e-3, +_2), _22 = _1 * _1, _4 = _22 * _22;
      return zoomRho(_1, _22, _4);
    };
    return zoom;
  }(Math.SQRT2, 2, 4);

  // node_modules/d3-timer/src/timer.js
  var frame = 0;
  var timeout = 0;
  var interval = 0;
  var pokeDelay = 1e3;
  var taskHead;
  var taskTail;
  var clockLast = 0;
  var clockNow = 0;
  var clockSkew = 0;
  var clock = typeof performance === "object" && performance.now ? performance : Date;
  var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
    setTimeout(f, 17);
  };
  function now() {
    return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
  }
  function clearNow() {
    clockNow = 0;
  }
  function Timer() {
    this._call = this._time = this._next = null;
  }
  Timer.prototype = timer.prototype = {
    constructor: Timer,
    restart: function(callback, delay, time) {
      if (typeof callback !== "function") throw new TypeError("callback is not a function");
      time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
      if (!this._next && taskTail !== this) {
        if (taskTail) taskTail._next = this;
        else taskHead = this;
        taskTail = this;
      }
      this._call = callback;
      this._time = time;
      sleep();
    },
    stop: function() {
      if (this._call) {
        this._call = null;
        this._time = Infinity;
        sleep();
      }
    }
  };
  function timer(callback, delay, time) {
    var t = new Timer();
    t.restart(callback, delay, time);
    return t;
  }
  function timerFlush() {
    now();
    ++frame;
    var t = taskHead, e;
    while (t) {
      if ((e = clockNow - t._time) >= 0) t._call.call(void 0, e);
      t = t._next;
    }
    --frame;
  }
  function wake() {
    clockNow = (clockLast = clock.now()) + clockSkew;
    frame = timeout = 0;
    try {
      timerFlush();
    } finally {
      frame = 0;
      nap();
      clockNow = 0;
    }
  }
  function poke() {
    var now2 = clock.now(), delay = now2 - clockLast;
    if (delay > pokeDelay) clockSkew -= delay, clockLast = now2;
  }
  function nap() {
    var t0, t1 = taskHead, t2, time = Infinity;
    while (t1) {
      if (t1._call) {
        if (time > t1._time) time = t1._time;
        t0 = t1, t1 = t1._next;
      } else {
        t2 = t1._next, t1._next = null;
        t1 = t0 ? t0._next = t2 : taskHead = t2;
      }
    }
    taskTail = t0;
    sleep(time);
  }
  function sleep(time) {
    if (frame) return;
    if (timeout) timeout = clearTimeout(timeout);
    var delay = time - clockNow;
    if (delay > 24) {
      if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
      if (interval) interval = clearInterval(interval);
    } else {
      if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
      frame = 1, setFrame(wake);
    }
  }

  // node_modules/d3-timer/src/timeout.js
  function timeout_default(callback, delay, time) {
    var t = new Timer();
    delay = delay == null ? 0 : +delay;
    t.restart((elapsed) => {
      t.stop();
      callback(elapsed + delay);
    }, delay, time);
    return t;
  }

  // node_modules/d3-transition/src/transition/schedule.js
  var emptyOn = dispatch_default("start", "end", "cancel", "interrupt");
  var emptyTween = [];
  var CREATED = 0;
  var SCHEDULED = 1;
  var STARTING = 2;
  var STARTED = 3;
  var RUNNING = 4;
  var ENDING = 5;
  var ENDED = 6;
  function schedule_default(node, name2, id2, index2, group, timing) {
    var schedules = node.__transition;
    if (!schedules) node.__transition = {};
    else if (id2 in schedules) return;
    create(node, id2, {
      name: name2,
      index: index2,
      // For context during callback.
      group,
      // For context during callback.
      on: emptyOn,
      tween: emptyTween,
      time: timing.time,
      delay: timing.delay,
      duration: timing.duration,
      ease: timing.ease,
      timer: null,
      state: CREATED
    });
  }
  function init(node, id2) {
    var schedule = get3(node, id2);
    if (schedule.state > CREATED) throw new Error("too late; already scheduled");
    return schedule;
  }
  function set4(node, id2) {
    var schedule = get3(node, id2);
    if (schedule.state > STARTED) throw new Error("too late; already running");
    return schedule;
  }
  function get3(node, id2) {
    var schedule = node.__transition;
    if (!schedule || !(schedule = schedule[id2])) throw new Error("transition not found");
    return schedule;
  }
  function create(node, id2, self2) {
    var schedules = node.__transition, tween;
    schedules[id2] = self2;
    self2.timer = timer(schedule, 0, self2.time);
    function schedule(elapsed) {
      self2.state = SCHEDULED;
      self2.timer.restart(start2, self2.delay, self2.time);
      if (self2.delay <= elapsed) start2(elapsed - self2.delay);
    }
    function start2(elapsed) {
      var i, j2, n, o;
      if (self2.state !== SCHEDULED) return stop();
      for (i in schedules) {
        o = schedules[i];
        if (o.name !== self2.name) continue;
        if (o.state === STARTED) return timeout_default(start2);
        if (o.state === RUNNING) {
          o.state = ENDED;
          o.timer.stop();
          o.on.call("interrupt", node, node.__data__, o.index, o.group);
          delete schedules[i];
        } else if (+i < id2) {
          o.state = ENDED;
          o.timer.stop();
          o.on.call("cancel", node, node.__data__, o.index, o.group);
          delete schedules[i];
        }
      }
      timeout_default(function() {
        if (self2.state === STARTED) {
          self2.state = RUNNING;
          self2.timer.restart(tick, self2.delay, self2.time);
          tick(elapsed);
        }
      });
      self2.state = STARTING;
      self2.on.call("start", node, node.__data__, self2.index, self2.group);
      if (self2.state !== STARTING) return;
      self2.state = STARTED;
      tween = new Array(n = self2.tween.length);
      for (i = 0, j2 = -1; i < n; ++i) {
        if (o = self2.tween[i].value.call(node, node.__data__, self2.index, self2.group)) {
          tween[++j2] = o;
        }
      }
      tween.length = j2 + 1;
    }
    function tick(elapsed) {
      var t = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i = -1, n = tween.length;
      while (++i < n) {
        tween[i].call(node, t);
      }
      if (self2.state === ENDING) {
        self2.on.call("end", node, node.__data__, self2.index, self2.group);
        stop();
      }
    }
    function stop() {
      self2.state = ENDED;
      self2.timer.stop();
      delete schedules[id2];
      for (var i in schedules) return;
      delete node.__transition;
    }
  }

  // node_modules/d3-transition/src/interrupt.js
  function interrupt_default(node, name2) {
    var schedules = node.__transition, schedule, active, empty3 = true, i;
    if (!schedules) return;
    name2 = name2 == null ? null : name2 + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).name !== name2) {
        empty3 = false;
        continue;
      }
      active = schedule.state > STARTING && schedule.state < ENDING;
      schedule.state = ENDED;
      schedule.timer.stop();
      schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
      delete schedules[i];
    }
    if (empty3) delete node.__transition;
  }

  // node_modules/d3-transition/src/selection/interrupt.js
  function interrupt_default2(name2) {
    return this.each(function() {
      interrupt_default(this, name2);
    });
  }

  // node_modules/d3-transition/src/transition/tween.js
  function tweenRemove(id2, name2) {
    var tween0, tween1;
    return function() {
      var schedule = set4(this, id2), tween = schedule.tween;
      if (tween !== tween0) {
        tween1 = tween0 = tween;
        for (var i = 0, n = tween1.length; i < n; ++i) {
          if (tween1[i].name === name2) {
            tween1 = tween1.slice();
            tween1.splice(i, 1);
            break;
          }
        }
      }
      schedule.tween = tween1;
    };
  }
  function tweenFunction(id2, name2, value) {
    var tween0, tween1;
    if (typeof value !== "function") throw new Error();
    return function() {
      var schedule = set4(this, id2), tween = schedule.tween;
      if (tween !== tween0) {
        tween1 = (tween0 = tween).slice();
        for (var t = { name: name2, value }, i = 0, n = tween1.length; i < n; ++i) {
          if (tween1[i].name === name2) {
            tween1[i] = t;
            break;
          }
        }
        if (i === n) tween1.push(t);
      }
      schedule.tween = tween1;
    };
  }
  function tween_default(name2, value) {
    var id2 = this._id;
    name2 += "";
    if (arguments.length < 2) {
      var tween = get3(this.node(), id2).tween;
      for (var i = 0, n = tween.length, t; i < n; ++i) {
        if ((t = tween[i]).name === name2) {
          return t.value;
        }
      }
      return null;
    }
    return this.each((value == null ? tweenRemove : tweenFunction)(id2, name2, value));
  }
  function tweenValue(transition2, name2, value) {
    var id2 = transition2._id;
    transition2.each(function() {
      var schedule = set4(this, id2);
      (schedule.value || (schedule.value = {}))[name2] = value.apply(this, arguments);
    });
    return function(node) {
      return get3(node, id2).value[name2];
    };
  }

  // node_modules/d3-transition/src/transition/interpolate.js
  function interpolate_default(a, b) {
    var c;
    return (typeof b === "number" ? number_default : b instanceof color ? rgb_default : (c = color(b)) ? (b = c, rgb_default) : string_default)(a, b);
  }

  // node_modules/d3-transition/src/transition/attr.js
  function attrRemove2(name2) {
    return function() {
      this.removeAttribute(name2);
    };
  }
  function attrRemoveNS2(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }
  function attrConstant2(name2, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = this.getAttribute(name2);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
    };
  }
  function attrConstantNS2(fullname, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = this.getAttributeNS(fullname.space, fullname.local);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
    };
  }
  function attrFunction2(name2, interpolate, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0, value1 = value(this), string1;
      if (value1 == null) return void this.removeAttribute(name2);
      string0 = this.getAttribute(name2);
      string1 = value1 + "";
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }
  function attrFunctionNS2(fullname, interpolate, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0, value1 = value(this), string1;
      if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
      string0 = this.getAttributeNS(fullname.space, fullname.local);
      string1 = value1 + "";
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }
  function attr_default2(name2, value) {
    var fullname = namespace_default(name2), i = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
    return this.attrTween(name2, typeof value === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i, tweenValue(this, "attr." + name2, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i, value));
  }

  // node_modules/d3-transition/src/transition/attrTween.js
  function attrInterpolate(name2, i) {
    return function(t) {
      this.setAttribute(name2, i.call(this, t));
    };
  }
  function attrInterpolateNS(fullname, i) {
    return function(t) {
      this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
    };
  }
  function attrTweenNS(fullname, value) {
    var t0, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
      return t0;
    }
    tween._value = value;
    return tween;
  }
  function attrTween(name2, value) {
    var t0, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0) t0 = (i0 = i) && attrInterpolate(name2, i);
      return t0;
    }
    tween._value = value;
    return tween;
  }
  function attrTween_default(name2, value) {
    var key = "attr." + name2;
    if (arguments.length < 2) return (key = this.tween(key)) && key._value;
    if (value == null) return this.tween(key, null);
    if (typeof value !== "function") throw new Error();
    var fullname = namespace_default(name2);
    return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
  }

  // node_modules/d3-transition/src/transition/delay.js
  function delayFunction(id2, value) {
    return function() {
      init(this, id2).delay = +value.apply(this, arguments);
    };
  }
  function delayConstant(id2, value) {
    return value = +value, function() {
      init(this, id2).delay = value;
    };
  }
  function delay_default(value) {
    var id2 = this._id;
    return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get3(this.node(), id2).delay;
  }

  // node_modules/d3-transition/src/transition/duration.js
  function durationFunction(id2, value) {
    return function() {
      set4(this, id2).duration = +value.apply(this, arguments);
    };
  }
  function durationConstant(id2, value) {
    return value = +value, function() {
      set4(this, id2).duration = value;
    };
  }
  function duration_default(value) {
    var id2 = this._id;
    return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get3(this.node(), id2).duration;
  }

  // node_modules/d3-transition/src/transition/ease.js
  function easeConstant(id2, value) {
    if (typeof value !== "function") throw new Error();
    return function() {
      set4(this, id2).ease = value;
    };
  }
  function ease_default(value) {
    var id2 = this._id;
    return arguments.length ? this.each(easeConstant(id2, value)) : get3(this.node(), id2).ease;
  }

  // node_modules/d3-transition/src/transition/easeVarying.js
  function easeVarying(id2, value) {
    return function() {
      var v2 = value.apply(this, arguments);
      if (typeof v2 !== "function") throw new Error();
      set4(this, id2).ease = v2;
    };
  }
  function easeVarying_default(value) {
    if (typeof value !== "function") throw new Error();
    return this.each(easeVarying(this._id, value));
  }

  // node_modules/d3-transition/src/transition/filter.js
  function filter_default2(match2) {
    if (typeof match2 !== "function") match2 = matcher_default(match2);
    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j2 = 0; j2 < m; ++j2) {
      for (var group = groups[j2], n = group.length, subgroup = subgroups[j2] = [], node, i = 0; i < n; ++i) {
        if ((node = group[i]) && match2.call(node, node.__data__, i, group)) {
          subgroup.push(node);
        }
      }
    }
    return new Transition(subgroups, this._parents, this._name, this._id);
  }

  // node_modules/d3-transition/src/transition/merge.js
  function merge_default2(transition2) {
    if (transition2._id !== this._id) throw new Error();
    for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j2 = 0; j2 < m; ++j2) {
      for (var group0 = groups0[j2], group1 = groups1[j2], n = group0.length, merge3 = merges[j2] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group0[i] || group1[i]) {
          merge3[i] = node;
        }
      }
    }
    for (; j2 < m0; ++j2) {
      merges[j2] = groups0[j2];
    }
    return new Transition(merges, this._parents, this._name, this._id);
  }

  // node_modules/d3-transition/src/transition/on.js
  function start(name2) {
    return (name2 + "").trim().split(/^|\s+/).every(function(t) {
      var i = t.indexOf(".");
      if (i >= 0) t = t.slice(0, i);
      return !t || t === "start";
    });
  }
  function onFunction(id2, name2, listener) {
    var on0, on1, sit = start(name2) ? init : set4;
    return function() {
      var schedule = sit(this, id2), on = schedule.on;
      if (on !== on0) (on1 = (on0 = on).copy()).on(name2, listener);
      schedule.on = on1;
    };
  }
  function on_default2(name2, listener) {
    var id2 = this._id;
    return arguments.length < 2 ? get3(this.node(), id2).on.on(name2) : this.each(onFunction(id2, name2, listener));
  }

  // node_modules/d3-transition/src/transition/remove.js
  function removeFunction(id2) {
    return function() {
      var parent2 = this.parentNode;
      for (var i in this.__transition) if (+i !== id2) return;
      if (parent2) parent2.removeChild(this);
    };
  }
  function remove_default2() {
    return this.on("end.remove", removeFunction(this._id));
  }

  // node_modules/d3-transition/src/transition/select.js
  function select_default3(select2) {
    var name2 = this._name, id2 = this._id;
    if (typeof select2 !== "function") select2 = selector_default(select2);
    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j2 = 0; j2 < m; ++j2) {
      for (var group = groups[j2], n = group.length, subgroup = subgroups[j2] = new Array(n), node, subnode, i = 0; i < n; ++i) {
        if ((node = group[i]) && (subnode = select2.call(node, node.__data__, i, group))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          subgroup[i] = subnode;
          schedule_default(subgroup[i], name2, id2, i, subgroup, get3(node, id2));
        }
      }
    }
    return new Transition(subgroups, this._parents, name2, id2);
  }

  // node_modules/d3-transition/src/transition/selectAll.js
  function selectAll_default2(select2) {
    var name2 = this._name, id2 = this._id;
    if (typeof select2 !== "function") select2 = selectorAll_default(select2);
    for (var groups = this._groups, m = groups.length, subgroups = [], parents2 = [], j2 = 0; j2 < m; ++j2) {
      for (var group = groups[j2], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          for (var children3 = select2.call(node, node.__data__, i, group), child, inherit2 = get3(node, id2), k = 0, l = children3.length; k < l; ++k) {
            if (child = children3[k]) {
              schedule_default(child, name2, id2, k, children3, inherit2);
            }
          }
          subgroups.push(children3);
          parents2.push(node);
        }
      }
    }
    return new Transition(subgroups, parents2, name2, id2);
  }

  // node_modules/d3-transition/src/transition/selection.js
  var Selection2 = selection_default.prototype.constructor;
  function selection_default2() {
    return new Selection2(this._groups, this._parents);
  }

  // node_modules/d3-transition/src/transition/style.js
  function styleNull(name2, interpolate) {
    var string00, string10, interpolate0;
    return function() {
      var string0 = styleValue(this, name2), string1 = (this.style.removeProperty(name2), styleValue(this, name2));
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
    };
  }
  function styleRemove2(name2) {
    return function() {
      this.style.removeProperty(name2);
    };
  }
  function styleConstant2(name2, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = styleValue(this, name2);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
    };
  }
  function styleFunction2(name2, interpolate, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0 = styleValue(this, name2), value1 = value(this), string1 = value1 + "";
      if (value1 == null) string1 = value1 = (this.style.removeProperty(name2), styleValue(this, name2));
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }
  function styleMaybeRemove(id2, name2) {
    var on0, on1, listener0, key = "style." + name2, event = "end." + key, remove3;
    return function() {
      var schedule = set4(this, id2), on = schedule.on, listener = schedule.value[key] == null ? remove3 || (remove3 = styleRemove2(name2)) : void 0;
      if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);
      schedule.on = on1;
    };
  }
  function style_default2(name2, value, priority) {
    var i = (name2 += "") === "transform" ? interpolateTransformCss : interpolate_default;
    return value == null ? this.styleTween(name2, styleNull(name2, i)).on("end.style." + name2, styleRemove2(name2)) : typeof value === "function" ? this.styleTween(name2, styleFunction2(name2, i, tweenValue(this, "style." + name2, value))).each(styleMaybeRemove(this._id, name2)) : this.styleTween(name2, styleConstant2(name2, i, value), priority).on("end.style." + name2, null);
  }

  // node_modules/d3-transition/src/transition/styleTween.js
  function styleInterpolate(name2, i, priority) {
    return function(t) {
      this.style.setProperty(name2, i.call(this, t), priority);
    };
  }
  function styleTween(name2, value, priority) {
    var t, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0) t = (i0 = i) && styleInterpolate(name2, i, priority);
      return t;
    }
    tween._value = value;
    return tween;
  }
  function styleTween_default(name2, value, priority) {
    var key = "style." + (name2 += "");
    if (arguments.length < 2) return (key = this.tween(key)) && key._value;
    if (value == null) return this.tween(key, null);
    if (typeof value !== "function") throw new Error();
    return this.tween(key, styleTween(name2, value, priority == null ? "" : priority));
  }

  // node_modules/d3-transition/src/transition/text.js
  function textConstant2(value) {
    return function() {
      this.textContent = value;
    };
  }
  function textFunction2(value) {
    return function() {
      var value1 = value(this);
      this.textContent = value1 == null ? "" : value1;
    };
  }
  function text_default2(value) {
    return this.tween("text", typeof value === "function" ? textFunction2(tweenValue(this, "text", value)) : textConstant2(value == null ? "" : value + ""));
  }

  // node_modules/d3-transition/src/transition/textTween.js
  function textInterpolate(i) {
    return function(t) {
      this.textContent = i.call(this, t);
    };
  }
  function textTween(value) {
    var t0, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
      return t0;
    }
    tween._value = value;
    return tween;
  }
  function textTween_default(value) {
    var key = "text";
    if (arguments.length < 1) return (key = this.tween(key)) && key._value;
    if (value == null) return this.tween(key, null);
    if (typeof value !== "function") throw new Error();
    return this.tween(key, textTween(value));
  }

  // node_modules/d3-transition/src/transition/transition.js
  function transition_default() {
    var name2 = this._name, id0 = this._id, id1 = newId();
    for (var groups = this._groups, m = groups.length, j2 = 0; j2 < m; ++j2) {
      for (var group = groups[j2], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          var inherit2 = get3(node, id0);
          schedule_default(node, name2, id1, i, group, {
            time: inherit2.time + inherit2.delay + inherit2.duration,
            delay: 0,
            duration: inherit2.duration,
            ease: inherit2.ease
          });
        }
      }
    }
    return new Transition(groups, this._parents, name2, id1);
  }

  // node_modules/d3-transition/src/transition/end.js
  function end_default() {
    var on0, on1, that = this, id2 = that._id, size = that.size();
    return new Promise(function(resolve, reject) {
      var cancel = { value: reject }, end2 = { value: function() {
        if (--size === 0) resolve();
      } };
      that.each(function() {
        var schedule = set4(this, id2), on = schedule.on;
        if (on !== on0) {
          on1 = (on0 = on).copy();
          on1._.cancel.push(cancel);
          on1._.interrupt.push(cancel);
          on1._.end.push(end2);
        }
        schedule.on = on1;
      });
      if (size === 0) resolve();
    });
  }

  // node_modules/d3-transition/src/transition/index.js
  var id = 0;
  function Transition(groups, parents2, name2, id2) {
    this._groups = groups;
    this._parents = parents2;
    this._name = name2;
    this._id = id2;
  }
  function transition(name2) {
    return selection_default().transition(name2);
  }
  function newId() {
    return ++id;
  }
  var selection_prototype = selection_default.prototype;
  Transition.prototype = transition.prototype = {
    constructor: Transition,
    select: select_default3,
    selectAll: selectAll_default2,
    selectChild: selection_prototype.selectChild,
    selectChildren: selection_prototype.selectChildren,
    filter: filter_default2,
    merge: merge_default2,
    selection: selection_default2,
    transition: transition_default,
    call: selection_prototype.call,
    nodes: selection_prototype.nodes,
    node: selection_prototype.node,
    size: selection_prototype.size,
    empty: selection_prototype.empty,
    each: selection_prototype.each,
    on: on_default2,
    attr: attr_default2,
    attrTween: attrTween_default,
    style: style_default2,
    styleTween: styleTween_default,
    text: text_default2,
    textTween: textTween_default,
    remove: remove_default2,
    tween: tween_default,
    delay: delay_default,
    duration: duration_default,
    ease: ease_default,
    easeVarying: easeVarying_default,
    end: end_default,
    [Symbol.iterator]: selection_prototype[Symbol.iterator]
  };

  // node_modules/d3-ease/src/cubic.js
  function cubicInOut(t) {
    return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
  }

  // node_modules/d3-transition/src/selection/transition.js
  var defaultTiming = {
    time: null,
    // Set on use.
    delay: 0,
    duration: 250,
    ease: cubicInOut
  };
  function inherit(node, id2) {
    var timing;
    while (!(timing = node.__transition) || !(timing = timing[id2])) {
      if (!(node = node.parentNode)) {
        throw new Error(`transition ${id2} not found`);
      }
    }
    return timing;
  }
  function transition_default2(name2) {
    var id2, timing;
    if (name2 instanceof Transition) {
      id2 = name2._id, name2 = name2._name;
    } else {
      id2 = newId(), (timing = defaultTiming).time = now(), name2 = name2 == null ? null : name2 + "";
    }
    for (var groups = this._groups, m = groups.length, j2 = 0; j2 < m; ++j2) {
      for (var group = groups[j2], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          schedule_default(node, name2, id2, i, group, timing || inherit(node, id2));
        }
      }
    }
    return new Transition(groups, this._parents, name2, id2);
  }

  // node_modules/d3-transition/src/selection/index.js
  selection_default.prototype.interrupt = interrupt_default2;
  selection_default.prototype.transition = transition_default2;

  // node_modules/d3-brush/src/brush.js
  var { abs, max: max2, min: min2 } = Math;
  function number1(e) {
    return [+e[0], +e[1]];
  }
  function number2(e) {
    return [number1(e[0]), number1(e[1])];
  }
  var X = {
    name: "x",
    handles: ["w", "e"].map(type),
    input: function(x2, e) {
      return x2 == null ? null : [[+x2[0], e[0][1]], [+x2[1], e[1][1]]];
    },
    output: function(xy) {
      return xy && [xy[0][0], xy[1][0]];
    }
  };
  var Y = {
    name: "y",
    handles: ["n", "s"].map(type),
    input: function(y2, e) {
      return y2 == null ? null : [[e[0][0], +y2[0]], [e[1][0], +y2[1]]];
    },
    output: function(xy) {
      return xy && [xy[0][1], xy[1][1]];
    }
  };
  var XY = {
    name: "xy",
    handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
    input: function(xy) {
      return xy == null ? null : number2(xy);
    },
    output: function(xy) {
      return xy;
    }
  };
  function type(t) {
    return { type: t };
  }

  // node_modules/d3-path/src/path.js
  var pi = Math.PI;
  var tau = 2 * pi;
  var epsilon = 1e-6;
  var tauEpsilon = tau - epsilon;
  function append2(strings) {
    this._ += strings[0];
    for (let i = 1, n = strings.length; i < n; ++i) {
      this._ += arguments[i] + strings[i];
    }
  }
  function appendRound(digits) {
    let d = Math.floor(digits);
    if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);
    if (d > 15) return append2;
    const k = 10 ** d;
    return function(strings) {
      this._ += strings[0];
      for (let i = 1, n = strings.length; i < n; ++i) {
        this._ += Math.round(arguments[i] * k) / k + strings[i];
      }
    };
  }
  var Path = class {
    constructor(digits) {
      this._x0 = this._y0 = // start of current subpath
      this._x1 = this._y1 = null;
      this._ = "";
      this._append = digits == null ? append2 : appendRound(digits);
    }
    moveTo(x2, y2) {
      this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}`;
    }
    closePath() {
      if (this._x1 !== null) {
        this._x1 = this._x0, this._y1 = this._y0;
        this._append`Z`;
      }
    }
    lineTo(x2, y2) {
      this._append`L${this._x1 = +x2},${this._y1 = +y2}`;
    }
    quadraticCurveTo(x1, y1, x2, y2) {
      this._append`Q${+x1},${+y1},${this._x1 = +x2},${this._y1 = +y2}`;
    }
    bezierCurveTo(x1, y1, x2, y2, x3, y3) {
      this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x3},${this._y1 = +y3}`;
    }
    arcTo(x1, y1, x2, y2, r) {
      x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
      if (r < 0) throw new Error(`negative radius: ${r}`);
      let x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
      if (this._x1 === null) {
        this._append`M${this._x1 = x1},${this._y1 = y1}`;
      } else if (!(l01_2 > epsilon)) ;
      else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
        this._append`L${this._x1 = x1},${this._y1 = y1}`;
      } else {
        let x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
        if (Math.abs(t01 - 1) > epsilon) {
          this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
        }
        this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
      }
    }
    arc(x2, y2, r, a0, a1, ccw) {
      x2 = +x2, y2 = +y2, r = +r, ccw = !!ccw;
      if (r < 0) throw new Error(`negative radius: ${r}`);
      let dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
      if (this._x1 === null) {
        this._append`M${x0},${y0}`;
      } else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
        this._append`L${x0},${y0}`;
      }
      if (!r) return;
      if (da < 0) da = da % tau + tau;
      if (da > tauEpsilon) {
        this._append`A${r},${r},0,1,${cw},${x2 - dx},${y2 - dy}A${r},${r},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
      } else if (da > epsilon) {
        this._append`A${r},${r},0,${+(da >= pi)},${cw},${this._x1 = x2 + r * Math.cos(a1)},${this._y1 = y2 + r * Math.sin(a1)}`;
      }
    }
    rect(x2, y2, w, h2) {
      this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}h${w = +w}v${+h2}h${-w}Z`;
    }
    toString() {
      return this._;
    }
  };
  function path() {
    return new Path();
  }
  path.prototype = Path.prototype;

  // node_modules/d3-scale/src/init.js
  function initRange(domain, range) {
    switch (arguments.length) {
      case 0:
        break;
      case 1:
        this.range(domain);
        break;
      default:
        this.range(range).domain(domain);
        break;
    }
    return this;
  }

  // node_modules/d3-scale/src/ordinal.js
  var implicit = Symbol("implicit");
  function ordinal() {
    var index2 = new InternMap(), domain = [], range = [], unknown = implicit;
    function scale(d) {
      let i = index2.get(d);
      if (i === void 0) {
        if (unknown !== implicit) return unknown;
        index2.set(d, i = domain.push(d) - 1);
      }
      return range[i % range.length];
    }
    scale.domain = function(_2) {
      if (!arguments.length) return domain.slice();
      domain = [], index2 = new InternMap();
      for (const value of _2) {
        if (index2.has(value)) continue;
        index2.set(value, domain.push(value) - 1);
      }
      return scale;
    };
    scale.range = function(_2) {
      return arguments.length ? (range = Array.from(_2), scale) : range.slice();
    };
    scale.unknown = function(_2) {
      return arguments.length ? (unknown = _2, scale) : unknown;
    };
    scale.copy = function() {
      return ordinal(domain, range).unknown(unknown);
    };
    initRange.apply(scale, arguments);
    return scale;
  }

  // node_modules/d3-scale-chromatic/src/colors.js
  function colors_default(specifier) {
    var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
    while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
    return colors;
  }

  // node_modules/d3-scale-chromatic/src/categorical/category10.js
  var category10_default = colors_default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

  // node_modules/d3-shape/src/constant.js
  function constant_default4(x2) {
    return function constant() {
      return x2;
    };
  }

  // node_modules/d3-shape/src/path.js
  function withPath(shape) {
    let digits = 3;
    shape.digits = function(_2) {
      if (!arguments.length) return digits;
      if (_2 == null) {
        digits = null;
      } else {
        const d = Math.floor(_2);
        if (!(d >= 0)) throw new RangeError(`invalid digits: ${_2}`);
        digits = d;
      }
      return shape;
    };
    return () => new Path(digits);
  }

  // node_modules/d3-shape/src/array.js
  var slice2 = Array.prototype.slice;

  // node_modules/d3-shape/src/point.js
  function x(p) {
    return p[0];
  }
  function y(p) {
    return p[1];
  }

  // node_modules/d3-shape/src/curve/bump.js
  var Bump = class {
    constructor(context, x2) {
      this._context = context;
      this._x = x2;
    }
    areaStart() {
      this._line = 0;
    }
    areaEnd() {
      this._line = NaN;
    }
    lineStart() {
      this._point = 0;
    }
    lineEnd() {
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    }
    point(x2, y2) {
      x2 = +x2, y2 = +y2;
      switch (this._point) {
        case 0: {
          this._point = 1;
          if (this._line) this._context.lineTo(x2, y2);
          else this._context.moveTo(x2, y2);
          break;
        }
        case 1:
          this._point = 2;
        default: {
          if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x2) / 2, this._y0, this._x0, y2, x2, y2);
          else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y2) / 2, x2, this._y0, x2, y2);
          break;
        }
      }
      this._x0 = x2, this._y0 = y2;
    }
  };
  function bumpX(context) {
    return new Bump(context, true);
  }

  // node_modules/d3-shape/src/link.js
  function linkSource(d) {
    return d.source;
  }
  function linkTarget(d) {
    return d.target;
  }
  function link2(curve) {
    let source = linkSource, target = linkTarget, x2 = x, y2 = y, context = null, output = null, path2 = withPath(link3);
    function link3() {
      let buffer;
      const argv = slice2.call(arguments);
      const s = source.apply(this, argv);
      const t = target.apply(this, argv);
      if (context == null) output = curve(buffer = path2());
      output.lineStart();
      argv[0] = s, output.point(+x2.apply(this, argv), +y2.apply(this, argv));
      argv[0] = t, output.point(+x2.apply(this, argv), +y2.apply(this, argv));
      output.lineEnd();
      if (buffer) return output = null, buffer + "" || null;
    }
    link3.source = function(_2) {
      return arguments.length ? (source = _2, link3) : source;
    };
    link3.target = function(_2) {
      return arguments.length ? (target = _2, link3) : target;
    };
    link3.x = function(_2) {
      return arguments.length ? (x2 = typeof _2 === "function" ? _2 : constant_default4(+_2), link3) : x2;
    };
    link3.y = function(_2) {
      return arguments.length ? (y2 = typeof _2 === "function" ? _2 : constant_default4(+_2), link3) : y2;
    };
    link3.context = function(_2) {
      return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), link3) : context;
    };
    return link3;
  }
  function linkHorizontal() {
    return link2(bumpX);
  }

  // node_modules/d3-zoom/src/constant.js
  var constant_default5 = (x2) => () => x2;

  // node_modules/d3-zoom/src/event.js
  function ZoomEvent(type2, {
    sourceEvent,
    target,
    transform: transform2,
    dispatch: dispatch2
  }) {
    Object.defineProperties(this, {
      type: { value: type2, enumerable: true, configurable: true },
      sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
      target: { value: target, enumerable: true, configurable: true },
      transform: { value: transform2, enumerable: true, configurable: true },
      _: { value: dispatch2 }
    });
  }

  // node_modules/d3-zoom/src/transform.js
  function Transform(k, x2, y2) {
    this.k = k;
    this.x = x2;
    this.y = y2;
  }
  Transform.prototype = {
    constructor: Transform,
    scale: function(k) {
      return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
    },
    translate: function(x2, y2) {
      return x2 === 0 & y2 === 0 ? this : new Transform(this.k, this.x + this.k * x2, this.y + this.k * y2);
    },
    apply: function(point) {
      return [point[0] * this.k + this.x, point[1] * this.k + this.y];
    },
    applyX: function(x2) {
      return x2 * this.k + this.x;
    },
    applyY: function(y2) {
      return y2 * this.k + this.y;
    },
    invert: function(location) {
      return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
    },
    invertX: function(x2) {
      return (x2 - this.x) / this.k;
    },
    invertY: function(y2) {
      return (y2 - this.y) / this.k;
    },
    rescaleX: function(x2) {
      return x2.copy().domain(x2.range().map(this.invertX, this).map(x2.invert, x2));
    },
    rescaleY: function(y2) {
      return y2.copy().domain(y2.range().map(this.invertY, this).map(y2.invert, y2));
    },
    toString: function() {
      return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
    }
  };
  var identity2 = new Transform(1, 0, 0);
  transform.prototype = Transform.prototype;
  function transform(node) {
    while (!node.__zoom) if (!(node = node.parentNode)) return identity2;
    return node.__zoom;
  }

  // node_modules/d3-zoom/src/noevent.js
  function nopropagation2(event) {
    event.stopImmediatePropagation();
  }
  function noevent_default3(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
  }

  // node_modules/d3-zoom/src/zoom.js
  function defaultFilter(event) {
    return (!event.ctrlKey || event.type === "wheel") && !event.button;
  }
  function defaultExtent() {
    var e = this;
    if (e instanceof SVGElement) {
      e = e.ownerSVGElement || e;
      if (e.hasAttribute("viewBox")) {
        e = e.viewBox.baseVal;
        return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
      }
      return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
    }
    return [[0, 0], [e.clientWidth, e.clientHeight]];
  }
  function defaultTransform() {
    return this.__zoom || identity2;
  }
  function defaultWheelDelta(event) {
    return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
  }
  function defaultTouchable() {
    return navigator.maxTouchPoints || "ontouchstart" in this;
  }
  function defaultConstrain(transform2, extent, translateExtent) {
    var dx0 = transform2.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent[1][1]) - translateExtent[1][1];
    return transform2.translate(
      dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
      dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
    );
  }
  function zoom_default2() {
    var filter3 = defaultFilter, extent = defaultExtent, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate = zoom_default, listeners = dispatch_default("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
    function zoom(selection2) {
      selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, { passive: false }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }
    zoom.transform = function(collection, transform2, point, event) {
      var selection2 = collection.selection ? collection.selection() : collection;
      selection2.property("__zoom", defaultTransform);
      if (collection !== selection2) {
        schedule(collection, transform2, point, event);
      } else {
        selection2.interrupt().each(function() {
          gesture(this, arguments).event(event).start().zoom(null, typeof transform2 === "function" ? transform2.apply(this, arguments) : transform2).end();
        });
      }
    };
    zoom.scaleBy = function(selection2, k, p, event) {
      zoom.scaleTo(selection2, function() {
        var k0 = this.__zoom.k, k1 = typeof k === "function" ? k.apply(this, arguments) : k;
        return k0 * k1;
      }, p, event);
    };
    zoom.scaleTo = function(selection2, k, p, event) {
      zoom.transform(selection2, function() {
        var e = extent.apply(this, arguments), t0 = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p, p1 = t0.invert(p0), k1 = typeof k === "function" ? k.apply(this, arguments) : k;
        return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
      }, p, event);
    };
    zoom.translateBy = function(selection2, x2, y2, event) {
      zoom.transform(selection2, function() {
        return constrain(this.__zoom.translate(
          typeof x2 === "function" ? x2.apply(this, arguments) : x2,
          typeof y2 === "function" ? y2.apply(this, arguments) : y2
        ), extent.apply(this, arguments), translateExtent);
      }, null, event);
    };
    zoom.translateTo = function(selection2, x2, y2, p, event) {
      zoom.transform(selection2, function() {
        var e = extent.apply(this, arguments), t = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
        return constrain(identity2.translate(p0[0], p0[1]).scale(t.k).translate(
          typeof x2 === "function" ? -x2.apply(this, arguments) : -x2,
          typeof y2 === "function" ? -y2.apply(this, arguments) : -y2
        ), e, translateExtent);
      }, p, event);
    };
    function scale(transform2, k) {
      k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
      return k === transform2.k ? transform2 : new Transform(k, transform2.x, transform2.y);
    }
    function translate(transform2, p0, p1) {
      var x2 = p0[0] - p1[0] * transform2.k, y2 = p0[1] - p1[1] * transform2.k;
      return x2 === transform2.x && y2 === transform2.y ? transform2 : new Transform(transform2.k, x2, y2);
    }
    function centroid(extent2) {
      return [(+extent2[0][0] + +extent2[1][0]) / 2, (+extent2[0][1] + +extent2[1][1]) / 2];
    }
    function schedule(transition2, transform2, point, event) {
      transition2.on("start.zoom", function() {
        gesture(this, arguments).event(event).start();
      }).on("interrupt.zoom end.zoom", function() {
        gesture(this, arguments).event(event).end();
      }).tween("zoom", function() {
        var that = this, args = arguments, g = gesture(that, args).event(event), e = extent.apply(that, args), p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point, w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]), a = that.__zoom, b = typeof transform2 === "function" ? transform2.apply(that, args) : transform2, i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
        return function(t) {
          if (t === 1) t = b;
          else {
            var l = i(t), k = w / l[2];
            t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k);
          }
          g.zoom(null, t);
        };
      });
    }
    function gesture(that, args, clean) {
      return !clean && that.__zooming || new Gesture(that, args);
    }
    function Gesture(that, args) {
      this.that = that;
      this.args = args;
      this.active = 0;
      this.sourceEvent = null;
      this.extent = extent.apply(that, args);
      this.taps = 0;
    }
    Gesture.prototype = {
      event: function(event) {
        if (event) this.sourceEvent = event;
        return this;
      },
      start: function() {
        if (++this.active === 1) {
          this.that.__zooming = this;
          this.emit("start");
        }
        return this;
      },
      zoom: function(key, transform2) {
        if (this.mouse && key !== "mouse") this.mouse[1] = transform2.invert(this.mouse[0]);
        if (this.touch0 && key !== "touch") this.touch0[1] = transform2.invert(this.touch0[0]);
        if (this.touch1 && key !== "touch") this.touch1[1] = transform2.invert(this.touch1[0]);
        this.that.__zoom = transform2;
        this.emit("zoom");
        return this;
      },
      end: function() {
        if (--this.active === 0) {
          delete this.that.__zooming;
          this.emit("end");
        }
        return this;
      },
      emit: function(type2) {
        var d = select_default2(this.that).datum();
        listeners.call(
          type2,
          this.that,
          new ZoomEvent(type2, {
            sourceEvent: this.sourceEvent,
            target: zoom,
            type: type2,
            transform: this.that.__zoom,
            dispatch: listeners
          }),
          d
        );
      }
    };
    function wheeled(event, ...args) {
      if (!filter3.apply(this, arguments)) return;
      var g = gesture(this, args).event(event), t = this.__zoom, k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p = pointer_default(event);
      if (g.wheel) {
        if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
          g.mouse[1] = t.invert(g.mouse[0] = p);
        }
        clearTimeout(g.wheel);
      } else if (t.k === k) return;
      else {
        g.mouse = [p, t.invert(p)];
        interrupt_default(this);
        g.start();
      }
      noevent_default3(event);
      g.wheel = setTimeout(wheelidled, wheelDelay);
      g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
      function wheelidled() {
        g.wheel = null;
        g.end();
      }
    }
    function mousedowned(event, ...args) {
      if (touchending || !filter3.apply(this, arguments)) return;
      var currentTarget = event.currentTarget, g = gesture(this, args, true).event(event), v2 = select_default2(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p = pointer_default(event, currentTarget), x0 = event.clientX, y0 = event.clientY;
      nodrag_default(event.view);
      nopropagation2(event);
      g.mouse = [p, this.__zoom.invert(p)];
      interrupt_default(this);
      g.start();
      function mousemoved(event2) {
        noevent_default3(event2);
        if (!g.moved) {
          var dx = event2.clientX - x0, dy = event2.clientY - y0;
          g.moved = dx * dx + dy * dy > clickDistance2;
        }
        g.event(event2).zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer_default(event2, currentTarget), g.mouse[1]), g.extent, translateExtent));
      }
      function mouseupped(event2) {
        v2.on("mousemove.zoom mouseup.zoom", null);
        yesdrag(event2.view, g.moved);
        noevent_default3(event2);
        g.event(event2).end();
      }
    }
    function dblclicked(event, ...args) {
      if (!filter3.apply(this, arguments)) return;
      var t0 = this.__zoom, p0 = pointer_default(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t0.invert(p0), k1 = t0.k * (event.shiftKey ? 0.5 : 2), t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);
      noevent_default3(event);
      if (duration > 0) select_default2(this).transition().duration(duration).call(schedule, t1, p0, event);
      else select_default2(this).call(zoom.transform, t1, p0, event);
    }
    function touchstarted(event, ...args) {
      if (!filter3.apply(this, arguments)) return;
      var touches = event.touches, n = touches.length, g = gesture(this, args, event.changedTouches.length === n).event(event), started, i, t, p;
      nopropagation2(event);
      for (i = 0; i < n; ++i) {
        t = touches[i], p = pointer_default(t, this);
        p = [p, this.__zoom.invert(p), t.identifier];
        if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
        else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
      }
      if (touchstarting) touchstarting = clearTimeout(touchstarting);
      if (started) {
        if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() {
          touchstarting = null;
        }, touchDelay);
        interrupt_default(this);
        g.start();
      }
    }
    function touchmoved(event, ...args) {
      if (!this.__zooming) return;
      var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t, p, l;
      noevent_default3(event);
      for (i = 0; i < n; ++i) {
        t = touches[i], p = pointer_default(t, this);
        if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
        else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
      }
      t = g.that.__zoom;
      if (g.touch1) {
        var p0 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
        t = scale(t, Math.sqrt(dp / dl));
        p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
        l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
      } else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
      else return;
      g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
    }
    function touchended(event, ...args) {
      if (!this.__zooming) return;
      var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t;
      nopropagation2(event);
      if (touchending) clearTimeout(touchending);
      touchending = setTimeout(function() {
        touchending = null;
      }, touchDelay);
      for (i = 0; i < n; ++i) {
        t = touches[i];
        if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
        else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
      }
      if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
      if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
      else {
        g.end();
        if (g.taps === 2) {
          t = pointer_default(t, this);
          if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
            var p = select_default2(this).on("dblclick.zoom");
            if (p) p.apply(this, arguments);
          }
        }
      }
    }
    zoom.wheelDelta = function(_2) {
      return arguments.length ? (wheelDelta = typeof _2 === "function" ? _2 : constant_default5(+_2), zoom) : wheelDelta;
    };
    zoom.filter = function(_2) {
      return arguments.length ? (filter3 = typeof _2 === "function" ? _2 : constant_default5(!!_2), zoom) : filter3;
    };
    zoom.touchable = function(_2) {
      return arguments.length ? (touchable = typeof _2 === "function" ? _2 : constant_default5(!!_2), zoom) : touchable;
    };
    zoom.extent = function(_2) {
      return arguments.length ? (extent = typeof _2 === "function" ? _2 : constant_default5([[+_2[0][0], +_2[0][1]], [+_2[1][0], +_2[1][1]]]), zoom) : extent;
    };
    zoom.scaleExtent = function(_2) {
      return arguments.length ? (scaleExtent[0] = +_2[0], scaleExtent[1] = +_2[1], zoom) : [scaleExtent[0], scaleExtent[1]];
    };
    zoom.translateExtent = function(_2) {
      return arguments.length ? (translateExtent[0][0] = +_2[0][0], translateExtent[1][0] = +_2[1][0], translateExtent[0][1] = +_2[0][1], translateExtent[1][1] = +_2[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
    };
    zoom.constrain = function(_2) {
      return arguments.length ? (constrain = _2, zoom) : constrain;
    };
    zoom.duration = function(_2) {
      return arguments.length ? (duration = +_2, zoom) : duration;
    };
    zoom.interpolate = function(_2) {
      return arguments.length ? (interpolate = _2, zoom) : interpolate;
    };
    zoom.on = function() {
      var value = listeners.on.apply(listeners, arguments);
      return value === listeners ? zoom : value;
    };
    zoom.clickDistance = function(_2) {
      return arguments.length ? (clickDistance2 = (_2 = +_2) * _2, zoom) : Math.sqrt(clickDistance2);
    };
    zoom.tapDistance = function(_2) {
      return arguments.length ? (tapDistance = +_2, zoom) : tapDistance;
    };
    return zoom;
  }

  // node_modules/markmap-view/dist/index.js
  var q = typeof navigator < "u" && navigator.userAgent.includes("Macintosh");
  var bt = ordinal(category10_default);
  var J = (e = 1, t = 3, i = 2) => (n) => e + t / i ** n.state.depth;
  var Q = {
    autoFit: false,
    duration: 500,
    embedGlobalCSS: true,
    fitRatio: 0.95,
    maxInitialScale: 2,
    scrollForPan: q,
    initialExpandLevel: -1,
    zoom: true,
    pan: true,
    toggleRecursively: false,
    color: (e) => {
      var t;
      return bt(`${((t = e.state) == null ? void 0 : t.path) || ""}`);
    },
    lineWidth: J(),
    maxWidth: 0,
    nodeMinHeight: 16,
    paddingX: 8,
    spacingHorizontal: 80,
    spacingVertical: 5
  };
  function Et(e) {
    let t = 0;
    for (let i = 0; i < e.length; i++)
      t = (t << 5) - t + e.charCodeAt(i) | 0;
    return (t >>> 0).toString(36);
  }
  function v(e) {
    if (typeof e == "string") {
      const i = e;
      e = (n) => n.matches(i);
    }
    const t = e;
    return function() {
      let n = Array.from(this.childNodes);
      return t && (n = n.filter((s) => t(s))), n;
    };
  }
  function zt(e) {
    var t = 0, i = e.children, n = i && i.length;
    if (!n) t = 1;
    else for (; --n >= 0; ) t += i[n].value;
    e.value = t;
  }
  function Ct() {
    return this.eachAfter(zt);
  }
  function St(e) {
    var t = this, i, n = [t], s, o, h2;
    do
      for (i = n.reverse(), n = []; t = i.pop(); )
        if (e(t), s = t.children, s) for (o = 0, h2 = s.length; o < h2; ++o)
          n.push(s[o]);
    while (n.length);
    return this;
  }
  function wt(e) {
    for (var t = this, i = [t], n, s; t = i.pop(); )
      if (e(t), n = t.children, n) for (s = n.length - 1; s >= 0; --s)
        i.push(n[s]);
    return this;
  }
  function Rt(e) {
    for (var t = this, i = [t], n = [], s, o, h2; t = i.pop(); )
      if (n.push(t), s = t.children, s) for (o = 0, h2 = s.length; o < h2; ++o)
        i.push(s[o]);
    for (; t = n.pop(); )
      e(t);
    return this;
  }
  function Xt(e) {
    return this.eachAfter(function(t) {
      for (var i = +e(t.data) || 0, n = t.children, s = n && n.length; --s >= 0; ) i += n[s].value;
      t.value = i;
    });
  }
  function _t(e) {
    return this.eachBefore(function(t) {
      t.children && t.children.sort(e);
    });
  }
  function Ot(e) {
    for (var t = this, i = At(t, e), n = [t]; t !== i; )
      t = t.parent, n.push(t);
    for (var s = n.length; e !== i; )
      n.splice(s, 0, e), e = e.parent;
    return n;
  }
  function At(e, t) {
    if (e === t) return e;
    var i = e.ancestors(), n = t.ancestors(), s = null;
    for (e = i.pop(), t = n.pop(); e === t; )
      s = e, e = i.pop(), t = n.pop();
    return s;
  }
  function Mt() {
    for (var e = this, t = [e]; e = e.parent; )
      t.push(e);
    return t;
  }
  function Ht() {
    var e = [];
    return this.each(function(t) {
      e.push(t);
    }), e;
  }
  function Tt() {
    var e = [];
    return this.eachBefore(function(t) {
      t.children || e.push(t);
    }), e;
  }
  function jt() {
    var e = this, t = [];
    return e.each(function(i) {
      i !== e && t.push({ source: i.parent, target: i });
    }), t;
  }
  function j(e, t) {
    var i = new _(e), n = +e.value && (i.value = e.value), s, o = [i], h2, a, c, l;
    for (t == null && (t = Ft); s = o.pop(); )
      if (n && (s.value = +s.data.value), (a = t(s.data)) && (l = a.length))
        for (s.children = new Array(l), c = l - 1; c >= 0; --c)
          o.push(h2 = s.children[c] = new _(a[c])), h2.parent = s, h2.depth = s.depth + 1;
    return i.eachBefore(Bt);
  }
  function $t() {
    return j(this).eachBefore(Nt);
  }
  function Ft(e) {
    return e.children;
  }
  function Nt(e) {
    e.data = e.data.data;
  }
  function Bt(e) {
    var t = 0;
    do
      e.height = t;
    while ((e = e.parent) && e.height < ++t);
  }
  function _(e) {
    this.data = e, this.depth = this.height = 0, this.parent = null;
  }
  _.prototype = j.prototype = {
    constructor: _,
    count: Ct,
    each: St,
    eachAfter: Rt,
    eachBefore: wt,
    sum: Xt,
    sort: _t,
    path: Ot,
    ancestors: Mt,
    descendants: Ht,
    leaves: Tt,
    links: jt,
    copy: $t
  };
  var Lt = "2.1.2";
  var Dt = {
    version: Lt
  };
  var { version: Wt } = Dt;
  var Pt = Object.freeze({
    children: (e) => e.children,
    nodeSize: (e) => e.data.size,
    spacing: 0
  });
  function tt(e) {
    const t = Object.assign({}, Pt, e);
    function i(a) {
      const c = t[a];
      return typeof c == "function" ? c : () => c;
    }
    function n(a) {
      const c = h2(o(), a, (l) => l.children);
      return c.update(), c.data;
    }
    function s() {
      const a = i("nodeSize"), c = i("spacing");
      return class U extends j.prototype.constructor {
        constructor(d) {
          super(d);
        }
        copy() {
          const d = h2(this.constructor, this, (p) => p.children);
          return d.each((p) => p.data = p.data.data), d;
        }
        get size() {
          return a(this);
        }
        spacing(d) {
          return c(this, d);
        }
        get nodes() {
          return this.descendants();
        }
        get xSize() {
          return this.size[0];
        }
        get ySize() {
          return this.size[1];
        }
        get top() {
          return this.y;
        }
        get bottom() {
          return this.y + this.ySize;
        }
        get left() {
          return this.x - this.xSize / 2;
        }
        get right() {
          return this.x + this.xSize / 2;
        }
        get root() {
          const d = this.ancestors();
          return d[d.length - 1];
        }
        get numChildren() {
          return this.hasChildren ? this.children.length : 0;
        }
        get hasChildren() {
          return !this.noChildren;
        }
        get noChildren() {
          return this.children === null;
        }
        get firstChild() {
          return this.hasChildren ? this.children[0] : null;
        }
        get lastChild() {
          return this.hasChildren ? this.children[this.numChildren - 1] : null;
        }
        get extents() {
          return (this.children || []).reduce(
            (d, p) => U.maxExtents(d, p.extents),
            this.nodeExtents
          );
        }
        get nodeExtents() {
          return {
            top: this.top,
            bottom: this.bottom,
            left: this.left,
            right: this.right
          };
        }
        static maxExtents(d, p) {
          return {
            top: Math.min(d.top, p.top),
            bottom: Math.max(d.bottom, p.bottom),
            left: Math.min(d.left, p.left),
            right: Math.max(d.right, p.right)
          };
        }
      };
    }
    function o() {
      const a = s(), c = i("nodeSize"), l = i("spacing");
      return class extends a {
        constructor(d) {
          super(d), Object.assign(this, {
            x: 0,
            y: 0,
            relX: 0,
            prelim: 0,
            shift: 0,
            change: 0,
            lExt: this,
            lExtRelX: 0,
            lThr: null,
            rExt: this,
            rExtRelX: 0,
            rThr: null
          });
        }
        get size() {
          return c(this.data);
        }
        spacing(d) {
          return l(this.data, d.data);
        }
        get x() {
          return this.data.x;
        }
        set x(d) {
          this.data.x = d;
        }
        get y() {
          return this.data.y;
        }
        set y(d) {
          this.data.y = d;
        }
        update() {
          return et(this), rt(this), this;
        }
      };
    }
    function h2(a, c, l) {
      const d = (p, m) => {
        const u = new a(p);
        Object.assign(u, {
          parent: m,
          depth: m === null ? 0 : m.depth + 1,
          height: 0,
          length: 1
        });
        const x2 = l(p) || [];
        return u.children = x2.length === 0 ? null : x2.map((y2) => d(y2, u)), u.children && Object.assign(u, u.children.reduce(
          (y2, k) => ({
            height: Math.max(y2.height, k.height + 1),
            length: y2.length + k.length
          }),
          u
        )), u;
      };
      return d(c, null);
    }
    return Object.assign(n, {
      nodeSize(a) {
        return arguments.length ? (t.nodeSize = a, n) : t.nodeSize;
      },
      spacing(a) {
        return arguments.length ? (t.spacing = a, n) : t.spacing;
      },
      children(a) {
        return arguments.length ? (t.children = a, n) : t.children;
      },
      hierarchy(a, c) {
        const l = typeof c > "u" ? t.children : c;
        return h2(s(), a, l);
      },
      dump(a) {
        const c = i("nodeSize"), l = (d) => (p) => {
          const m = d + "  ", u = d + "    ", { x: x2, y: y2 } = p, k = c(p), b = p.children || [], z = b.length === 0 ? " " : `,${m}children: [${u}${b.map(l(u)).join(u)}${m}],${d}`;
          return `{ size: [${k.join(", ")}],${m}x: ${x2}, y: ${y2}${z}},`;
        };
        return l(`
`)(a);
      }
    }), n;
  }
  tt.version = Wt;
  var et = (e, t = 0) => (e.y = t, (e.children || []).reduce((i, n) => {
    const [s, o] = i;
    et(n, e.y + e.ySize);
    const h2 = (s === 0 ? n.lExt : n.rExt).bottom;
    s !== 0 && Kt(e, s, o);
    const a = Ut(h2, s, o);
    return [s + 1, a];
  }, [0, null]), It(e), Qt(e), e);
  var rt = (e, t, i) => {
    typeof t > "u" && (t = -e.relX - e.prelim, i = 0);
    const n = t + e.relX;
    return e.relX = n + e.prelim - i, e.prelim = 0, e.x = i + e.relX, (e.children || []).forEach((s) => rt(s, n, e.x)), e;
  };
  var It = (e) => {
    (e.children || []).reduce((t, i) => {
      const [n, s] = t, o = n + i.shift, h2 = s + o + i.change;
      return i.relX += h2, [o, h2];
    }, [0, 0]);
  };
  var Kt = (e, t, i) => {
    const n = e.children[t - 1], s = e.children[t];
    let o = n, h2 = n.relX, a = s, c = s.relX, l = true;
    for (; o && a; ) {
      o.bottom > i.lowY && (i = i.next);
      const d = h2 + o.prelim - (c + a.prelim) + o.xSize / 2 + a.xSize / 2 + o.spacing(a);
      (d > 0 || d < 0 && l) && (c += d, Gt(s, d), Vt(e, t, i.index, d)), l = false;
      const p = o.bottom, m = a.bottom;
      p <= m && (o = Zt(o), o && (h2 += o.relX)), p >= m && (a = Yt(a), a && (c += a.relX));
    }
    !o && a ? qt(e, t, a, c) : o && !a && Jt(e, t, o, h2);
  };
  var Gt = (e, t) => {
    e.relX += t, e.lExtRelX += t, e.rExtRelX += t;
  };
  var Vt = (e, t, i, n) => {
    const s = e.children[t], o = t - i;
    if (o > 1) {
      const h2 = n / o;
      e.children[i + 1].shift += h2, s.shift -= h2, s.change -= n - h2;
    }
  };
  var Yt = (e) => e.hasChildren ? e.firstChild : e.lThr;
  var Zt = (e) => e.hasChildren ? e.lastChild : e.rThr;
  var qt = (e, t, i, n) => {
    const s = e.firstChild, o = s.lExt, h2 = e.children[t];
    o.lThr = i;
    const a = n - i.relX - s.lExtRelX;
    o.relX += a, o.prelim -= a, s.lExt = h2.lExt, s.lExtRelX = h2.lExtRelX;
  };
  var Jt = (e, t, i, n) => {
    const s = e.children[t], o = s.rExt, h2 = e.children[t - 1];
    o.rThr = i;
    const a = n - i.relX - s.rExtRelX;
    o.relX += a, o.prelim -= a, s.rExt = h2.rExt, s.rExtRelX = h2.rExtRelX;
  };
  var Qt = (e) => {
    if (e.hasChildren) {
      const t = e.firstChild, i = e.lastChild, n = (t.prelim + t.relX - t.xSize / 2 + i.relX + i.prelim + i.xSize / 2) / 2;
      Object.assign(e, {
        prelim: n,
        lExt: t.lExt,
        lExtRelX: t.lExtRelX,
        rExt: i.rExt,
        rExtRelX: i.rExtRelX
      });
    }
  };
  var Ut = (e, t, i) => {
    for (; i !== null && e >= i.lowY; )
      i = i.next;
    return {
      lowY: e,
      index: t,
      next: i
    };
  };
  var nt = ".markmap{--markmap-max-width: 9999px;--markmap-a-color: #0097e6;--markmap-a-hover-color: #00a8ff;--markmap-code-bg: #f0f0f0;--markmap-code-color: #555;--markmap-highlight-bg: #ffeaa7;--markmap-table-border: 1px solid currentColor;--markmap-font: 300 16px/20px sans-serif;--markmap-circle-open-bg: #fff;--markmap-text-color: #333;--markmap-highlight-node-bg: #ff02;font:var(--markmap-font);color:var(--markmap-text-color)}.markmap-link{fill:none}.markmap-node>circle{cursor:pointer}.markmap-foreign{display:inline-block}.markmap-foreign p{margin:0}.markmap-foreign a{color:var(--markmap-a-color)}.markmap-foreign a:hover{color:var(--markmap-a-hover-color)}.markmap-foreign code{padding:.25em;font-size:calc(1em - 2px);color:var(--markmap-code-color);background-color:var(--markmap-code-bg);border-radius:2px}.markmap-foreign pre{margin:0}.markmap-foreign pre>code{display:block}.markmap-foreign del{text-decoration:line-through}.markmap-foreign em{font-style:italic}.markmap-foreign strong{font-weight:700}.markmap-foreign mark{background:var(--markmap-highlight-bg)}.markmap-foreign table,.markmap-foreign th,.markmap-foreign td{border-collapse:collapse;border:var(--markmap-table-border)}.markmap-foreign img{display:inline-block}.markmap-foreign svg{fill:currentColor}.markmap-foreign>div{width:var(--markmap-max-width);text-align:left}.markmap-foreign>div>div{display:inline-block}.markmap-highlight rect{fill:var(--markmap-highlight-node-bg)}.markmap-dark .markmap{--markmap-code-bg: #1a1b26;--markmap-code-color: #ddd;--markmap-circle-open-bg: #444;--markmap-text-color: #eee}";
  var M = "g.markmap-node";
  var te = "path.markmap-link";
  var ee = "g.markmap-highlight";
  var H = linkHorizontal();
  function Y2(e, t) {
    const i = minIndex(e, t);
    return e[i];
  }
  function T(e) {
    e.stopPropagation();
  }
  var re = new Hook();
  var it = class _it {
    constructor(t, i) {
      this.options = { ...Q }, this._disposeList = [], this.handleZoom = (n) => {
        const { transform: s } = n;
        this.g.attr("transform", s);
      }, this.handlePan = (n) => {
        n.preventDefault();
        const s = transform(this.svg.node()), o = s.translate(
          -n.deltaX / s.k,
          -n.deltaY / s.k
        );
        this.svg.call(this.zoom.transform, o);
      }, this.handleClick = (n, s) => {
        let o = this.options.toggleRecursively;
        (q ? n.metaKey : n.ctrlKey) && (o = !o), this.toggleNode(s, o);
      }, this.ensureView = this.ensureVisible, this.svg = t.datum ? t : select_default2(t), this.styleNode = this.svg.append("style"), this.zoom = zoom_default2().filter((n) => this.options.scrollForPan && n.type === "wheel" ? n.ctrlKey && !n.button : (!n.ctrlKey || n.type === "wheel") && !n.button).on("zoom", this.handleZoom), this.setOptions(i), this.state = {
        id: this.options.id || this.svg.attr("id") || getId(),
        rect: { x1: 0, y1: 0, x2: 0, y2: 0 }
      }, this.g = this.svg.append("g"), this.g.append("g").attr("class", "markmap-highlight"), this._observer = new ResizeObserver(
        debounce(() => {
          this.renderData();
        }, 100)
      ), this._disposeList.push(
        re.tap(() => {
          this.setData();
        }),
        () => this._observer.disconnect()
      );
    }
    getStyleContent() {
      const { style: t } = this.options, { id: i } = this.state, n = typeof t == "function" ? t(i) : "";
      return [this.options.embedGlobalCSS && nt, n].filter(Boolean).join(`
`);
    }
    updateStyle() {
      this.svg.attr(
        "class",
        addClass(this.svg.attr("class"), "markmap", this.state.id)
      );
      const t = this.getStyleContent();
      this.styleNode.text(t);
    }
    async toggleNode(t, i = false) {
      var s, o;
      const n = (s = t.payload) != null && s.fold ? 0 : 1;
      i ? walkTree(t, (h2, a) => {
        h2.payload = {
          ...h2.payload,
          fold: n
        }, a();
      }) : t.payload = {
        ...t.payload,
        fold: (o = t.payload) != null && o.fold ? 0 : 1
      }, await this.renderData(t);
    }
    _initializeData(t) {
      let i = 0;
      const { color: n, initialExpandLevel: s } = this.options;
      let o = 0, h2 = 0;
      return walkTree(t, (a, c, l) => {
        var p, m, u, x2;
        h2 += 1, a.children = (p = a.children) == null ? void 0 : p.map((y2) => ({ ...y2 })), i += 1, a.state = {
          ...a.state,
          depth: h2,
          id: i,
          rect: {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          },
          size: [0, 0]
        }, a.state.key = [(m = l == null ? void 0 : l.state) == null ? void 0 : m.id, a.state.id].filter(Boolean).join(".") + Et(a.content), a.state.path = [(u = l == null ? void 0 : l.state) == null ? void 0 : u.path, a.state.id].filter(Boolean).join("."), n(a);
        const d = ((x2 = a.payload) == null ? void 0 : x2.fold) === 2;
        d ? o += 1 : (o || s >= 0 && a.state.depth >= s) && (a.payload = { ...a.payload, fold: 1 }), c(), d && (o -= 1), h2 -= 1;
      }), t;
    }
    _relayout() {
      if (!this.state.data) return;
      this.g.selectAll(v(M)).selectAll(
        v("foreignObject")
      ).each(function(c) {
        var p;
        const l = (p = this.firstChild) == null ? void 0 : p.firstChild, d = [l.scrollWidth, l.scrollHeight];
        c.state.size = d;
      });
      const { lineWidth: t, paddingX: i, spacingHorizontal: n, spacingVertical: s } = this.options, o = tt({}).children((c) => {
        var l;
        if (!((l = c.payload) != null && l.fold)) return c.children;
      }).nodeSize((c) => {
        const [l, d] = c.data.state.size;
        return [d, l + (l ? i * 2 : 0) + n];
      }).spacing((c, l) => (c.parent === l.parent ? s : s * 2) + t(c.data)), h2 = o.hierarchy(this.state.data);
      o(h2);
      const a = h2.descendants();
      a.forEach((c) => {
        const l = c.data;
        l.state.rect = {
          x: c.y,
          y: c.x - c.xSize / 2,
          width: c.ySize - n,
          height: c.xSize
        };
      }), this.state.rect = {
        x1: min(a, (c) => c.data.state.rect.x) || 0,
        y1: min(a, (c) => c.data.state.rect.y) || 0,
        x2: max(
          a,
          (c) => c.data.state.rect.x + c.data.state.rect.width
        ) || 0,
        y2: max(
          a,
          (c) => c.data.state.rect.y + c.data.state.rect.height
        ) || 0
      };
    }
    setOptions(t) {
      this.options = {
        ...this.options,
        ...t
      }, this.options.zoom ? this.svg.call(this.zoom) : this.svg.on(".zoom", null), this.options.pan ? this.svg.on("wheel", this.handlePan) : this.svg.on("wheel", null);
    }
    async setData(t, i) {
      i && this.setOptions(i), t && (this.state.data = this._initializeData(t)), this.state.data && (this.updateStyle(), await this.renderData());
    }
    async setHighlight(t) {
      this.state.highlight = t || void 0, await this.renderData();
    }
    _getHighlightRect(t) {
      const i = this.svg.node(), s = 4 / transform(i).k, o = {
        ...t.state.rect
      };
      return o.x -= s, o.y -= s, o.width += 2 * s, o.height += 2 * s, o;
    }
    async renderData(t) {
      const { paddingX: i, autoFit: n, color: s, maxWidth: o, lineWidth: h2 } = this.options, a = this.state.data;
      if (!a) return;
      const c = {}, l = {}, d = [];
      walkTree(a, (r, g, f) => {
        var E;
        (E = r.payload) != null && E.fold || g(), c[r.state.id] = r, f && (l[r.state.id] = f.state.id), d.push(r);
      });
      const p = {}, m = {}, u = (r) => {
        !r || p[r.state.id] || walkTree(r, (g, f) => {
          p[g.state.id] = r.state.id, f();
        });
      }, x2 = (r) => m[p[r.state.id]] || a.state.rect, y2 = (r) => (c[p[r.state.id]] || a).state.rect;
      m[a.state.id] = a.state.rect, t && u(t);
      let { highlight: k } = this.state;
      k && !c[k.state.id] && (k = void 0);
      let b = this.g.selectAll(v(ee)).selectAll(v("rect")).data(k ? [this._getHighlightRect(k)] : []).join("rect").attr("x", (r) => r.x).attr("y", (r) => r.y).attr("width", (r) => r.width).attr("height", (r) => r.height);
      const z = this.g.selectAll(v(M)).each((r) => {
        m[r.state.id] = r.state.rect;
      }).data(d, (r) => r.state.key), $ = z.enter().append("g").attr("data-depth", (r) => r.state.depth).attr("data-path", (r) => r.state.path).each((r) => {
        u(c[l[r.state.id]]);
      }), S = z.exit().each((r) => {
        u(c[l[r.state.id]]);
      }), w = z.merge($).attr(
        "class",
        (r) => {
          var g;
          return ["markmap-node", ((g = r.payload) == null ? void 0 : g.fold) && "markmap-fold"].filter(Boolean).join(" ");
        }
      ), F = w.selectAll(v("line")).data(
        (r) => [r],
        (r) => r.state.key
      ), N = F.enter().append("line").attr("stroke", (r) => s(r)).attr("stroke-width", 0), B = F.merge(N), L = w.selectAll(v("circle")).data(
        (r) => {
          var g;
          return (g = r.children) != null && g.length ? [r] : [];
        },
        (r) => r.state.key
      ), D = L.enter().append("circle").attr("stroke-width", 0).attr("r", 0).on("click", (r, g) => this.handleClick(r, g)).on("mousedown", T).merge(L).attr("stroke", (r) => s(r)).attr(
        "fill",
        (r) => {
          var g;
          return (g = r.payload) != null && g.fold && r.children ? s(r) : "var(--markmap-circle-open-bg)";
        }
      ), W = this._observer, P = w.selectAll(v("foreignObject")).data(
        (r) => [r],
        (r) => r.state.key
      ), O = P.enter().append("foreignObject").attr("class", "markmap-foreign").attr("x", i).attr("y", 0).style("opacity", 0).on("mousedown", T).on("dblclick", T);
      O.append("xhtml:div").append("xhtml:div").html((r) => r.content).attr("xmlns", "http://www.w3.org/1999/xhtml"), O.each(function() {
        var g;
        const r = (g = this.firstChild) == null ? void 0 : g.firstChild;
        W.observe(r);
      });
      const I = S.selectAll(
        v("foreignObject")
      );
      I.each(function() {
        var g;
        const r = (g = this.firstChild) == null ? void 0 : g.firstChild;
        W.unobserve(r);
      });
      const K = O.merge(P), st = d.flatMap(
        (r) => {
          var g;
          return (g = r.payload) != null && g.fold ? [] : r.children.map((f) => ({ source: r, target: f }));
        }
      ), A = this.g.selectAll(v(te)).data(st, (r) => r.target.state.key), at = A.exit(), ot = A.enter().insert("path", "g").attr("class", "markmap-link").attr("data-depth", (r) => r.target.state.depth).attr("data-path", (r) => r.target.state.path).attr("d", (r) => {
        const g = x2(r.target), f = [
          g.x + g.width,
          g.y + g.height
        ];
        return H({ source: f, target: f });
      }).attr("stroke-width", 0).merge(A);
      this.svg.style(
        "--markmap-max-width",
        o ? `${o}px` : null
      ), await new Promise(requestAnimationFrame), this._relayout(), b = b.data(k ? [this._getHighlightRect(k)] : []).join("rect"), this.transition(b).attr("x", (r) => r.x).attr("y", (r) => r.y).attr("width", (r) => r.width).attr("height", (r) => r.height), $.attr("transform", (r) => {
        const g = x2(r);
        return `translate(${g.x + g.width - r.state.rect.width},${g.y + g.height - r.state.rect.height})`;
      }), this.transition(S).attr("transform", (r) => {
        const g = y2(r), f = g.x + g.width - r.state.rect.width, E = g.y + g.height - r.state.rect.height;
        return `translate(${f},${E})`;
      }).remove(), this.transition(w).attr(
        "transform",
        (r) => `translate(${r.state.rect.x},${r.state.rect.y})`
      );
      const ct = S.selectAll(
        v("line")
      );
      this.transition(ct).attr("x1", (r) => r.state.rect.width).attr("stroke-width", 0), N.attr("x1", (r) => r.state.rect.width).attr("x2", (r) => r.state.rect.width), B.attr("y1", (r) => r.state.rect.height + h2(r) / 2).attr("y2", (r) => r.state.rect.height + h2(r) / 2), this.transition(B).attr("x1", -1).attr("x2", (r) => r.state.rect.width + 2).attr("stroke", (r) => s(r)).attr("stroke-width", h2);
      const ht = S.selectAll(
        v("circle")
      );
      this.transition(ht).attr("r", 0).attr("stroke-width", 0), D.attr("cx", (r) => r.state.rect.width).attr("cy", (r) => r.state.rect.height + h2(r) / 2), this.transition(D).attr("r", 6).attr("stroke-width", "1.5"), this.transition(I).style("opacity", 0), K.attr("width", (r) => Math.max(0, r.state.rect.width - i * 2)).attr("height", (r) => r.state.rect.height), this.transition(K).style("opacity", 1), this.transition(at).attr("d", (r) => {
        const g = y2(r.target), f = [
          g.x + g.width,
          g.y + g.height + h2(r.target) / 2
        ];
        return H({ source: f, target: f });
      }).attr("stroke-width", 0).remove(), this.transition(ot).attr("stroke", (r) => s(r.target)).attr("stroke-width", (r) => h2(r.target)).attr("d", (r) => {
        const g = r.source, f = r.target, E = [
          g.state.rect.x + g.state.rect.width,
          g.state.rect.y + g.state.rect.height + h2(g) / 2
        ], lt = [
          f.state.rect.x,
          f.state.rect.y + f.state.rect.height + h2(f) / 2
        ];
        return H({ source: E, target: lt });
      }), n && this.fit();
    }
    transition(t) {
      const { duration: i } = this.options;
      return t.transition().duration(i);
    }
    /**
     * Fit the content to the viewport.
     */
    async fit(t = this.options.maxInitialScale) {
      const i = this.svg.node(), { width: n, height: s } = i.getBoundingClientRect(), { fitRatio: o } = this.options, { x1: h2, y1: a, x2: c, y2: l } = this.state.rect, d = c - h2, p = l - a, m = Math.min(
        n / d * o,
        s / p * o,
        t
      ), u = identity2.translate(
        (n - d * m) / 2 - h2 * m,
        (s - p * m) / 2 - a * m
      ).scale(m);
      return this.transition(this.svg).call(this.zoom.transform, u).end().catch(noop);
    }
    findElement(t) {
      let i;
      return this.g.selectAll(v(M)).each(function(s) {
        s === t && (i = {
          data: s,
          g: this
        });
      }), i;
    }
    /**
     * Pan the content to make the provided node visible in the viewport.
     */
    async ensureVisible(t, i) {
      var k;
      const n = (k = this.findElement(t)) == null ? void 0 : k.data;
      if (!n) return;
      const s = this.svg.node(), o = s.getBoundingClientRect(), h2 = transform(s), [a, c] = [
        n.state.rect.x,
        n.state.rect.x + n.state.rect.width + 2
      ].map((b) => b * h2.k + h2.x), [l, d] = [
        n.state.rect.y,
        n.state.rect.y + n.state.rect.height
      ].map((b) => b * h2.k + h2.y), p = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        ...i
      }, m = [p.left - a, o.width - p.right - c], u = [p.top - l, o.height - p.bottom - d], x2 = m[0] * m[1] > 0 ? Y2(m, Math.abs) / h2.k : 0, y2 = u[0] * u[1] > 0 ? Y2(u, Math.abs) / h2.k : 0;
      if (x2 || y2) {
        const b = h2.translate(x2, y2);
        return this.transition(this.svg).call(this.zoom.transform, b).end().catch(noop);
      }
    }
    async centerNode(t, i) {
      var x2;
      const n = (x2 = this.findElement(t)) == null ? void 0 : x2.data;
      if (!n) return;
      const s = this.svg.node(), o = s.getBoundingClientRect(), h2 = transform(s), a = (n.state.rect.x + n.state.rect.width / 2) * h2.k + h2.x, c = (n.state.rect.y + n.state.rect.height / 2) * h2.k + h2.y, l = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        ...i
      }, d = (l.left + o.width - l.right) / 2, p = (l.top + o.height - l.bottom) / 2, m = (d - a) / h2.k, u = (p - c) / h2.k;
      if (m || u) {
        const y2 = h2.translate(m, u);
        return this.transition(this.svg).call(this.zoom.transform, y2).end().catch(noop);
      }
    }
    /**
     * Scale content with it pinned at the center of the viewport.
     */
    async rescale(t) {
      const i = this.svg.node(), { width: n, height: s } = i.getBoundingClientRect(), o = n / 2, h2 = s / 2, a = transform(i), c = a.translate(
        (o - a.x) * (1 - t) / a.k,
        (h2 - a.y) * (1 - t) / a.k
      ).scale(t);
      return this.transition(this.svg).call(this.zoom.transform, c).end().catch(noop);
    }
    destroy() {
      this.svg.on(".zoom", null), this.svg.html(null), this._disposeList.forEach((t) => {
        t();
      });
    }
    static create(t, i, n = null) {
      const s = new _it(t, i);
      return n && s.setData(n).then(() => {
        s.fit();
      }), s;
    }
  };

  // node_modules/markmap-toolbar/dist/index.mjs
  var VTYPE_ELEMENT2 = 1;
  var VTYPE_FUNCTION2 = 2;
  var SVG_NS2 = "http://www.w3.org/2000/svg";
  var XLINK_NS2 = "http://www.w3.org/1999/xlink";
  var NS_ATTRS2 = {
    show: XLINK_NS2,
    actuate: XLINK_NS2,
    href: XLINK_NS2
  };
  var isLeaf2 = (c) => typeof c === "string" || typeof c === "number";
  var isElement2 = (c) => (c == null ? void 0 : c.vtype) === VTYPE_ELEMENT2;
  var isRenderFunction2 = (c) => (c == null ? void 0 : c.vtype) === VTYPE_FUNCTION2;
  function jsx2(type2, props) {
    let vtype;
    if (typeof type2 === "string") vtype = VTYPE_ELEMENT2;
    else if (typeof type2 === "function") vtype = VTYPE_FUNCTION2;
    else throw new Error("Invalid VNode type");
    return {
      vtype,
      type: type2,
      props
    };
  }
  var jsxs = jsx2;
  function Fragment2(props) {
    return props.children;
  }
  var DEFAULT_ENV2 = {
    isSvg: false
  };
  function insertDom2(parent2, nodes) {
    if (!Array.isArray(nodes)) nodes = [nodes];
    nodes = nodes.filter(Boolean);
    if (nodes.length) parent2.append(...nodes);
  }
  function mountAttributes2(domElement, props, env) {
    for (const key in props) {
      if (key === "key" || key === "children" || key === "ref") continue;
      if (key === "dangerouslySetInnerHTML") {
        domElement.innerHTML = props[key].__html;
      } else if (key === "innerHTML" || key === "textContent" || key === "innerText" || key === "value" && ["textarea", "select"].includes(domElement.tagName)) {
        const value = props[key];
        if (value != null) domElement[key] = value;
      } else if (key.startsWith("on")) {
        domElement[key.toLowerCase()] = props[key];
      } else {
        setDOMAttribute2(domElement, key, props[key], env.isSvg);
      }
    }
  }
  var attrMap2 = {
    className: "class",
    labelFor: "for"
  };
  function setDOMAttribute2(el, attr2, value, isSVG) {
    attr2 = attrMap2[attr2] || attr2;
    if (value === true) {
      el.setAttribute(attr2, "");
    } else if (value === false) {
      el.removeAttribute(attr2);
    } else {
      const namespace = isSVG ? NS_ATTRS2[attr2] : void 0;
      if (namespace !== void 0) {
        el.setAttributeNS(namespace, attr2, value);
      } else {
        el.setAttribute(attr2, value);
      }
    }
  }
  function flatten2(arr) {
    return arr.reduce((prev2, item) => prev2.concat(item), []);
  }
  function mountChildren2(children3, env) {
    return Array.isArray(children3) ? flatten2(children3.map((child) => mountChildren2(child, env))) : mount2(children3, env);
  }
  function mount2(vnode, env = DEFAULT_ENV2) {
    if (vnode == null || typeof vnode === "boolean") {
      return null;
    }
    if (vnode instanceof Node) {
      return vnode;
    }
    if (isRenderFunction2(vnode)) {
      const {
        type: type2,
        props
      } = vnode;
      if (type2 === Fragment2) {
        const node = document.createDocumentFragment();
        if (props.children) {
          const children3 = mountChildren2(props.children, env);
          insertDom2(node, children3);
        }
        return node;
      }
      const childVNode = type2(props);
      return mount2(childVNode, env);
    }
    if (isLeaf2(vnode)) {
      return document.createTextNode(`${vnode}`);
    }
    if (isElement2(vnode)) {
      let node;
      const {
        type: type2,
        props
      } = vnode;
      if (!env.isSvg && type2 === "svg") {
        env = Object.assign({}, env, {
          isSvg: true
        });
      }
      if (!env.isSvg) {
        node = document.createElement(type2);
      } else {
        node = document.createElementNS(SVG_NS2, type2);
      }
      mountAttributes2(node, props, env);
      if (props.children) {
        let childEnv = env;
        if (env.isSvg && type2 === "foreignObject") {
          childEnv = Object.assign({}, childEnv, {
            isSvg: false
          });
        }
        const children3 = mountChildren2(props.children, childEnv);
        if (children3 != null) insertDom2(node, children3);
      }
      const {
        ref
      } = props;
      if (typeof ref === "function") ref(node);
      return node;
    }
    throw new Error("mount: Invalid Vnode!");
  }
  function mountDom2(vnode) {
    return mount2(vnode);
  }
  var clsToolbarItem = "mm-toolbar-item";
  var clsActive = "active";
  function renderBrand() {
    return /* @__PURE__ */ jsxs("a", { className: "mm-toolbar-brand", href: "https://markmap.js.org/", children: [
      /* @__PURE__ */ jsx2(
        "img",
        {
          alt: "markmap",
          src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAACoFBMVEUAAAAAAAD//wAAAACAgAD//wAAAABVVQCqqgBAQACAQACAgABmZgBtbQAAAABgQABgYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaFQAAAAAAAAAAAAAAAAAHAAARBQIdGAIYEwI/OgJYUQUfHQI+OgJDPgJJRARBPQRJQgRRSwRRTQRIQQRUTgRUUARZUgRSTQRPSQRjWgZORQRfWQZsZAhTTQRNRwRWUAZkXAZOSARUTgZPRwRRSQRoYwZWUQZWTgRbUwZmXQZoXghmXwdqYwdsYwdfVwVmXQdqYgdiWgVpYAl3bgl6cgl4cAqLggw8OAOWjA2Uig1OSAR2bQihlg55cAh5cAh6cQmMgwyOhAyUjA2QhQ2Uiw2Viw2soBCflA+voxGwpRGhlg+hlg+snxGroBGjmBCpnBC0pxKyphKxpRG2qhK0qBK5rBK5rBP/7h3/8B7/8R3/8h3/8R7/8h786x397B3+7R3EtxT66Rz66hz76hz86xz96xz97Bz+7Rz45xz56Bz76hz97Bz97B3MvRX15Rv25Rv45xz66Rz76hz97B3+7R3IuxX05Bv15Bv25Rz56Bz66Ry/sxPAsxPCtRTCthTNvxbZyxfczxfi0xjl1Rnn2Bnr2xrr3Brs3Rru3Rru3xrv3hrw3xrx4Bvx4Rvy4hvz4hvz4xv04xv05Bv14xv15Bv15Rv25Bv25Rv25Rz25hv35hv35xv45xv45xz55xz56Bv56Bz66Rv66Rz76Rv76Rz76hz86hv86xz+7h3/7R3/7h3/7x3/8B3/8B7/8R3/8R4Yqhj5AAAAq3RSTlMAAQECAgIDAwMEBAQFBwgICAwQERITFRYXGBkbHB0eHyQlJyguNTg8RUZISU5PV2FiY2RlZmdqa2xubnJzc3R2d3d3eXl5eXp7fH1+gIGCgoKDg4SEhIWGh4eHiYmJjIyMjZSUlJ+sra+zt7i4uru8ztHV1tbW2d7g4OHi4uPk5ufp7Ozv9fX29/f3+Pj6+vr7+/v7+/v7+/z8/Pz8/f39/f39/f3+/v7+/v7K6J1dAAACHklEQVQ4y2NgwAoYWdi5uLm5GXHIcrLCmMzYpDmAhKCKjoGtp40MFhVsDAwSxmmVEzZu2XvqSLkchjw3g0h445Ybd24vmTN1Usd5X3R5DgaNqgN35sycP2/GxMkTMRVwMOivvtO3YsWUm3duX790EcMKdgbNNXdnnJh1+9T6ipzU+FB0RzIyiFYB5WdfaElUF8TmTQ6GwH39J2bvypMHcpg4MAKKkUGo5s6KWRfyGRh4WJClGEGBCgS8DLobliy/3abMwM8NBYwQjXDgf3ryxOspyKYyg+RFTFwdnYDAzbrw+oLFm9Ot3J3AwNHFTBykQrhg++GDh48cOXzk4P6VZy8s230MyAGCwwcP7iyRBJpiur1n8hQIWHX27NkLi6bAwOSuow5ABeY7OydOhoCFIAULe6E8YFCf8QAqEC86evniZTA4tfLsuRXHr0E4ly9ePF0uC3KnpH1MZBQQxPoVgxyZ5RMdBQaRMc6yIEcihWbQGaA3k9G8CfQoN0pAtSoxCMACihk9qGtBQZ2LHtRIkRUMiqwd2TJADiswsrjQlAGju/o+MLrPNkWo8mFN1ewMWmvBCebQ0rKMJG87QzF0FRwMRuvugpLcrXu3rp7Zs61UCtMZ2nVHbk+fMX/+jMmTp3Sf9MLiULG45q237txaPG3yxPYrYQzYMo60RWbD3E27Ll68Uq+AK+uJqOlZBiSEKGLNnMA0iDfzwrI/NKgBOivk9piPdtUAAAAASUVORK5CYII="
        }
      ),
      /* @__PURE__ */ jsx2("span", { children: "markmap" })
    ] });
  }
  function renderItem({ title, content, onClick }) {
    return /* @__PURE__ */ jsx2("div", { className: clsToolbarItem, title, onClick, children: content });
  }
  var promise;
  function safeCaller(fn) {
    return async (...args) => {
      if (promise) return;
      promise = fn(...args);
      try {
        await promise;
      } finally {
        promise = void 0;
      }
    };
  }
  var _Toolbar = class _Toolbar2 {
    constructor() {
      this.showBrand = true;
      this.registry = {};
      this.el = mountDom2(/* @__PURE__ */ jsx2("div", { className: "mm-toolbar" }));
      this.items = [..._Toolbar2.defaultItems];
      this.register({
        id: "zoomIn",
        title: "Zoom in",
        content: _Toolbar2.icon("M9 5v4h-4v2h4v4h2v-4h4v-2h-4v-4z"),
        onClick: this.getHandler((mm) => mm.rescale(1.25))
      });
      this.register({
        id: "zoomOut",
        title: "Zoom out",
        content: _Toolbar2.icon("M5 9h10v2h-10z"),
        onClick: this.getHandler((mm) => mm.rescale(0.8))
      });
      this.register({
        id: "fit",
        title: "Fit window size",
        content: _Toolbar2.icon(
          "M4 7h2v-2h2v4h-4zM4 13h2v2h2v-4h-4zM16 7h-2v-2h-2v4h4zM16 13h-2v2h-2v-4h4z"
        ),
        onClick: this.getHandler((mm) => mm.fit())
      });
      this.register({
        id: "recurse",
        title: "Toggle recursively",
        content: _Toolbar2.icon("M16 4h-12v12h12v-8h-8v4h2v-2h4v4h-8v-8h10z"),
        onClick: (e) => {
          var _a3;
          const button = e.target.closest(
            `.${clsToolbarItem}`
          );
          const active = button == null ? void 0 : button.classList.toggle(clsActive);
          (_a3 = this.markmap) == null ? void 0 : _a3.setOptions({
            toggleRecursively: active
          });
        }
      });
      this.register({
        id: "dark",
        title: "Toggle dark theme",
        content: _Toolbar2.icon(
          "M10 4a6 6 0 0 0 0 12a6 6 0 0 0 0 -12v2a4 4 0 0 1 0 8z"
        ),
        onClick: () => {
          document.documentElement.classList.toggle("markmap-dark");
        }
      });
      this.render();
    }
    static create(mm) {
      const toolbar = new _Toolbar2();
      toolbar.attach(mm);
      return toolbar;
    }
    static icon(path2, attrs = {}) {
      attrs = {
        stroke: "none",
        fill: "currentColor",
        "fill-rule": "evenodd",
        ...attrs
      };
      return /* @__PURE__ */ jsx2("svg", { width: "20", height: "20", viewBox: "0 0 20 20", children: /* @__PURE__ */ jsx2("path", { ...attrs, d: path2 }) });
    }
    /** @deprecated Set `showBrand` instead. */
    setBrand(show) {
      this.showBrand = show;
      return this.render();
    }
    register(data2) {
      this.registry[data2.id] = data2;
    }
    getHandler(handle) {
      handle = safeCaller(handle);
      return () => {
        if (this.markmap) handle(this.markmap);
      };
    }
    setItems(items) {
      this.items = [...items];
      return this.render();
    }
    attach(mm) {
      this.markmap = mm;
    }
    render() {
      const items = this.items.map((item) => {
        if (typeof item === "string") {
          const data2 = this.registry[item];
          if (!data2) console.warn(`[markmap-toolbar] ${item} not found`);
          return data2;
        }
        return item;
      }).filter(Boolean);
      while (this.el.firstChild) {
        this.el.firstChild.remove();
      }
      this.el.append(
        mountDom2(
          /* @__PURE__ */ jsxs(Fragment2, { children: [
            this.showBrand && renderBrand(),
            items.map(renderItem)
          ] })
        )
      );
      return this.el;
    }
  };
  _Toolbar.defaultItems = [
    "zoomIn",
    "zoomOut",
    "fit",
    "recurse",
    "dark"
  ];
  var Toolbar = _Toolbar;

  // src/markmap.js
  var transformer = new Transformer();
  function processMarkdown(markdown) {
    const lines = markdown.split("\n");
    let newLines = [];
    let inCodeBlock = false;
    let lastHeaderIndex = -1;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const trimmed = line.trim();
      if (trimmed.startsWith("```")) {
        inCodeBlock = !inCodeBlock;
        newLines.push(line);
        lastHeaderIndex = -1;
        continue;
      }
      if (inCodeBlock) {
        newLines.push(line);
        continue;
      }
      if (trimmed === "") {
        newLines.push(line);
        continue;
      }
      if (trimmed.startsWith("#")) {
        newLines.push(line);
        lastHeaderIndex = newLines.length - 1;
        continue;
      }
      if (trimmed.startsWith("- ") || trimmed.startsWith("* ") || trimmed.startsWith(">") || /^\d+\. /.test(trimmed)) {
        newLines.push(line);
        lastHeaderIndex = newLines.length - 1;
        continue;
      }
      if (lastHeaderIndex !== -1) {
        const currentHeader = newLines[lastHeaderIndex];
        newLines[lastHeaderIndex] = `${currentHeader}<br/><span class="markmap-body-text">${trimmed}</span>`;
      } else {
        newLines.push(`- <span class="markmap-body-text">${trimmed}</span>`);
      }
    }
    return newLines.join("\n");
  }
  function renderMarkmaps() {
    const markmapElements = document.querySelectorAll("pre code.language-markmap");
    markmapElements.forEach((el) => {
      const preElement = el.parentElement;
      if (preElement.dataset.markmapRendered) {
        return;
      }
      preElement.dataset.markmapRendered = "true";
      const rawMarkdown = el.textContent;
      let config3 = {};
      try {
        if (el.dataset.markmapConfig) {
          config3 = JSON.parse(el.dataset.markmapConfig);
        }
      } catch (e) {
        console.error("Failed to parse markmap config", e);
      }
      const markdown = processMarkdown(rawMarkdown);
      const { root: root3 } = transformer.transform(markdown);
      const container = document.createElement("div");
      container.classList.add("markmap");
      container.style.position = "relative";
      container.style.width = "100%";
      container.style.height = "auto";
      container.style.minHeight = "150px";
      container.style.border = "1px solid #666";
      container.style.boxSizing = "border-box";
      container.style.borderRadius = "4px";
      if (config3.textColor) container.style.setProperty("--markmap-text-color", config3.textColor);
      if (config3.headingColor) container.style.setProperty("--markmap-circle-fill", config3.headingColor);
      if (config3.circleColor) container.style.setProperty("--markmap-circle-stroke", config3.circleColor);
      if (config3.lineColor) container.style.setProperty("--markmap-line-color", config3.lineColor);
      if (config3.highlightColor) container.style.setProperty("--markmap-highlight-color", config3.highlightColor);
      if (config3.linkColor) container.style.setProperty("--markmap-link-color", config3.linkColor);
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.style.width = "100%";
      svg.style.display = "block";
      const style = document.createElement("style");
      style.textContent = `
      .markmap-node {
        cursor: pointer;
      }
      .markmap-node circle {
        fill: var(--markmap-circle-fill, #11ff84);
        stroke: var(--markmap-circle-stroke, #11ff84);
        stroke-width: 1px;
      }
      .markmap-node text {
        fill: var(--markmap-text-color, #fd9bcc);
        font-family: var(--markmap-font-family, "Fira Code", monospace);
      }
      .markmap-node foreignObject {
        color: var(--markmap-text-color, #fd9bcc);
        font-family: var(--markmap-font-family, "Fira Code", monospace);
      }
      .markmap-node a {
        color: var(--markmap-link-color, #46d2e8);
      }
      .markmap-link {
        stroke: var(--markmap-line-color, #ff0080);
      }
      .markmap-body-text {
        font-weight: normal;
        font-size: 0.9em;
        color: var(--markmap-body-text-color, #fd9bcc);
        display: inline-block;
      }
      /* Highlight/Bold Color Variable mapping */
      .markmap-node foreignObject strong,
      .markmap-node foreignObject em,
      .markmap-node foreignObject b,
      .markmap-node foreignObject i {
        color: var(--markmap-highlight-color, #FF14E0) !important;
      }
    `;
      svg.append(style);
      const toolbar = document.createElement("div");
      toolbar.style.position = "absolute";
      toolbar.style.right = "20px";
      toolbar.style.top = "20px";
      toolbar.style.padding = "0";
      toolbar.style.display = "flex";
      toolbar.style.gap = "8px";
      toolbar.style.flexDirection = "column";
      container.append(svg, toolbar);
      preElement.replaceWith(container);
      const mm = it.create(svg, {
        spacingVertical: 15,
        paddingX: 20,
        maxWidth: 300
      }, root3);
      Toolbar.create(mm, toolbar);
      const updateLayout = async () => {
        await mm.fit();
        const { y2 } = mm.state.rect;
        let calculatedHeight = y2 * 1.5 + 300;
        const MAX_HEIGHT = 900;
        if (calculatedHeight > MAX_HEIGHT) {
          calculatedHeight = MAX_HEIGHT;
        }
        if (calculatedHeight > 0) {
          svg.style.height = `${calculatedHeight}px`;
          container.style.height = `${calculatedHeight}px`;
        }
        await mm.fit();
      };
      const refreshButton = document.createElement("button");
      refreshButton.textContent = "\u21BB";
      refreshButton.type = "button";
      refreshButton.title = "Refresh Layout";
      refreshButton.style.zIndex = "999";
      refreshButton.style.cursor = "pointer";
      refreshButton.style.width = "30px";
      refreshButton.style.height = "30px";
      refreshButton.style.borderRadius = "50%";
      refreshButton.style.border = "1px solid #1f8";
      refreshButton.style.background = "#222";
      refreshButton.style.color = "#1f8";
      refreshButton.style.fontSize = "16px";
      refreshButton.style.display = "flex";
      refreshButton.style.alignItems = "center";
      refreshButton.style.justifyContent = "center";
      refreshButton.style.position = "absolute";
      refreshButton.style.bottom = "10px";
      refreshButton.style.right = "10px";
      refreshButton.onclick = (e) => {
        e.stopPropagation();
        updateLayout();
      };
      container.appendChild(refreshButton);
      const blockEvents = [
        "click",
        "dblclick",
        "mousedown",
        "mouseup",
        "mousemove",
        "wheel",
        "pointerdown",
        "pointerup",
        "pointermove",
        "contextmenu"
      ];
      blockEvents.forEach((evt) => {
        container.addEventListener(evt, (e) => {
          e.stopPropagation();
        });
      });
      (async () => {
        await mm.fit();
        await updateLayout();
      })();
    });
  }
  renderMarkmaps();
  var observer = new MutationObserver(renderMarkmaps);
  observer.observe(document.body, {
    childList: true,
    subtree: true
  });
})();
/*! Bundled license information:

markmap-common/dist/index.mjs:
  (*! @gera2ld/jsx-dom v2.2.2 | ISC License *)

markmap-toolbar/dist/index.mjs:
  (*! @gera2ld/jsx-dom v2.2.2 | ISC License *)
*/
